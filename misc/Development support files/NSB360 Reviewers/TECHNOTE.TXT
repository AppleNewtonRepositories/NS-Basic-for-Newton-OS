NS BASIC Technical Notes:   December 18, 1996=============================================This file contains a number of technical notes about NS BASIC. Asadditional technotes are released, they will be added to this file.Contents: 1. How to control an Infrared remote device 2. How to dump all your notes to the serial port 3. How to get the name of a key of a data file 4. NS BASIC and Graffiti 5. NS BASIC and MoreInfo 6. How to do multi-dimensional arrays 7. How to attach a picture to an entry in Names 8. How to turn NS BASIC into a button on the screen 9. How to do bit manipulation10. How to turn Notes into Programs11. How to use makePict()12. How to Dial using NS BASIC13. NS BASIC and Kanji (and other languages)14. How to download a Names file15. How to send email from NS BASIC16. How to put away items from the In Box from NS BASIC17. How to find lattitude and longitude18. Where does memory go?19. FormattedNumberStr()20. LISTRUN and Import (2.5)21. Some Undocumented Functions22. MessagePad 130 Performance and special functions23. Uploading Packages24. Using Endpoints with NSBASIC25. NS BASIC goes Poof!26. How to make a quick Note27. How to connect from Windows 95  28. Hardware Tidbits                   29. How to access NewtonPress¨                     30. Benchmarks on MP 110 through MP 2000                   31. Widgets By Hand, a detailed example 32. Serial Input/Output33. Accessing and Using Other Files, Data, and Applications34. BASIC Internet Enabler (BIT)NS BASIC Tech Note                                     Oct 27, 1995How to control your TV, CD player, etc from NS BASIC on your Newton-------------------------------------------------------------------1.0 Introduction2.0 Listing3.0 Notes on Listing4.0 IR Remote Control    4.1 Pioneer CD player codes    4.2 Finding codes for your own player    4.3 Why can't my Newton read the codes?1.0 Introduction----------------It's pretty easy to write a program to control infrared remote controlled devices from NS BASIC. In this tech note, we'll show you how to do the basic commands to control the remote: it will be up to you to set up the proper codes for your own devices and make your own controlling program.The following code sample shows how to issue a PLAY command to a Pioneer CD player. The first part of the program sets up the calling sequence; statement 100 actually transmits the command. You'll be changing lines 20 to 90 to suit your own device. 2.0 Listing-----------0010 rem test ir -- ir0020 LET t="01000101101110101110100000010111"0030 LET trans=[0,500,14,50,14,0,8]0035 LET zero="0"[0] // char 0 (not string 0)0040 for i=0 to strLen(t)-10050   addArraySlot(trans,1)0060   if t[i]=zero then addArraySlot(trans,1) else addArraySlot(trans,3)0070 next i0080 addArraySlot(trans,1)0090 addArraySlot(trans,1)0100 sendIRremote(trans,1)3.0 Notes on Listing--------------------In the above example, trans is an array which contains the command string to be sent out the IR port. The following elements make up the array:trans[0]    Command name code; put anything you like in here.trans[1]    TimeBase: number of microseconds in each time unittrans[2]    Lead In: number of time units to transmit before starting commandtrans[3]    Repeat: number of time units to wait before repeating commandtrans[4]    Lead Out: number of time units after the commandtrans[5]    always zero.trans[6...] A sequence of numbers, showing the number of time units            to spend in each state, starting with off.4.0 How IR Remote Controls work-------------------------------IR remote controls are really quite simple: A sequence of flashes, much like signalling with a flashlight, is transmitted. Each command has a different pattern of lengths of time the signal is on or off. Each manufacturer has his own pattern; sometimes different devices from the same manufacturer will even have different patterns.Commands are usually expressed as hex numbers. By converting these to binary, you get the sequence of ONs and OFFs to be sent. Along with the codes, the manufacturer will specify how long the ON and OFF periods have to be to define each of the characters.These periods are usually expressed as a number of time units. Each time unit is a number of microseconds. There may also be a period of time that the signal is sent as a lead in or lead out to the command.The Pioneer, like most consumer units, uses a 40 khz carrier, as does the Newton. For data communications, the standard is to use 500, which is what the Newton does in that mode.4.1 How the Pioneer CD control works------------------------------------The Pioneer does everything in multiples of 500 milliseconds, so trans[1] is set to 500. For a command, the first thing that is expected is a lead in of 14 time units, set in trans[2], followed by no signal for 8 time units, which is in trans[6].The command itself is made up of two parts: a lead in code, which is fixed, and the command code itself. For the the Pioneer CD player, the lead in code is 45BA (base 16) and the command for PLAY is E817. Converting these to binary gives the string "01000101101110101110100000010111" used in the above example.Each binary digit in the Pioneer is transmitted as single time unit ON, followed by a single time unit OFF for 0 and three time units for 1. The example program above is a quick and dirty method for building up the array of ones and threes that is needed: I'm sure more elegant code can be written. In particular, building up the trans array takes too long to be done each time. A nice application could store the completed trans arrays in a file.The end result is the trans[7] and on are a sequence of time units that the signal is to be alternately ON and OFF, starting with ON.For the record (or CD that is), the other codes used on Pioneer CD players are STOP (6897), REW (8877), FF (08F7), PAUSE (18E7), PGM (B04F), TRACK (02FD) and DISC (B847, also 827D)4.2 How do I find the codes for my own player?----------------------------------------------The easiest way is through the internet: ftp to nada.kth.se:home/d89-bga/hp/remote/remotesMany of the common units are documented at this site. If you make a sample bit of code for a new type of remote, email it to us at gh@hookup.net, and we'll put it in our code samples library for all to use.If all else fails, you can always hook up a diode to an oscilliscope and capture the codes from another remote. It doesn't seem to be possible to collect the code directly from another remote to the Newton: the incoming IR filters out frequencies other than those needed for Sharp-type data transmission. This rules out the frequency used by IR remote devices.4.3 Why can't my Newton read the codes?---------------------------------------------This answered by Mike Martin, Apple Assistance Center / PowerBook Support Manager:"The IR module that the Newton OMP, 100, 110, and 120 uses is based on an integrated sub module that SHARP makes .. it integrates transmission and receiving ciruitry in the same module.  The Transmissive IR LED is just straight out, no filtration on the outgoung bandwidth (the modulation of the outbound IR LED is done via software timing -- educated guess).  The inbound IR Reciever is a different story. At the module level, there is a IR bandwith filter of 500Khz.  In an ASK modulated data stream, TVIR is about 40Khz, "SHARP PROTOCOL" IR (off of which the newton bases it's newton-newton communication or "beaming") is at 500Khz.  So the only "incoming" IR data stream that the Newton can actually read is what is passed to it by the IR module made by Sharp.  If the Sharp module is put into recieve mode, it's only going to see signals in the 500Khz range -- IE: it cant "see" the TVIR signals coming from a TV Remote control.There is no hardware way around this from the standpoint of the Newton Hardware -- but there are other ways to sample and decode TVIR waveforms --If you are interested in a really spiffy IR module that can do (send *and* receive) TVIR, SHARP ASK, and IRdA (low Speed), then look at the Crystal Semiconductor CS8130 Multi Standard IR Transciever .. It's a killer chip that does about 90% of the hard work for you."For more detailed information on the Newton transmission protocol for data, see http://www.dstc.edu.au/AU/staff/david-arnold/newton/sharp-ask.html.Now if only the Newton was backlit so we could see our remotes by the light of the TV![Now that we have the 130, let's go channel surfing!]NS BASIC is BASIC for the Newton. For more information, please contact NS BASIC Corp. at 416 264-5999 or at info@nsbasic.com.2. Sending your notes out the Serial Port                January 20, 1996(with the paragraphs in the correct order)----------------------------------------------------------------------------(Contributed by John Schettino js12@gte.com)You can use NS BASIC to send the text of your notes out the serial port. Thisis a simple way to capture note text on your PC or Mac, using a terminalemulator to capture the text and save it to a file.There are some cases where the note text seems to be sent in the wrong order.This happens when you have edited a note on the Newton, rearranging theparagraphs, or when you add new paragraphs in the middle of a note.Each note in the notepad is stored in a record of the notes file. The notesrecord includes a field named "data" that has an array of paragraphs for thecurrent note.Let's say you wrote 3 different paragraps on your newton (tapped to set thecursor in 3 places):OneTwoThreeThis gets you 3 frames in the data[] array of the entry for this note:[{viewStationery:para,viewBounds:{left:12,top:10,right:232,bottom:48},text:"One",viewFont:12291},{viewStationery:para,viewBounds:{left:9,top:80,right:207,bottom:99},text:"Two",viewFont:12291},{viewStationery:para,viewBounds:{left:7,top:122,right:230,bottom:179},text:"Three",viewFont:12291}]Note that the viewBounds.top numbers are in a nice acending order...Dumping these in a loop likerem no error checkingfor i = 0 to length(n.data) -1print n.data[i]next iwould get youOneTwoThreeGreat, but what if you drag the middle line ("Two") below the third. Now on-screen you seeOneThreeTwobut the data[] looks like this:[{viewStationery:para,viewBounds:{left:12,top:10,right:232,bottom:48},text:"One",viewFont:12291},{viewStationery:para,viewBounds:{left:9,top:200,right:207,bottom:219},text:"Two",viewFont:12291},{viewStationery:para,viewBounds:{left:7,top:122,right:230,bottom:179},text:"Three",viewFont:12291}]Only the viewBounds.top/bottom has changed. You'll want to sort these(using your favorite sort routine... how about the built-in sort()?)First, copy the data arraymydata := clone(n.data) // copy the array pointers, but not the framesNext, use sort() to sort the array based on viewbounds.top:Sort( mydata,'|<|, 'viewbounds.top )Now dump them out:rem no error checkingfor i = 0 to length(mydata) -1print mydata[i]next iOneTwoThreeHere is a complete program that sends the text of all notes out theserial port, with the text in the correct order:0010 rem dump all notes to serial port0020 open ch,"notes",timestamp0030 environ io="s0"0040 get ch,n0050 if fstat=1 then goto 01300060 print datentime(n.timestamp)0070 if not n.data or length(n.data)=0 then goto 400073 mydata := clone(n.data) // copy the array pointers, but not theframes0076 sort( mydata,'|<|, 'viewbounds.top )0080 for i=0 to length(n.data)-10090   if n.data.text then print n.data[i].text // skip ink-onlyparagraphs0100 next i0110 print " "0120 GOTO 00400130 rem fin0140 environ io="screen"3. NS BASIC Tech Note                                     Jan 1, 1995How to find out key of a file-------------------------------------------------------------------One of the first things you need to do in accessing someone else'sfiles is figure out what the name of the index variable is for your OPEN andGET statements.Here's a short NS BASIC program that displays all the file names andwhat their indexes are. It uses some functions that are not listed in the NSBASIC manual.* list0010 rem list indexes of all files0011 print "Enter 0 for internal, 1 for card:";0012 input store0020 LET x:=getstores()[store]:getsoupnames()0030 for i=0 to length(x)-10040   print x[i]0060   LET indexes:=getstores()[store]:getsoup(x[i]):getindexes()0065   if length(indexes)=0 then goto 1000070   for j=0 to length(indexes)-10080     print "",indexes[j].path0090   next j0100 next i* runEnter 0 for internal, 1 for card:? 1Calendar          mtgStartDate          mtgAlarmCalendar Notes          mtgStartDate          mtgAlarmindexes.BAS:NSBASIC          LineNoNames          sortOnNotes          timeStampRepeat Meetings          mtgStopDate          mtgAlarmRepeat Notes          mtgStopDate          mtgAlarmSCRATCH.BAS:NSBASIC          LineNoSystem          tagTo do          mtgStartDate          mtgAlarm4. NS BASIC Tech Note                                     Nov 30, 1994NS BASIC and Graffiti                        --------------------------------------------------------------------------A number of users have contacted us about a problem using Graffiti while inthe NS BASIC program editor.To work around a "feature" in the Newton, Graffiti outputs CR & spacewhen the CR character is entered. This keeps the cursor from disappearing fromthe screen in most applications. However, it also keeps NS BASIC from seeingwhen you've entered a CR.We've contacted Graffiti about this. They admit it's a kludge, but the onlyway they could find to deal with the problem. They are currently assessing thesituation to see if there is another way to get around it. It isexpected that other packages will also have problems with their method.Graffiti works properly with NS BASIC for all other functions, otherthan program editing.If you'd like to send further feedback on this to Graffiti, you can email themat joe@palm.com.If you have further questions, please contact us at NS BASIC atinfo@nsbasic.com.Here's a great workaround from an NS BASIC user:"Despite this problem while playing and editing a basic program I still preferto use Graffiti instead of the keyboard.  What I do is put the Graffiti"square" over the keyboard leaving the return key of the keyboard exposed; Ithen use Graffiti as I would normally use only pressing the return key insteadof making the return gesture on the Graffiti square."  -- David Whiteman,dbw@primenet.com5. NS BASIC Tech Note                                     September 1, 1994NS BASIC and MoreInfo                        --------------------------------------------------------------------------You can play around with the data that SilverWARE's MoreInfoapplication adds to your Names file in NS BASIC. Here's a bit of code thatprints out a list of contacts:* list0010 open ch,"names",sortOn0020 get ch,n,"Couper"0025 print "Contacts for" && n.sorton0030 LET m:=n.|moreInfo:SilverWARE|.contacts0040 for i=0 to length(m)-10050   print datentime(m[i].time),m[i].type,m[i].re0060 next i* runContacts for Couper8/18/94 1:11 am     Call      No answerBy using the VARS command, you can see all the data that MoreInfokeeps. Accessthe other fields in the same fashion.* open ch,"system",tag* get ch,s,"moreInfo:SilverWARE"* varsCH: 1FSTAT: 0n:{ sortOn: Couper cardType: 2 phones:[ 555 7995 555-7242 555-4623] company:Maximum Nutrition Ltd. address: 41 Fairway Hdts. city: "Toronto" region:"Ontario" country: "Canada", postal_code: "L3T 3A7" bday: 32080107, name:{first: "Sandra1" class: person last: Couper title: "President"} notes:[]_uniqueID: 1 _modtime: 47666951 MoreInfo:SilverWARE:{ moreInfoItems:[ 5 10 25]department: "Sales" employees:[ Scream] siblings:[ Marko] contacts:[{ Time:47666951 type: "Call" re: "No answer"}]}} M:[{ Time: 47666951 type: "Call" re:"No answer"}] i: 1 s:{ tag: "MoreInfo:SilverWARE" installed: TRUE onlyName:Couper _uniqueID: 31 _modtime: 47666948}*6. NS BASIC Tech Note                                     September 14, 1994How to use multi-dimensional arrays                        --------------------------------------------------------------------------Multidimensional arrays are easy to implement in NS BASIC. To do soeffectively requires a bit more information than is contained in the NS BASICHandbook, dated July 1, 1994.To refer to element (i,j) in a 2 dimensional array A, do the following:A[i][j]To initialize such an array, doDIM A[rows]FOR i=0 to rows  A[i]=ARRAY(cols,0)NEXT iARRAY(x,y) is a handy function not mentioned in the July 1 Handbook. Itreturns an array of x elements, each set to the value y.In this same fashion, arrays of greater than two dimensions can beconstructed.7. NS BASIC Tech Note                                     Aug 14, 1994How to put a picture in your Names slot                --------------------------------------------------------------------------Here's a neat hack in NS BASIC. It puts a PICT into the Notes slot of the Names app. Now, when you beam your business card, you can have acustom designed picture, or perhaps your company logo.Note: To do this, you'll need the NTK, either the live or demo version.NS BASIC isn't strictly needed, but makes it easy.Here's the program:0010 REM put a picture into notes0020 open ch,"Names",sortOn0030 get ch,n,"Henne"0040 LET n.notes=getroot().|txtxfer:NSBASIC|._proto.stepchildren[13]0050 put ch,nHow to:1. Create your graphic in some sort of drawing program. I usedHyperCard.2. Using ResEdit, cut and paste the graphic into a resource file that'sincluded in a project in NTK. Mine was called |txtxfer:NSBASIC|. Make sure you've named the resource in ResEdit ("NSBASIC", in thisexample)3. In the project, define a clPictureView. Set the value of the iconslot to your named resource, and download it. Here's how the completeclPictureView frame should look: {viewFlags: 513,    icon: GetPictAsBits("NSBASIC", nil),    viewFormat: 1,    viewBounds: {top: 2, left: 2, right: 239, bottom: 135},    viewclass: 76 };4. Now, look at the stepchildren slots of your app. You can do this inNS BASIC by typing0010 LET x=getroot().|txtxfer:NSBASIC|._proto.stepchildrenRUNVARSSee which element of stepChildren is your clPictureView. Mine was 13.5. Modify line 40 of the above program to name your application andaddress the correct element of stepChildren.6. Modify line 30 to get your own card in Names7. Run it!NS BASIC has gotta be one of the neatest hacking tools around for theNewton (along with ViewFrame!)[My thanks to Sidney Low, who first figured out how to do this]8. NS BASIC Tech Note                                   January 1, 1995How to turn NS BASIC into a button on the screen           --------------------------------------------------------------------------Suppose you want to leave your NS BASIC program running while you dosomething else on your Newton, and then just bring it back when you're ready.Here's some sample code showing how.0010 rem Park NS BASIC in the corner0020 GOSUB 1000 //hide BASIC0030 stop1000 rem hide BASIC1010 LET base:=getroot().|basic:nsbasic|1020 LET oldBounds=base.viewBounds1030 LET newBounds={left:2, right:60, top:2, bottom: 15}1040 LET w={viewBounds: newBounds, viewJustify: 2, goto: 2000}1050 LET W.viewformat=4*vfround+2*vfpen+vffillwhite+vfframeblack1060 LET w.text="BASIC"1070 window w1,w1080 LET newBounds.bottom=newBounds.bottom+41090 LET newBounds.right=newBounds.right+41100 LET z=setvalue(base,'viewbounds,newBounds)1105 LET X=setvalue(base,'viewflags,1)1110 show w11120 end2000 rem show BASIC2010 LET z=setvalue(base,'viewBounds,oldBounds)2020 LET z=setvalue(base,'viewflags,5)2030 hide w12040 returnNS BASIC itself is contained in a window. What this program does is change thebounds of the NS BASIC window from being the full screen to being just a smallrectangle in the upper left corner.  The viewBounds of the underlying NS BASICwindow are stored in getroot().|basic:nsbasic|.viewbounds. The setValue()function works like a LET statement would, but forces a redraw of the windowif something important (like the viewbounds) changes.9. NS BASIC Tech Note                                     September 13, 1995How to do Bit Manipulation                      --------------------------------------------------------------------------There are four functions not listed in the NS BASIC manual that canhelp you do bit manipulation.They are:BAND(a,b)BOR(a,b)BXOR(a,b)BNOT(a)These functions return the integer result of their operation. A and B must beintegers.Example* PRINT BAND(3,5)* 1Technote: Programs and Notes               -- May 23 1996=========================================================[Contributed by Henry Melton (hmelton@io.com) of Hutto, Texas]One project that I wanted was the ability to move BASIC programs back and forth from notes to NSBASIC.  Moving programs in and out the serial portis easy, and I think it can even be done over the IR port, but I wanted a totally standalone situation where I could build up programs from librarieswhile at an airport or at lunch.  A sample program that writes programs to notes is in the documentation, but I wanted one that would read notes and make it into a program.  I have already turned all the sample program files into Paperback packages.  I wanted to cut and pasteinteresting code into a  note and then read it in.Well, I succeeded, in spite of the Create command only allowing string keys.NSBASIC has the ability to LIST a program to a simple soup and then ENTER it back in allowing code merge.  I wrote a program that reads a note andthen writes it to this simple list soup.  To get around the inability toCreate the soup, I manually list a non-existant range of numbers to asoup.  Here are the steps:Paste the program into the only note in the BASIC folder.in NSBASIC:LIST 1,2,tempRUN Notes2BASNEWENTER temp.txtHere is the code to Notes2BAS for NS BASIC 3.0 and earlier:0010 open o,"temp.txt",recNo0060 LET r=00070 LET sym=intern("BASIC")0080 open x,"notes"0090 get x,y0100 if fstat = 1 then end0110 if y.labels=(sym) then gosub 01300120 GOTO 00900130 rem print contents0140 for i=0 to length(y.data)-10150   LET a$= y.data[i].text0160   GOSUB 0190 //Write Lines0170 next i0180 return0190 REM Write Lines0200 if strlen(a$) = 0 then return0210 GOSUB 0250 //Write First Line0220 if fstat > 0 then stop0230 LET r=r+10240 GOTO 02000250 REM Write First Line0260 LET ret$=chr(13)0270 LET j=strpos(a$,ret$,0)0280 if j=NIL then goto 03800290 LET b$=substr(a$,0,j)0300 LET c$=substr(a$,j+1,NIL)0310 print "writing",r,b$0320 LET t={}0330 LET t.recno=r0340 LET t.text=b$0350 put o,t0360 LET a$=c$0370 return0380 print "writing",r,a$0390 LET t={}0400 LET t.recno=r0410 LET t.text=a$0420 put o,t0430 LET a$=""0440 returnHere is a program that puts a program into the Notes file.This is for Rev 3.5 and higher: the program file layout has changed a bit.10 REM List2Notes V2.120 LET defaultFont=030 LET f=getStores()[1]:getSoupNames()40 LET b=["None -- Exit","All Programs"]50 for i=0 to length(f)-160 LET r=strpos(f[i],":NSBASIC",0)70 if r then addArraySlot(b,f[i])80 next i90 LET wb={Text:"BASIC Program",labelCommands:b,goto:0350,viewbounds:{left:10,right:200,top:50,bottom:80}}100 window b1,wb,"labelpicker"110 show b1120 wait 1000130 cls140 print "    List to Notes -- Choose Program"150 GOTO 0120160 LET fname=b[wb.viewvalue]170 LET ts=time()180 open pch,fname,lineno190 if fstat > 0 then bye200 print fname&&"Copy started."210 LET x=""220 get pch,stmt225 if fstat=1 then goto 260230 if Stmt.text=nil Then goto 0220235 If Stmt.lineno > 199999 Then LET nn=stmt.lineno - 200000240 LET x=x&nn&&Stmt.text&chr(13)250 GOTO 0220260 close pch270 open ch,"notes",timestamp280 if fstat>0 then stop290 LET n={class:'paperroll,data:[{ViewStationery:'para,viewBounds:{left:0,right:239,top:0,bottom:100},text:x}],viewstationery:'paperroll,height:1000,labels:'BASIC, timeStamp:ts}300 If DefaultFont > 0 Then n.data[0].viewfont=defaultFont Else  n.data[0].viewfont=getglobals().userconfiguration.userfont310 put ch,n320 if fstat > 0 then print "Failed." else print "Completed."330 close ch340 return350 if wb.viewvalue = 0 then bye360 if wb.viewvalue = 1 then goto 0390370 GOSUB 0160380 GOTO 0120390 hide400 LET ts=time()410 for fx=2 to length(b)-1420 LET fname=b[fx]430 GOSUB 0180440 LET ts=ts+1450 next fx460 bye11. TechNote: How to use the MakePict() function -- Mar 26, 1995------------------------------------------------------------[Note: This was contributed by Stefen Kienecker(kienecker@mail.ppp.net) ofHamburg, Germany]I send you a non optimized program for drawing a verhulst diagram usingmakepict(). It needs at least 52 kb free heap space and runs about twohours onan MP100.0010 rem verhulst0011 dim an[40]0012 dim xn[40]0013 let w1spec = {viewbounds: {left: 0, right:100, top: 0, bottom:100},viewfill:nofill}0015 GOSUB 8020 //call preload array an0016 GOSUB 8045 //call preload array xn0080 rem calculating section0090 for i = 1 to 390100   let const = i*((4-2.7)/39)+2.70110   let x = random(0,100)/1000120   for z = 1 to 1390130	    let x = const * x * (1-x)0140	    let j = ceiling(x*100)0150	    if z>=100 then gosub 01900160   next z0170 next i0180 end0190 rem drawroutine0200 let an[z-100]=makeline(i-1,j-1,i,j) 0210 let xn[i]=makepict(an,nil)0230 wdraw wr,xn0240 return8010 rem preload of the arrays8020 for ans = 0 to 398030   let an[ans]=makeline(3,3,3,3)8040 next ans8042 return8045 for xns = 0 to 398050   let xn[xns]=makepict(an,nil)8052   window wr,w1spec8053   show wr8054   wdraw wr,xn[xns]8060 next xns8070 returnany attempt to choose a higher dim - say 60 - causes a memory out.[Additional information: makePick(shapeArray, StyleFrame) returns apicture shape created from a series of drawing operations, as a single entity.Thepicture shape returned is in PICT format.]12. NS BASIC TechNoteHow to Dial using NS BASIC               August 30, 1995          --------------------------------------------------------------------------Recently I was in rural France and wanted to check my voicemail. Easy,I thought. But then I discovered the local phones all used pulse dialingand could not generate the tones I needed to control the voicemail.My Newton and NS BASIC come to the rescue. The following program puts 8buttons on the screen which generate the various tones I need to control myvoicemail.The program uses the RAWDIAL(<dialString>,'speaker) function, whichisn't in the NS BASIC handbook.Note the use of the new WSTAT variable to determine the window clickedon. This feature is available with NS BASIC 2.5.0010 rem control voicemail -- dialer0020 LET windows:=80030 LET f:={viewbounds: {left: 10, right: 220}, viewjustify: 2,viewformat: 0}0031 LET f.viewformat:=Vfframeblack+4*vfround+2*vfpen0040 LET ht:=floor(220/windows)0050 cls0060 dim w[windows],wf[windows]0100 for i=0 to Windows-10105   LET wf[i]=f0110   read wf[i].text,wf[i].dialstring,wf[i].goto0150   LET wf[i].viewbounds.top:=i*ht0160   LET wf[i].viewbounds.bottom:=i*ht+ht-50170   window w[i],wf[i]0180   show w[i]0190 next i0200 rem wait for event0210 wait 100000220 GOTO 0200 //wait for event0500 rem get0505 data "Calling Card #","888 555-1010 1234",20000510 data "Voice Mail 1","#555-1212 1234",20000515 data "Voice Mail 2","#555-1313 1234",20000520 data "play/rewind","1",20000530 data "fast forward","3",20000540 data "delete","7",20000550 data "save","9",20000560 data "quit","",90000590 return2000 rem do it2010 wait 1002020 LET x=rawdial(wf[wstat].dialstring,'speaker)2030 GOTO 0200 //wait for event9000 rem fin9010 hide9030 end13. NS BASIC TechNote: NS BASIC and Kanji (and other languages)   September 1, 1994                   --------------------------------------------------------------------------By using Unicodes, special characters in other languages as well as Kanji canbe used with NS BASIC.To use Kanji, you need a Newton with the Kanji font installed. To seethe list of valid fonts on your newton, type PRINT GETGLOBALS().fonts intoNSBASIC. You will see a list of fonts, usually espy, newYork, geneva andMonaco. On Japanese Newtons, you should also see Kanji.Set the viewFont slot in your windowspec to be the font you want. Youcan then use the appropriate unicode codes to see the special charactersyou want to see in your window.For European languages (German, French, etc), a list of unicodecharacters (such as unlauts and accents) is in Appendix C of the Handbook.Many thanks to Yoshiharu Hori, who worked out that "\u58003000826f6cbb"prints his name in Kanji!14. NS BASIC TechNoteHow to download to your Names file  -- February 7,1996--------------------------------------------------------Not making an appearance on Newton OS 2.0 units is the Newton Connection Kit.This leaves people who used to download their name and address files to theirNewtons with no way to do so. It's actually pretty easy to do using NS BASIC and Apple's new Newton Presspackage. All it takes is a bit of work to format the data properly before youdownload it. This method assumes you have a Newton 2.0 unit.Names entries are in a frame. If you put together a string with the contentsof that frame already set up, NS BASIC can insert the entries. (NS BASIC couldalso be used to put together the frame, but in this example, I'm offloadingthat task to the host machine)Here's a sample Names frame:{name: {first:"John",last:"Nadeau"}, company:"The Wine Establishment",address:"250 The Esplanade Suite 104", address2:"", city:"Toronto",region:"ON", postal_code:"M5A 1J2", country:"", email:"", phones: ["861-1331","861-1098","",""], notes: [{text:"Aubry Glazer voice mail 487-5183",viewBounds: {left: 10, top: 7, right:230, bottom: 99}, viewStationery: 'para,viewFont: 18435}], cardType: '1, sorton: "NadeauJohn", class: 'person}In this example, a Hypertalk script was used to create this data from aHypercard address stack. The code used is at the end of this tech note inProgram 2.The resulting file was then pasted into Newton Press, and a package created.It was then downloaded. Running Program 1 copies the data from the file andputs it into the Names soup.There are a couple of other interesting possibilities from this method. As thedata is moved as a package, it can be transferred by a variety of means:downloading by serial or Appletalk connection, as email, as beaming: any way apackage can be moved. Secondly, this method provides a convenient way ofdownloading all sorts of other data to Newtons, such as product files andgraphics.Program 1: Extract Names from a Newton Press package:0010 rem get data from NewtonBook0020 LET pkgRef:=getPkgRef("addresses",getstores()[1])0030 LET pkgInfo:=getPkgRefInfo(pkgRef)0040 LET dataFile:=pkgInfo.parts[0].book.contents[0].data0050 LET p=00060 LET i=00070 open ch,"names",sorton0100 rem mainline0110 GOSUB 1000 //get a record0120 if rec="EOF" then stop0125 LET i=i+10126 PRINT i0130 LET frame:=compile(rec)0140 LET entry:=u:frame()0150 put ch,entry0190 GOTO 0100 //mainline1000 rem get a record1020 LET p1=strPos(datafile,"}" & chr(13),p)1030 if p1=NIL then goto 10501035 LET rec=substr(datafile,p,p1-p+1)1040 LET p=p1+21045 return1050 LET rec="EOF"1060 returnProgram 2: Create data for Newton Press(Note: this is just a sample of how you might do this: you'll have to usewhatever tools you have on your host system to create a similar program)on mouseUp  put "Macintosh HD:Address Export" into f  open file f  go card 1 of bg "file Card"  lock screen  repeat with i=1 to the number of cards of this bg    set cursor to busy    if the number of words of bg field Name is 1 then      put "" into firstname      put bg field Name into lastname    else      put bg field name into firstname      delete the last word of firstname      put the last word of bg field name into lastname    end if    put "name: {" into s    put "first:" & quote & firstname & quote & ",last:" ª    & quote & lastname & quote & "}, " after s    put "company:" & quote & bg field company & quote & ", " after s    put "address:" & quote & bg field address1 & quote & ª    ", address2:" & quote & bg field address2 & quote & ", " after s    put "city:" & quote & bg field city & quote & ", region:" ª    & quote & bg field state & quote & ª    ", postal_code:" & quote & bg field postalCode & quote & ª    ", country:" & quote & bg field country & quote & ", " after s    put "email:" & quote & bg field email & quote & ", " after s    put "phones: [" & quote & bg field phone1 & quote & "," ª    & quote & bg field phone2 & quote & "," after s    put quote & bg field phone3 & quote & "," & quote & ª    bg field phone4 & quote & "], " after s        if bg field notes is not empty then      put the number of chars of bg field notes into lines      put "notes: [{text:" & quote & bg field notes & quote & ", "  & ª      "viewBounds: {left: 10, top: 7, right:230, bottom: " & lines & "}, " & ª      "viewStationery: 'para, viewFont: {family: 'geneva, face: 0, size: 9}}]," after s    end if    put "cardType: '1, " after s    if bg field name is empty then      put bg field company into sortOn      put "'company" into class    else      put lastName & firstName into sortOn      put "'person" into class    end if    put "sorton: " & quote & sortOn & quote & ", " after s    put "class: " & class after s    write "{" & s & "}" & return to file f    go next card of this bg  end repeat  close file f  end mouseUpFurther Enhancement: Getting the type of phone number to appear beside thenumberThe type of the phone number is a subclass of the phone fields. The possiblesubclasses are:homePhoneworkPhonefaxPhoneotherPhonecarPhonebeeperPhonemobilePhonehomefaxPhoneYou could modify the output program to have a number of setClass() calls tofix the types after the frame is complete.15. NS BASIC Tech NoteHow to send email from NS BASIC -- February 14, 1996----------------------------------------------------Requirements: NS BASIC 3.x and Newton OS 2.0.Sending email from NS BASIC is surprisingly easy. You can take virtually anytype of data that BASIC handles and route it to your Out Box. It can then besent out. The default carrier is eWorld.This feature can be used for more than just sending messages to your friends.You could also send data which is to be processed by other computers.Here's some sample code:0010 rem put a mail item into the out box0020 LET transportSym:=getGroupTransport('mail)0030 LET NSBSym:=getroot().|basic:nsbasic|0040 LET item=getroot().(transportSym):newItem(NSBSym)0050 LET item.toRef=[{name: "info",email:"info@nsbasic.com"}]0060 LET item.title="NSBASIC info request"0070 LET item.text="Please send me the latest info!"0080 send('mail, item)Here's what this program is doing:Line 20 gets the name of the mail transport.Line 30 gets the reference to NS BASIC.In line 40, the newItem() function is called to set up a frame, customized formail from NS BASIC.In lines 50-70, we customize that frame by adding some additional information: ToRef is an array of frames where mail is to be sent. Each frame has a nameand an email address. Multiple address can be specified. Title is the title of the message. Note that the first word of the title canbe used to signal how the Put Away function will handle the item: see the TechNote on "How to Handle Items in the In Box". Text is the text of the message. Body is not used in the above message, but can be used to enclose additionalinformation.Finally, the send function in line 80 sends the item on its way.For more information, see the Newton Programmer's Guide: Communications,available onftp://ftp.info.apple.com/Apple.Support.Area/Developer_Services/Newton_Development/docs/. Chapters 2 and 3 deal with transportcommunications.16. NS BASIC Tech NoteHow to Handle Items in the In Box -- February 14,1996------------------------------------------------------Requirements: NS BASIC 3.x and Newton OS 2.0.It's easy to link up the In Box's Put Away feature with NS BASIC. You can haveitems in the In Box automatically picked up by NS BASIC programs and beprocessed.This feature can be used for a variety of applications. You could take theincoming data and update it into your files. You could also have your Newtonautomatically reply to incoming messages: see the Tech note entitled "How tosend email from NS BASIC" for more information.Incoming messages could come from a variety of sources. They could be sent asordinary mail messages through the Internet, or by a specialized email packagesuch as enRoute, from Net Strategy Software.Setting up-----------You first have to tell the InBox which messages should be sent to NS BASIC,and then tell NS BASIC what to do with these messages. Here's some samplecode:0010 rem register with In Box0110 regInBoxApp('|basic:nsbasic|,"NSBASIC")0100 rem set up a putaway function0110 function putaway(x) :chain("PUTAWAY",x)0120 LET getroot().|basic:nsbasic|.putaway:=putawayLine 20 lets the In Box know what to do. The regInBoxApp() function takes twoarguments: the first is the symbolic name of the NS BASIC application. Thesecond is a string that is checked against the beginning of the Title of theincoming message. If they match, the message is sent to NS BASIC when the PutAway button is tapped.Line 110 sets up the function to handle messages which are to be put away. Ituses the same mechanism as other applications which call NS BASIC: the CHAINfunction. The first argument is the name of the NS BASIC program to run, andthe second is the message itself that got passed from the In Box. The formatof the message is a frame, similar in format to the one that get constructedin outgoing messages: see the Tech note entitled "How to send email from NSBASIC" for more information.Line 120 is the trick that makes this all work. We add the putaway function wecreated into the NS BASIC application itself. It will stay there until theNewton is reset - in which case, you'll need to run this program again. Laterrevisions of NS BASIC may very well have this function built in, so theputaway function will stick around.To make the above example a bit more sophisticated, you could have the putawayfunction you define in line 110 use the second word of the Title as the nameof the program to CHAIN to.Processing items----------------In the above example, line 110 set PUTAWAY as the name of the BASIC program tobe run. Here it is:0010 rem PUTAWAY0020 print chainParamThe message being sent is in the variable chainParam: it's a complete framewith lots of information. Slots you're likely to be interested in include:chainParam.titlechainParam.textchainParam.bodyYou can treat this data just like any NS BASIC variable: print it, alter it orwrite it to a file.For more information, see the Newton Programmer's Guide: Communications,available onftp://ftp.info.apple.com/Apple.Support.Area/Developer_Services/Newton_Development/docs/. Chapters 2 and 3 deal with transportcommunications.17. NS BASIC Tech NoteNS BASIC Tech Note: How to find your longitude and latitude    8 Dec 1995-------------------------------------------------------------------------[Contributed by Jonathan Kipling Knight (KKnight-COS3@Kaman.com) of ColoradoSprings, CO]I've been writing astronomy programs in NS BASIC but one of the fundamentalthings was to know your longitude and latitude.  If you look at the frameGetGlobals().userConfiguration.location you'll notice very odd looking numbersfor the longitude and latitude.  I proceeded to do some number analysis onvarious locations and came up with formulae to convert to the numbers thatyou'd get off of a map.  The following is a listing of a program that willdisplay the degrees longitude and latitude of your current location.0010 LET maxInt=pow(2,29)-10020 LET here=GetGlobals().userConfiguration.location0030 IF here.longitude>(maxInt/2) THEN west=1 ELSE west=00040 IF here.latitude>(maxInt/4) THEN south=1 ELSE south=00050 LET longit=360*(here.longitude/maxInt-west)0060 LET latit=360*(here.latitude/maxInt-south)0070 PRINT "You're in ";here.name;" at"0080 PRINT "Longitude (W<0) ";longit;chr(176)0090 PRINT "Latitude (S<0) ";latit;chr(176)I found that the internal representation can pinpoint an object on Earth to anaccuracy of about 7.5 cm. If you'd like a complete list of available locations on your newton look at the elements in GetRoot().|worldclock|.cards.18. NS BASIC Tech Note: Why doesn't the internal RAM add up to 2 Megs?    26Feb 96-------------------------------------------------------------------------------[Contributed by Jonathan Kipling Knight (KKnight-COS3@Kaman.com) of ColoradoSprings, CO]For those of you with Newton 2.0 who were wondering where all of your InternalRAM goes here is some technical trivia.  I was able to find where the rest ofthe 2 Megs went after you take out the 1361k for the "Internal" store and the512k for the System RAM.  Apple made an invisible store called "WorldData"taking up 219k of Internal RAM.  It contains all the location soups like"Cities" and "Countries".  Here is a listing of a program that will make the"WorldData" store visible for as long as you don't ReBoot:0010 LET stores:=GetStores()      // The : is important here0020 LET sp:=GetLocationSoup("Cities")0030 LET q:=Query(sp,{type:'index,indexPath:'_uniqueID})0040 LET e:=u.q:Next()0050 LET st:=EntryStore(e)0060 FOR i=0 to Length(stores)-10070     IF st=stores[i] THEN GOTO 400080 NEXT i0090 AddArraySlot(stores,st)0100 ENDAfter you run this, the new store will show up on any utility that looks atstores and soups.  Open up the Extras Drawer and you'll find new soups in theStorage Folder and you'll find the Memory Info for "WorldData" under the Infoicon.  Any soup browsing utility can now look at the once invisible soups(though they are WriteProtected).19. Tech Note: The FormattedNumberStr Function   -- March 4, 1996-------------------------------------------------------------[Note: This information was originally posted to comp.sys.newton.programmer.Q:      The Newton 1.x documentation and OS included a sprintf-likefunction for formatting numbers called FormattedNumberStr.  The NewtonProgrammer's Guide 2.0 First Edition (beta) says this function is nolonger supported.  How do I format my numbers?A:      You may continue to use FormattedNumberStr.  Here is theFormattedNumberStrAPI that is supported.  FormattedNumberStr should beconsidered to have undefined results if passed arguments other thanthose specified here.FormattedNumberStr(number, formatString)Returns a formatted string representation of a real number. number          A real number.formatString    A string specifying how the number should be formatted.This function works similar to the C function sprintf. The formatStringspecifies how the real number should be formatted; that is, whether touse decimal or exponential notation and how many places to includeafter the decimal point. It accepts the following format specifiers:        %f      Use decimal notation (such as "123,456.789000").        %e      Use exponential notation (such as "1.234568e+05").        %E      Use exponential notation (such as "1.234568E+05").        You can also specify a period followed by a number after the % symbolto indicate how many places to show following the decimal point. ("%.3f" yields "123,456.789" for example.)Note: FormattedNumberStr uses the current values ofGetLocale().numberFormat to get the separator and decimal charactersand settings.  The example strings above are for the US English locale.Known ProblemsOther specifiersDo not use other formatStrings.  Previous releases of the documentationlisted %g and %G as supported specifiers.  The behavior of thesespecifiers has changed with the Newton 2.0 OS.  Given the similaritiesto the sprintf function, it may occur to you to try other sprintfformatting characters.   Specifiers other than above have an undefinedresult and should be considered undocumented and unsupported.Large numbersFormattedNumberStr does not work properly for numbers larger than1.0e24.  If the number is very large the function can cause the Newtondevice to hang.Small numbers or long numbersIf more than 15 characters of output would be generated, for examplebecause you are using %f with large number or a large number of digitsfollowing the decimal, FormattedNumberStr has undefined results, andcan cause the Newton device to hang.RoundingFormattedNumberStr does not guarantee which direction it will round. In the Newton 2.0 OS, it rounds half cases down rather than up or to aneven digit.  If you need a precisely rounded number you should use themath functions Ceiling, Floor, NearbyInt, or Round with suitable math.Trailing decimalsIn early releases of the Newton 1.0 OS, there was a bug inFormattedNumberStr that caused a trailing decimal character to be addedwhen zero decimal positions was specified.  That is,FormattedNumberStr(3.0, "%.0f") resulted in  "3." not "3".  To properlytest for and remove this unwanted extra character you must be sure touse the character specified in the Locale settings and not assume thedecimal character will be a period._________________________________________________________________Bob Ebert, Newton Developer Technical Support, Apple Computer IncMS 305-2A, 5 Infinite Loop, Cupertino, CA  95014   (408) 974-1945Internet: ebert@newton.apple.com  ALink: EBERT  Fax: 408-862-1277Disclaimer: I've been wrong before, and I'll be wrong again...20. Tech Note: The LISTRUN and IMPORT Commands                April 8, 1996-----------------------------------------------------------------------The LISTRUN and IMPORT commands provide a mechanism for distributing NS BASICprograms for users of NS BASIC 2.5 and earlier. These commands were replacedin Rev 3.0 by the MAKEPACKAGE command, and the pages dropped from theHandbook. This Tech Note contains the information from those pages.Saving and Loading RunTime ProgramsYou can create programs that other people can run, even though they do not ownNS BASIC. You can also write programs than other NS BASIC owners can run, butnot examine. These programs are called .i.RunTime programs;. Once created,these programs cannot be viewed by anyone. You can create a RunTime version ofa SAVEed program using the LISTRUN command. We'll create a small program, saveit, and then use the LISTRUN Command to create the RunTime version:0010 REM LISTRUN Example0020 PRINT "Hidden Program"0030 END* SAVE listRunExamplelistRunExample saved.* LISTRUN//START,listRunExample,9/23/94 1:33 pm,Version 1.02'0+02*((=ZNWkXV75628sYSwJNKEjorsrmvwvy_.V$5P"a$XY_3Xp*-5=9*"MNXYZR$'_9<g>5.//ENDNotice the output of the LISTRUN Command. This text represents the smallprogram in a way that does not reveal the NS BASIC program text. When you use a serial terminal with NS BASIC, you can copy a RunTime programout of the communications software you use with your desktop computer and saveit to a file.You can use a text version of a RunTime program with any version of NS BASIC.To load a RunTime program into NS BASIC, you must connect the Newton to adesktop computer. See the Using NS BASIC With a Computer or Terminal sectionof this Handbook for more information.Once the Newton and desktop computer are connected, you use the IMPORT commandto load the RunTime program. The IMPORT Command will display a prompt when itis ready to begin loading a RunTime program. At this time, you can use copyand paste to enter the text of the RunTime program into your communicationssoftware. NS BASIC will process the file, and save an executable butunLISTable version onto the Newton. This is an example session showing theIMPORT Command:* NEW* IMPORTInitializing ImportPaste RunTime Program to serial port now!* //START,listRunExample,9/23/94 1:33 pm,Version 1.02'0+02*((=ZNWkXV75628sYSwJNKEjorsrmvwvy_.V$5P"a$XY_3Xp*-5=9*"MNXYZR$'_9<g>5.//ENDSaving as listRunExample.BAS:NSBASICWrite out .txt file...0* 1* 2* Compiling...Saving listRunExample.BAS:NSBASIC...Import complete.* DIRlistRunExample           BASIC program* LOAD listRunExample* LIST* RUNHidden Program* -----------------------------------------------------------------------LISTRUN	CommanddescriptionLISTRUN produces a specially encoded version of a program called a RunTimeprogram. It outputs the program in a printable but unreadable form.This output can be sent to another Newton using a serial connection.The IMPORT Command is used at the other end to SAVE the RunTime as a NS BASICprogram which can be executed but not LISTed.To create a RunTime file that may be used by others, LOAD your program andtype LISTRUN while connected via a serial terminal. You will see a textversion of your program displayed. Copy this text via cut and paste and saveit. Other people may LOAD and RUN this special text version using the IMPORTCommand.Lines in Runtime files that start with // are comments and annotations. Theydo not turn into code. You may add additional // lines to provide somedocumentation with your RunTime program.The //START line is used by NS BASIC during IMPORT processing. It includes theprogram name, the date and time the Runtime was created, and the version of NSBASIC that was used to create it.If the word "overwrite" appears anywhere on the //START line, the incomingprogram will overwrite a program of the same name that exists on the Newton.If you omit the overwrite word and a program of the same name exists on theNewton the IMPORT will be rejected and the following message is displayed:programName already exists.Delete and Import again.Each line contains a checksum to guard against data corruption.example: creating runtime program10 REM LISTRUN Example20 PRINT "Hidden Program"30 endoutput* save listRunExamplelistRunExample saved.* listrun//START,listRunExample,9/23/94 1:33 pm,Version 1.02'0+02*((=ZNWkXV75628sYSwJNKEjorsrmvwvy_.V$5P"a$XY_3Xp*-5=9*"MNXYZR$'_9<g>5.//END-----------------------------------------------------------------------IMPORT	CommanddescriptionThe IMPORT Command is used to LOAD a RunTime file as a NS BASIC program whichcan be executed but not LISTed.You must connect the Newton to a desktop computer with a serial cable in orderto use the IMPORT Command.Lines in RunTime files that start with // are comments and annotations. Theydo not turn into code. You may add additional // lines to provide somedocumentation with your RunTime program.The //START line is used by NS BASIC during IMPORT processing. It includes theprogram name, the date and time the RunTime was created, and the version of NSBASIC that was used to create it.If the word "overwrite" appears anywhere on the //START line, the incomingprogram will overwrite a program of the same name that exists on the Newton.If you omit the overwrite word and a program of the same name exists on theNewton the IMPORT will be rejected and the following message is displayed:programName already exists.Delete and Import again.Each line contains a checksum to guard against data corruption.example: loading a runtime program* new* importInitializing ImportPaste RunTime Program to serial port now!* //START,listRunExample,9/23/94 1:33 pm,Version 1.02'0+02*((=ZNWkXV75628sYSwJNKEjorsrmvwvy_.V$5P"a$XY_3Xp*-5=9*"MNXYZR$'_9<g>5.//ENDSaving as listRunExample.BAS:NSBASICWrite out .txt file...0* 1* 2* Compiling...Saving listRunExample.BAS:NSBASIC...Import complete.* dirlistRunExample           BASIC program* load listRunExample* list* runHidden Program* 21. NS BASIC Tech Note: Global Functions                    29 April 1996.-------------------------------------------------------------------------Contributed by Jonathan Kipling Knight (KKnight-COS3@Kaman.com), ColoradoSprings, CO.If you are interested in knowing everything your MessagePad can do, you mightbe frustrated to find out that most of the global functions in NOS 2.0 areeither hidden or undocumented.  In an endeavor to fill the void that Apple hascreated I've been compiling a list of functions I've found in explorations ofthe internal architecture.  In NOS 1.3, Apple had visible 619 global functionsin GetGlobals().functions.  When I upgraded to 2.0 they were all madeinvisible.  After many searches I was finally able to write an NS BASICprogramto find all the references to the functions.  I have now compiled a list of1252 functions. All the ROM functions (1246) occur in the magic pointer object@4098 but be very carefull in handling this object -- it is very large.  Fourof the slots in @4098 do not have functions as values so they need softwareoverrides to be used.  The following table summarizes what is documented fromvarious sources.		Fns	Not	Source	Doc'd	in 2.0	------	-----	------	B	 74	0	A	218	0	P	273	4	W	397	13	------	-----	------	Union	399	15Sources:B -  NS BASIC Handbook by George Henne. 1995. NS BASIC Corp.A - The NewtonScript Programming Language by Apple Computer, Inc. Feb 21, 1996(http://dev.info.apple.com/newton/techinfo/techinfo.html)P - Programming for the Newton by Julie McKeehan and Neil Rhodes. 1994AcademicPress.W - Wireless for the Newton by Julie McKeehan and Neil Rhodes. 1995 AcademicPress.That leaves at least 868 undocumented functions that currently exist in NOS2.0.  The following is a list of some of the more interesting ones I've beenable to figure out.AnnoyUser()	This will do the annoying three beeps you hear	for a meeting.  It returns nil.BadWickedNaughtyNoot(object1,object2)	This function prints the objects to the inspector	but besides that I haven't been able to figure	anything out.  Nifty name though.BatteryStatus(integer)	This call will return an information frame on	the battery supplies.  If the input is 0 then	the main source (AA cells or AC).  If the input	is 1 then the lithium backup battery.  One	interesting bit of info in the frame is the	actual voltage of the source.CircleDistance(long1,lat1,long2,lat2,x)	This returns the km between two positions rounded	to the nearest 10 km.  The longitude and latitude	must be the integer form that is stored in the	Newton.  They are described in more detail in the	Tech Note "How to find your Longitude and Latitude."	As far as I can tell, x is unused.Clicker()	This will produce a click with random tone.DESCreatePasswordKey(string)	A call to this will return a DES encrypted key to	the inputed string.  The key is 8 bytes long and	of Class deskey.Gestalt(integer)	If integer is 16777219,16777220,16777222,16777225	then this returns a wealth of information on the	system that your operating under.	Gestalt(16777219).ScreenResolutionX provides the number	of pixels per inch (85 for MessagePad 120) of your screen	in the X direction (similarly for Y).GetCardInfo()	This will return a frame of chip information on	the card that is inserted in your card slot.GetCityEntry(string)	This will return an array of entries in the	"cities" soup whose name matches the string.GetHeapStats(frameOrNil)	If you input a frame or nil it will return a	frame of information on the byte useage of	the heap.  I don't know what the numbers mean.GetOrientation()	This returns 0 if in portrait mode or 3 if in	landscape mode.InitiatePlan9()	Sounds scary but does no damage.  This was part 	of the Area 51 Easter Egg that the CIA forced 	Apple to take out.  Executing this function will	change all the icons in the Dates application to	little spacemen and spaceships.  It returns a	frame with the new icons.LatitudeToString(integer)	This and its counterpart for Longitude return a	string of the degrees and minutes with N/S.  The	input is Newton's internal representation number.	They effectively replace the routines in the Tech	Note "How to find your Longitude and Latitude."ReBoot()	This will reboot your computer.Ref(integer)	This function will return an object that is attached	to the integer.  Every non-immediate value has an	integer associated with it.  Plug that integer into	Ref and you'll get the value back.  For instance,	Ref(699) returns the proto frame for endpoints @174.RefOf(object)	This is the opposite of Ref and will return an	integer associated with the object.StrParse(string,delimString)	This will return an array of strings from the first	input parsed according to the second.Functions too scary to experiment with:AddProcrastinatedSend(a,b,c,d,e)PowerOffJooHooShuuShuu(x)PowerOffYobiKaiGi(x)PackageEntryFromThingy(x)SetTimeHardware(x)ViewAutopsy(x)These are all great functions to work with but as Apple says: "Undocumentedfunctions, methods and data objects are not supported nor are they guarenteedto work in future Newton devices. Using them may produce undesirable effectsoncurrent and future Newton devices."22. NS BASIC Tech Note: MessagePad 130 Performance (Revised) May 7, 1996--------------------------------------------------------------------(Note: These performance tests were done with NS BASIC 3.50, butshould be fairly applicable to most other Newton applications. Inour original tests, we found significant speed improvements whenrunning our benchmarks. Thanks to Flash Sheridan, who pointed outthat a Newton runs much faster after a cold reboot than it will afterseveral months of use.)In the marketing literature for the MP 130, Apple stressed thebacklighting and increased memory, without mentioning any possibleeffect on performance.The MP 130 is somewhat faster than the MP 120 with NOS 2.0 in almost all operations.Here's a summary:Execution      about the sameScreen I/O     1.1 times fasterFile I/O       1.2 times fasterNS BASIC launched in about 2/3 the time. The NS BASIC standard benchmark program compiled in a bit more than half the time, and ran1.1 times faster overall.[Tests were run using NS BASIC 3.5 with Visual Designer, from the samememory card in two different MessagePads. Both units were reset before the tests were run.]Conclusion: When it comes to getting more performance from your Newton, you'll probably do better by doing a backup/cold reset/restoreof your Newton than upgrading to an MP 130.Mea Culpa: We apoligize for the earlier misleading results. We ranthe tests carefully, and they were consistant with the results wegot from other developers. It was widely believed that a warm resetwould clear up any memory usage: the discovery that it takes a coldreset to completely do this should be of benefit to all Newton users.New functions for NS BASIC users in the MessagePad 130------------------------------------------------------The Message Pad 130 supports some new functions that can be used from NS BASIC. They are used just like any other function.BackLightPresent() - Returns true if the unit has a backlightBackLightStatus() - Returns true if the backlight is onBackLight(TRUE) - Turns the backlight onBackLight(NIL) - Turns the backlight offNS BASIC Tech Note: Uploading NS BASIC packages         Dec 16, 1996--------------------------------------------------------------------[Applies to NS BASIC 3.0 and higher]Once you've created an package in the Extras drawer using theMAKEPACKAGE command, you'll want some way to get to off the Newton soyou can give it to someone else to run.There are a number of packages which will allow you to this.Here's where you can find them:X-Port: Mac and Windows:http://www.landware.comNewton Package Uploader (Mac only)http://www1.netaxs.com:8080/~weyer/newton/toolinfo.htm#NPUPackage Buddy (Mac only)http://rainbow.rmii.com/~rbruce/tactile/shareware.htmlRemember, you're welcome to distribute packages you've created with NS BASIC freely. You may not, however, give anyone else your copy ofNS BASIC itself.24. NS BASIC Tech Note: Using Endpoints with NSBASIC  6 JUNE 1996.------------------------------------------------------------Contributed by Jonathan Kipling Knight (KKnight-COS3@Kaman.com), Colorado Springs, CO.[Note: NS BASIC provides a standard, easy to use interface to communications, based on the INPUT and PRINT statements. WIth Rev 3.5, we also provided a more direct interface to the underlying communications in the Newton. While this is more complex to use, it is also much more powerful. Here'a a tech note showing how to roll your own communications - Ed.]If you have a special purpose for a program that involves talking to the outside world, you might be glad to see the large document "Newton Programmers Guide: Communications" at http://dev.info.apple.com/newton/techinfo/techinfo.html.  This document was designed to be used with Newton 2.0 in conjunction with the Newton ToolKit.  If you planned to use endpoints with NSBASIC then you'll run into a snag.  Apple doesn't provide the values of the necessary constants to start communicating.  The following is a list of constants that are missing from that document.Constants missing from NPG:CommunicationsProtos:oldProtoEndpoint        @174  // provided for compatibility with NOS 1.xprotoBasicEndpoint      @383  // the normal proto for endpointsprotoStreamingEndpoint  @466  // use to "stream" large objects onto storesServices:kCMSMNPID               "mnps"  // Asynchronous Serial with MNP CompressionkCMSSlowIR              "slir"  // InfraredkCMSModemID             "mods"  // ModemkCMSAsynchSerial        "aser"  // Asynchronous SerialkCMSAppleTalkID         "atlk"  // AppleTalkThe following listing is the special purpose that drove me to find these missing constants.  It is a program that calls up the NIST Atomic Clock computer (located in Boulder, Colorado) and sets the Newton's time to the received time strings.  This is a working program but could use some more error checking and state checking to make it dependable.  It's offered here to provide an example of how to set up and use endpoints with NSBASIC.  The functions are extended for clarity and should be typed in without carriage returns.0010  LET kCMSModemID="mods"0020  LET protoBasicEndpoint:=@3830030  LET opSetRequired=5120040  LET unicodeLF=chr(10)0050  LET unicodeCR=chr(13)0060  LET EOL:=Stringer([unicodeCR,unicodeLF]) // End of Line characters0070  LET OTM:="*"  // Character received on the seconds mark0080  LET connectService={label:kCMSModemID,type:'service,opCode:opSetRequired}0090  LET dialOps:=MakeModemOption()  // Gets Extras\Prefs\Modem options0100  LET initConfig=[connectService,dialOps]0110  LET NISTAddress=MakePhoneOption("1(303)494-4774")0120  LET ep={_proto:protoBasicEndpoint}0130  FUNCTION InitFunc(ep,data,term,ops)      begin      SetValue(u.inWindow,'text,data);      if StrPosExact(data,"<OTM>",0) then       ep:SetInputSpec(u.rxTimeSpec);      end0140  FUNCTION RxTimeFunc(ep,data,term,ops)      begin      local dt;      SetValue(u.inWindow,'text,data);      dt:=u:DecodeNISTTime(data);      if Abs(dt-TimeInSeconds())<60*60 then       begin       SetTimeInSeconds(dt);       u:FinishConnect(ep);       end;      end0150  FUNCTION DecodeNISTTime(data)      begin      local dst,ds,secs,hrPos:=StrPos(data,":",0)-2;      ds:=StringToNumber(SubStr(data,hrPos+9,2));      dst:=if ds<51 and ds<>0 then 3600 else 0;      secs:=(StringToNumber(SubStr(data,hrPos-15,5))-48988)*86400;      secs:=secs+(StringToTime(SubStr(data,hrPos,5))-StringToTime("00:00"))*60;      secs:=secs+StringToNumber(SubStr(data,hrPos+6,2));      secs:=secs+dst+GetUserConfig('location).gmt;      RintToL(secs) end0160  FUNCTION FinishConnect(ep)      begin      ep:SetInputSpec(nil);      ep:FlushInput();      ep:Disconnect(True,nil);      ep:UnBind(nil);      end0170  LET initSpec={termination:{endSequence:EOL},form:'string, inputScript:InitFunc}0180  LET rxTimeSpec={termination:{endSequence:OTM},form:'string, inputScript:RxTimeFunc}0190  LET inWindow:={text:"",viewBounds:RelBounds(5,5,230,50)}0200  WINDOW inW,inWindow0210  SHOW inW0220  u.ep:Instantiate(ep,initConfig)0230  u.ep:Bind(nil,nil)  // bind endpoint to service0240  u.ep:Connect(NISTAddress,{reqTimeout:30000}) // Stop calling after 30 secs0250  u.ep:SetInputSpec(initSpec)  // Start receiving0260  WAIT 30000 // Wait 30 secs for connection to finish0270  u.ep:Dispose()  // Dispose endpoint0280  HIDE0290  ENDAll of the other services can be used in a similar manner if you use the above constants and follow NPG:Communications.  BASIC 3.5 now provides for more communication services but for highly specialized communications, it is possible to use endpoints directly.  By the way, the above program makes a 2-5 second phone call so it shouldn't increase your phone bill by much.  I've seen it at 15 cents a call.25. NS BASIC Tech Note: NS BASIC goes Poof!           July 24, 1996                      --------------------------------------------------------------------------I have been playing around with using viewffects for providing animaton whenopening/closing windows.  I have used ones such as DrawerEffect andBarnDoorOpenEffect.  These are nice to provide some variation in the openingand closing of windows.  I had been wanting, though without much luck, to beable to make windows close with the poof & clouds you get when scrubbing outsomething.Through the help of Micael Engber (and his article in PIE Developers), JamesThiele, Oliver Veolckers, John Schettino, and Steve Weyers I have been ableto make it work in NS BASIC.  Without the help from these people, I wouldstill be struggling along.  Immediately below is the expanded code forclarity, followed by the exact BASIC code.  If you do "poof out" a window, itis best not to use an opening veiwEffect because it makes the ending screenrefresh non-standard.The Detailed code:// Provide the windowSpec of the window to be "poofed" to the functionFUNCTION poofItsGone(winToHide)begin// Isolate the original window spec so it isn't modified     local poofBox := Clone(winToHide.viewBounds);// copy the clouds     local bma:=[Clone(@53), Clone(@54), Clone(@55)];// You must make the cloud bigger to cover the whole window (or the cornerswill// still show).  Make the number (3 below) bigger or smaller as required (asmaller// number will make the cloud larger, a larger number will make it smaller)     local qWidth := (poofBox.right - poofBox.left) DIV 3;     local qHeight := (poofBox.bottom - poofBox.top) DIV 3;// Adjust the sides of the new viewbounds.     poofBox.top := poofBox.top - qHeight;     poofBox.left := poofBox.left - qWidth;     poofBox.bottom := poofBox.bottom + qHeight;     poofBox.right := poofBox.right + qWidth;// Build a speacial window used just to refresh the screen area outside theoriginal// window, don't worry because it won't show up on the screen     local danQuayle := BuildContext({viewclass:74, viewFlags: 64,viewBounds: poofBox});// Make the poof sounds.     PlaySound(@314);// Iterate thru a loop.     foreach bm in bma do          begin          bm.bounds := poofBox;// Show the cloud.          GetRoot():CopyBits(bm, poofBox.left, poofBox.top, 8);// I'm using a Newton 110, you may need to adjust the sleep time for yourNewton// but it must be at least "1" or you won't see anything.          Sleep(1);// Hide the cloud.          GetRoot():CopyBits(bm, poofBox.left, poofBox.top, 3);          end;// Hide the window so it doesn't reappear.     winToHide:Hide();// Open then close "danQuayle" to refresh the screen around the originalwindow     danQuayle:Open();     danQuayle:Close();endNow for the NS BASIC code:In this case I am poofing out a window called aboutWin, with a window speccalled aboutWinSpec.  Any valid windowSpec can be substituted - this is ageneral purpose code.This line (0028 in my case) should be put in the main body of the program.0028 FUNCTION poofItsGone(winToHide) BEGIN local poofBox :=Clone(winToHide.viewBounds); local bma:= [Clone(@53), Clone(@54),Clone(@55)]; local qWidth := (poofBox.right - poofBox.left) DIV 3; localqHeight := (poofBox.bottom - poofBox.top) DIV 3; poofBox.top := poofBox.top -qHeight; poofBox.left := poofBox.left - qWidth; poofBox.bottom :=poofBox.bottom + qHeight; poofBox.right := poofBox.right + qWidth; localdanQuayle := BuildContext({viewclass:74, viewFlags: 64, viewBounds:poofBox}); PlaySound(@314); foreach bm in bma do begin bm.bounds := poofBox;GetRoot():CopyBits(bm, poofBox.left, poofBox.top, 8); Sleep(1);GetRoot():CopyBits(bm, poofBox.left, poofBox.top, 3); end; winToHide:Hide();danQuayle:Open(); danQuayle:Close(); endThis is the line that the GOTO/GOSUB in the windowSpec points to (0062 in mycase):0062 LET unUsed := U:poofItsGone(aboutWinSpec)This is my windowSpec (just for reference):0325 LET aboutWinSpec := {GOTO: 0062, text: aboutText, viewbounds: {top: 103,bottom: 217, left: 46, right: 194}, viewFont: {family: 'espy, face: 0, size:10}, viewJustify: 2, viewFormat: 6*vfPen+4*vfRound+vfFrameMatte+vfFillWhite}Many thanks to Matthew Riehl for this Tech Note! You can reach him at SharpsShtr@aol.com.NS BASIC Tech Note                                     August 26, 199626. How to make a quick Note                     --------------------------------------------------------------------------Newton OS 2.0 gives you a method for quickly putting some information onthe NotePad.Here's the sample code:10 notes:=getroot().paperroll20 u.notes:makeTextNote("This is my new note",true)The text, "This is my new note", is now on the notepad.Of course, you can still roll your own notes, much as you did in Newton OS 1.x. Note that some of the fields and the layout have changed since 1.x,and that the examples in the manual up to the Dec'95 edition are for 1.xsystems.For full details on the Notes Soup Format, see Chapter 18 of the NewtonProgrammers Guide, available on Apple's web site.NS BASIC Tech Note                                     September 6, 199627. How to connect from Windows 95                     --------------------------------------------------------------------------Contributed by Fields C. Gunsett, gunsetfc@indy.net.1. Start Hyperterminal with the following commands:	Win95, 	Start/Programs/Accessories/Hyperterminal2.	Double click on the Hypertrm icon, enter the name of the of the connection that you want to	establish, say, NEWTON.3.	This will open a new window labeled NEWTON-HyperTerminal.  Another window opens labeled	Phone Number. Click on the down arrow at the connect using box and select Direct to Com?, where ? 	is the com port that you would like to use. Use the same com port that you use to install	new packages or backup the Newton.4.	This opens another window labeled COM? Properties. In this window set the	baud rate (9600), the	Data bits (8), the Parity (N), the Stop Bits (1) and flow control (Xon/Xoff). Select OK.5.	Select File/Properties and then select the Settings Tab, Select TTY as the Emulation type. Press on the ASCII Set Up button: the new window will have two parts (ASCII Sending and ASCII Receiving). In the ASCII Sending box, check Send line ends with line feeds, and check Echo typed characters locally. The delay option is set to zero milliseconds for both line and character. In the ASCII Receiving box, check Append line feeds to incoming line ends, and check Wrap lines that exceed terminal width.6.	Select OK7.	Select File then Save8.	Open the NS Basic Package on the Newton.9.	Close the keyboard.10.	Tap the Use Screen line and select Extr - External Serial11.	The screen on the PC will indicate that a connection has been made andan asterisk will appear.12.	You are now ready to begin data entry from your pc keyboard.NS BASIC Tech Note                                      September 27, 199628. Hardware Tidbits                   --------------------------------------------------------------------------Contributed by Jonathan Kipling Knight (KKnight-COS3@Kaman.com), ColoradoSprings, CO.Here are some technical tidbits on the MessagePad 120 hardware.  Most of thisinformation you can't find very easily and has been uncovered through sometinkering.1) How to wake up your MessagePad through the serial port.The MessagePad has the ability to wake up just by activity on the serial port.This can be accomplished by raising the Data Terminal Ready line ( DTR, pin 7 onthe DIN8 connector ). This usually occurs when attached hardware is ready to dosomething.  For example, when a modem hears the phone ring or when a desktopcomputer is connecting to the MessagePad.2) The chips inside.	Chip, Company, Purpose, Comments	-----------------------------------------------------------------------	P610ARM, ARM, Inc., Processor, Speed of 20 MHz	LO2, Apple, Newton OS ROM, Version 2.0	HI2, Apple, Newton OS ROM, Version 2.0	Z85C30, Zilog, RS422 serial	external clk, up to 32.3 MHz	28F008SA, Intel, Flash memory, 8 MegaBits = 1 MB (ads say 8 MB)	?, ?, Static memory, 4 chips of 512kB each = 2 MB	AD7880AR, Analog Devices, A/D converter, 12 bit analog to digital converter	LIC 7645, Apple, RUNT, Memory management	LT1271CQ, Linear Tech, Switching reg., 3.5V to 30V input, 60kHz	switch    LTC902CS, Linear Tech, ?, can't find what it is.3) Future microphone?The Newton OS 2.0 comes with a built in global function named GetRecordVolume(). I think you can assume this means Apple was thinking ahead to future hardwarerevisions or to other companies that provide Newton PDAs with recordcapabilities.4) Battery charging.There is button in the center in the battery compartment.  If depressed, theMessagePad thinks there is a nicad battery pack in the compartment.  When innicad mode, the MessagePad will trickle charge the batteries with whatever powersource is plugged in.  I found that I didn't need to buy Apple's nicad pack. Place tape over that switch and put Renewal Alkaline batteries or your own nicadbatteries in the compartment.  The MessagePad will then recharge them anytime youplug it into the wall.  When charging, the battery indicator in the Extras drawerwill change from "Battery" to "Charging".  You may be wary about charging RenewalAlkaline batteries in the MessagePad but I've tried it - it works.  The Renewalsdon't even get warm and will charge fully in a few hours.  One advantage is thatRenewals don't have the memory effect like nicads.5) Cheap voltage regulator.Here's how to build a cheap voltage regulator for the required 7 VDC for theMessagePad.  Most of the parts can be found at Radio Shack and almost anyelectronics store.  A cheap car adaptor can be found at many auto parts store. Once you get all the parts you can solder everything together according to theschematic on the back of the Regulator package.	Part		Quantity	Store	LM317T		1	Radio Shack	0.1 microfarad	2	Radio Shack	220 Ohm		1	Radio Shack	1 kOhm		1	Radio ShackWith this put together, you could adapt the MessagePad to any DC power source upto 28 Volts.  This means car batteries, 9V batteries, solar cells, and almost anyDC "wall wart" transformer.  Before you put it all together, a word aboutpolarity.  The plug that goes in the MessagePad has positive on the inside,negative on the outside.  For the standard Apple AC adaptor, the yellow wire ispositive and the white wire is negative.  Also, you'll notice two small contactsopen on the back, bottom right of the MessagePad.  The left is positive and theright is negative.NS BASIC Tech Note                                     October 16, 199629. How to access NewtonPress¨                     --------------------------------------------------------------------------Apple provides a useful application called NewtonPress. It allows you to taketext and graphics on your host PC or Mac, and turn them into a downloadablepackage that you can use on your Newton. The form of the package is a NewtonBook. While data formatted this way can be read easily using the Newton's builtin functionality, it is also a great way to download data that NS BASIC can use.Here is some information on how to do so.A. Extracting data from Newton Press¨ documentsUsing NS BASIC, itÕs easy to access data that has been downloaded to the Newtonthat has been created by Newton Press. (By the way, Newton Press, from Apple, isan indispensable application for lots of other uses). This makes a convenient wayto download databases. HereÕs some sample code that extracts information from apackage named ÔAddress ExportÕ which is on the card:0010 rem get data from NewtonBook0020 LET pkgRef:=getPkgRef("Address Export",getstores()[1])0030 LET pkgInfo:=getPkgRefInfo(pkgRef)0040 LET dataFile:=pkgInfo.parts[0].book.contents[0].dataThe variable dataFile will contain the complete object that was downloaded. Ifthe data was download as text, dataFile will be a normal string variable that isread only.To quickly the data into an NS BASIC data structure, you can use the followingmethod. Format the data on the host system so it is in the form of Newton frames.HereÕs what the sample data would look like:"{Name: "Arthur Dent ", Country: "England ", phone: "44 1 333 4444 "}{more records...}"Now, from NS BASIC, do the following:0050 record=substr(dataFile,a,b) // get a portion of dataFile0060 x=compile(record)0070 addressFrame=u:x()AddressFrame will now contain the data appropriately converted into normal frames.If your data comes in fixed length format and is read only, you can treatdataFile as a single large file, using an expression like record=substr(dataFile,recordNumber*recordLen, recordLen) to quickly access records from the file.B. Downloading Graphics to NS BASIC using Newton Press¨Another use for NS BASIC with Newton Press is as a way to download graphics orpictures. Once downloaded, these pictures can be stored in files (imagine a partsinventory with pictures, or a photo album), or used as icons and buttons. HereÕshow to download a map:First, paste the map into Newton Press and save it as a package called map.pkg.Download the package. YouÕll see it in the Extras Drawer.Next, use the following code to extract the picture and put it into an NS BASICwidget:0010 rem get graphic from NewtonBook0020 LET pkgRef:=getPkgRef("map.pkg",getstores()[1])0030 LET pkgInfo:=getPkgRefInfo(pkgRef)0040 LET map:=pkgInfo.parts[0].book.contents[0].data1020 LET ws.viewBounds:={left: 80, right: 140, top: 10, bottom: 200}1030 window w,ws1050 show w1100 U.ws:copyBits(map,0,0,nil)C. ENTER and NewtonPressThe ENTER command has been enhanced to extract programs and commands frompackages created using NewtonPress. On your PC or Mac, create a file with NSBASIC statements and commands and paste it into NewtonPress. (You can also typedirectly into NewtonPress.) Use NewtonPress to create a package and download it.When you use the ENTER command with the name of the package, each line in thatpackage will be read in turn and interpreted. A progress bar will show as this isgoing on.This feature is a useful way to download one or more programs, with SAVEstatements embedded. It is also a way of constructing a command list of NS BASICcommands. (Available starting with NS BASIC 3.60)NS BASIC Tech Note                                     October 31, 199630. Benchmarks on MP 110 through MP 2000                   --------------------------------------------------------------------------We managed to get our hands on the new eMate 300 and MessagePad units and ransome benchmarks on them. Before interpreting the results, be sure and read theNotes, Disclaimers and Observations section below!Unit        MP110    MP130 eMate300   MP2000NSB Rev      2.52     3.54     3.54     3.54CPU Intensive Tests:Overhead      397      113      104       35GOSUB        4005      983      717      246IF            841      194       72        1LET=          823      189       80        6GOTO         1111      302      173       21             ----     ----     ----     ----CPU          7177     1781     1146      309Screen Output Intensive Tests:WINDOW         78       57       40       11SHOW          270      155      121       57HIDE          219      142      114       53WPRINT        398      300      340      143             ----     ----     ----     ----Screen        965      655      614      265File I/O Intensive Tests:OPEN          171      261       85       18PUT          1165      999      365      290SEQ           329       78       89       31RND           359       94       67       28DEL          1099      686      365      264             ----     ----     ----     ----Soup         3122     2117      971      631             ====     ====     ====     ====Overall     20861     7546     5464     2128Notes, Disclaimers and Observations1. These tests were run on pre-release units of the eMate 300 and MP 2000. Thefinal versions from Apple may have different results.2. The test for the MP110 was run using an older version of NS BASIC. There weresubstantial performance improvements in NS BASIC itself, beyond the changes Applemade in changing from Newton OS 1.3 to 2.0. The performance improvement is acombination of Apple's and NS BASIC's work.3. All times are elapsed: lower times are faster.4. In the CPU test, the eMate was 76% faster than the 130, while the MP 2000 was5.7 times faster. Tightly localized code (IF, LET, GOTO) ran much faster (15times), indicating just how fast the StrongArm is. Tests which involved morewidely spread out code were slower, as it takes time to reference code not on thecurrent page and load it into memory.5. The Screen test showed some improvement on the eMate, and more than doubledon the MP 2000. Remember that some of the increased CPU speed is eaten up bygoing from a 240 by 320 single bit display to a screen twice the size with 4 bitgray scale. Updating information on the screen (WPRINT test) was actually a bitslower on the eMate 300 than on the MP 130. Opening, showing and hiding windowswas still faster: there's a lot more CPU work in setting up a window thanupdating it.6. The File I/O test was a welcome improvement. Writing to flash memory is slow,and we really didn't expect much here. What did they do to it so that the PUT andDEL operations were sped up so much?7. The Overall result reflects a somewhat arbitrary blend of the 3 groups oftests. Some applications you run may be more CPU intensive, without accessingmuch data, and will give different overall results.George HennePlease send comments/questions on these results to support@nsbasic.com.NS BASIC with Visual Designer is a complete, easy to use programming environmentfor Newton devices. For more information on NS BASIC, visit www.nsbasic.comCopyright (c) 1996 NS BASIC CorporationNS BASIC Tech Note                                      December 18, 199631. Widgets By Hand, a detailed example                     --------------------------------------------------------------------------This technote describes using widgets without the Visual Designer or the WIDGETDEF Statement. See Chapter 4 in the Handbook for an example of using the Visual Designer to build Newton interfaces.A widget is a Newton user interface element. In the NewtonScript language, widgets are called protos and view templates. You can create programs that use many of the visual elements found in Newton applications. Refer to the Reference section under WINDOW for a complete list of widgets.When you want to create an application that uses widgets, you combine windows and widgets to create a single screen that the user interacts with. This screen may consists of many widgets. Once the widgets are displayed, the user can interact with the screen using pen taps, hand-written input, and the keyboard. Your screen must be designed so that the user can indicate when they are finished entering information. A window that looks like a Newton button can be used. You can create a main window for your application using the APP widget. This widget includes a standard close box. You can add one or more additional windows that look like Newton buttons, such  as an "OK" button. These windows will use a GOTO field in their windowSpec to allow your program to process the user entry in the form.The following sample program creates a simple database with a form for user entry. It supports searching for records and adding new records. It uses several widgets for the form.The three sections of the program you should examine are the creation of the widgets (lines 130-330), the extraction of the user entered values from the widgets (lines 500-510), and the displaying of new values in widgets (lines 430-470).Note: Never use the same windowSpec variable in multiple WINDOW Statements without first assigning a new frame value to the variable. This is done in the example below with the spec variable. Each time this variable is used in a WINDOW Statement, it is initialized with a new frame containing the desired fields for the window.10 REM WIDGET Example20 OPEN example, "ExampleFile", Name30 IF FSTAT <> 0 THEN CREATE Âexample, "ExampleFile", Name70 spec := {GOTO: 'appDone, Âtitle: "Sample App"}80 WINDOW MainWindow, spec, "APP"110 SHOW MainWindow130 REM create and display blank form150 btn1spec := {GOTO: 360, text: "Search", viewBounds: SETBOUNDS(6, 280, 66, 294), widgetType:"TEXTBUTTON"}160 WINDOW SearchBtn, spec, "TEXTBUTTON"170 spec := {GOTO: 490, text: "Save", viewBounds: SETBOUNDS(70, 280, 130, 294), widgetType:"TEXTBUTTON"}180 WINDOW SaveBtn, spec, "TEXTBUTTON"190 spec := {GOTO: 540, text: "New", viewBounds: SETBOUNDS(134, 280, 191, 294), widgetType:"TEXTBUTTON"}200 WINDOW AllBtns, spec, "TEXTBUTTON"210 NameSpec := {label: "Name:", viewBounds: SETBOUNDS(9, 30, 230, 64), viewFlags: VCLICKABLE}220 WINDOW Name, NameSpec, "LABELINPUT"230 RankLabelSpec := {text:"RANK\n1 2 3 4 5 6 7 8 9", viewJustify:3, viewFormat: vfPen+vfFrameWhite, viewBounds: SETBOUNDS(21, 65, 230, 109), viewFlags: VCLICKABLE}240 WINDOW RankLabel, RankLabelSpec, "PARAGRAPH"250 RankSpec := {viewValue:0, viewBounds: SETBOUNDS(21, 110, 230, 119), viewFlags: VCLICKABLE}260 WINDOW Rank, RankSpec, "SLIDER"270 ContactSpec := {label: "Contact:", labelCommands: ["Now", "Soon", "Someday", "Never"], viewBounds: SETBOUNDS(9, 120, 230, 144), viewFlags: VCLICKABLE}280 WINDOW Contact, ContactSpec, "LABELINPUT"290 CalledSpec := {text: "Called", viewBounds: SETBOUNDS(21, 145, 110, 179), viewFlags: VCLICKABLE}300 WINDOW Called, CalledSpec, "CHECKBOX"310 NotesSpec := {boxTitle:"Notes", text: "", viewBounds: SETBOUNDS(21, 180, 230, 254), viewFlags: VCLICKABLE}320 WINDOW Notes, NotesSpec, "SCROLLER"330 SHOW SearchBtn, SaveBtn, NewBtn, Name, RankLabel, Rank, Contact, Called, Notes340 waitLoop: Wait 1000350 GOTO waitLoop360 REM user taps Search370 searchKey = NameSpec.entryLine.text380 GET example, editRec, searchKey390 IF FSTAT <> 1 THEN GOTO 0420400 BEEP 7410 GOTO 340420 REM found something!430 SETVALUE(NameSpec.entryLine, 'text, "" & editRec.name)440 SETVALUE(RankSpec, 'viewValue, editRec.rank)450 SETVALUE(ContactSpec.entryLine, 'text, "" & editRec.contact)460 IF CalledSpec.viewValue <> editRec.called THEN U.CalledSpec:TOGGLECHECK()470 SETVALUE(NotesSpec.notes, 'text, "" & editRec.notes)480 GOTO 340490 REM user taps Save500 newRecord = {name:NameSpec.entryLine.text,Ârank:RankSpec.viewValue, contact:ÂContactSpec.entryLine.text, Âcalled: CalledSpec.viewValue, Ânotes: NotesSpec.notes.text}510 PUT example, newRecord520 IF FSTAT <> 0 THEN BEEP 7 ELSE BEEP 4530 GOTO 0340540 REM user taps New550 SETVALUE(NameSpec.entryLine, 'text, "")560 SETVALUE(RankSpec, 'viewValue, 0)570 SETVALUE(ContactSpec.entryLine, 'text, "")580 IF CalledSpec.viewValue THEN x = U.CalledSpec:TOGGLECHECK()590 SETVALUE(NotesSpec.notes, 'text, "")600 GOTO 340610 appDone: REM user taps close box620 HIDE630 ENDNS BASIC Tech Note                                December 18, 199632. Serial Input/Output-------------------------------------------------------------------You can send and receive data via the serial port of your Newton. NS BASIC can PRINT to the serial port and INPUT from it. There are four steps to using the serial port:1 Initialize the port to the desired settings.You control the settings for the serial port using the environment variable s0. 2 Tell NS BASIC to use the serial port.You control the input and output device using the environment variable IO.3 Exchange data or output information as desired using the serial port.You control the prompt displayed by NS BASIC using the environment variable inputPrompt. You send data using PRINT and receive data using INPUT.4 Tell NS BASIC to stop using the serial port.You control the input and output device using the environment variable IO.It is very important that you perform these steps in this order. If your program quits unexpectedly and leaves the serial port open, other Newton applications may not be able to use the port. If this happens, reset your Newton.The first example program accepts input via the serial port. This program leaves the serial port in its default configuration.You will need to connect your Newton to a desktop computer to run this program. See the Using NS BASIC With a Computer or Terminal section of this Handbook for more information.10 REM Serial Port Example20 f={viewBounds:SETBOUNDS(100,100,130,110)}30 tr = 040 translist = ""50 CLS60 WINDOW w1,f70 SHOW w180 ENVIRON io="extr"90 REM get a transaction100 INPUT trans110 tr = tr+1120 translist = translist & trans & CHR(13)130 WPRINT w1, tr140 IF trans <> "BYE" THEN GOTO 90150 ENVIRON io="scre"160 PRINT translist170 HIDE w1The next example program dumps all of your appointments from the Calendar file to the serial port. The port is set to 4800 bps first. See the Handbook for more information on accessing Calendar and other built-in applications data.10 REM Serial Dump Calendar Example20 REM set serial params30 currPort := env("extr")40 currPort.data = [4800,8,1,"no"]50 ENVIRON extr=currPort60 ON ERROR GOTO 12070 ENVIRON IO="extr" // switch to serial80 OPEN ch,"calendar",mtgstartdate90 GET ch, n100 PRINT n // dump record110 GOTO 90120 REM EOF or other problem130 ENVIRON IO="scre"140 ENDNS BASIC Tech Note                                December 18, 199633. Accessing and Using Other Files, Data, and Applications-------------------------------------------------------------------The GETROOT() Function returns the root frame of your Newton. Every application currently installed on your Newton is accessible via this frame. Because of their large size, you should always use the special := assignment operator to point to this frame.The first example program will display all of the items stored in the root frame. The output of this list is quite large, and will not be reproduced in this technote. This program is completely safe. You can enter and run it on your Newton with no risk of data loss.10 REM getroot() Example20 rootFrame := getroot()30 rootElements := elements(rootFrame)40 numElements = length(rootElements)-150 FOR i = 0 TO numElements60 PRINT rootElements[i]70 NEXT iThe next example will open the Names application, and is also completely safe:10 getroot().cardFile:open()The :open() in the above program tells the Names application to open as if you had tapped Names. The built-in applications respond to :open() and :close(). The names of the built-in applications are paperRoll (Note Pad), calendar (Dates), cardFile (Names), extrasDrawer (Extras), and assistant (Assist).The last example program will display all of the fields in your user configuration frame. The output of this list is quite large, and will not be reproduced in this technote. This program is completely safe. You can enter and run it on your Newton with no risk of data loss.10 REM GETROOT().userConfiguration Example20 rootFrame := GETGLOBALS().userConfiguration30 rootElements := ELEMENTS(rootFrame)40 numElements = LENGTH(rootElements)-150 FOR i = 0 TO numElements60 PRINT rootElements[i]70 NEXT iThere are several built-in functions that are not documented in this handbook that my be used in NS BASIC.Warning: Many of the built-in functions are not documented. Others may freeze your Newton. Do not try to use any function you do not understand. Be aware that the use of these functions may cause data loss. Not all Newton devices may have the same built-in functions.NS BASIC Tech Note                                September 12, 199634. BASIC Internet Enabler (BIT)-------------------------------------------------------------------NS BASIC makes a very handy tool for accessing the internet. With it, you can create custom mail, news and web applications. By loading the BASIC iNet Tool (BIT) onto your system, you add a set of easy to use functions to NS BASIC that let you cruise the net from your Newt.Table of Contents-----------------1. Prerequisites    22. General Comments    23. How to use the BASIC Internet Tool (BIT)    34. News    45. WWW    56. Getting Mail    67. Sending Mail    78. Testing Stuff out using Telnet    8Appendix A: List of standard internet port numbers    9Appendix B: Program Listing   10Quotes from Beta Testers:"I think BIT is a very good way to get access to all the possibilities and informations of the internet. The handling is very easy. Everybody with a little knowledge of Internet-protocols could do his own Newsreader, Emailreader, etc...  Great...;))))""BIT looks like a very fun tool. A superb addition to a more and more professional product."1. Prerequisites----------------1. Newton MessagePad 130. (A Newton 120 2.0 probably has insufficient memory for this).2. The Newton Internet Enabler (NIE) must be installed. (Available from http://devworld.apple.com/dev/newton/tools/nie.html3. A modem4. An account with an Internet Service Provider (ISP)5. Internet Setup must have been performed6. NS BASIC 3.0 or newer, installed on the Internal store.7. Basic iNet Tool (BIT) must also be installed on the Internal store.2. General Comments----------------The NS BASIC internet interface is designed to be very easy to use. In this document, we give some of the basics on accessing different internet services.A good resource on how the internet works in general is located at http://www.freesoft.org/Connected. You might want to look at this to get information on more advanced uses of the internet services.The BASIC iNet Tool is an add on piece of software which NS BASIC uses to access the Newton Internet Enabler. Small (less that 15K), it greatly simplifies the code needed in the NS BASIC program.3. How to use the BASIC Internet Tool (BIT)-------------------------------------------To initialize BIT, put the following statement into your program:BIT:=getroot().|bit:nsbasic|You can now access the additional variables provided by BIT by referring to the in your program as BIT.<slotname>. To call a function, use the expression U.BIT:<funcname>(<parameters>).BIT runs as a background task. You can ask it to do something, and leave it to run while you do other processing. Note that if you do so, you will take cycles away from BIT and it will take longer for it to work. Running BIT as a background task allows you to do a bit of housekeeping in NS BASIC and to set up a WAIT loop that can time out if BIT takes too long to reply.Here are important variables and functions in BIT:mConnect() This function establishes the connection. Before it can be called, the variables BIT.fConfigAddr and BIT.fConfigRPort must be set. If the phone connection has not been made, this function will also establish it, using the defaults in Internet Setup.Send(text)This function sends the text and clears u.fReceiveBuffer.CancelRequest(nil)This function allows you to cancel an outstanding request.Receive(text)This function returns a copy of current contents of BIT.fReceiveBuffer and clears it.Cleanup()This function releases the connection and frees up the memory used by the connection.Rev()This function returns the current rev of BIT.The following variables are used by BIT:fEndPointState    var   0 if idle, 1 if connected.fReceiveBuffer    var   string data received from net. Max size is 8000.fConfigAddr       var   string net address to accessfConfigRPort      var   integer port number to access. See Appendix A.fstatus           var   the current status4. News----------------To connect with news, use address "nntp.netcruiser" and port 119. (The address will be different with your service provider; the port will be standard. See Appendix A for a complete list of ports). For complete documentation on how to talk to a news server, see http://freesoft.mesa.net/Connected/RFC/977/You'll get an initial welcome message back:"200 tor-nn1.netcom.ca InterNetNews NNRP server INN 1.4unoff4 05-Mar-96 ready (posting ok)."Tell it what newsgroup you want:group alt.food.wineYou'll get back :211 206 16868 17075 alt.food.wineThis means there are 206 articles, numbered from 16868 to 17075.To read the headers of some of the articles, sendxover 17000-17005You'll get back:"17070	Re: Old Liebfraumich...	"Roger L. Lustig" <julierog@ix.netcom.com>	Wed, 31 Jul 1996 22:51:21 -0400	<32001BA9.367@ix.netcom.com>	<4tnroe$m9m@mcmail.CIS.McMaster.CA>	1092	14""17071	Re: Wine de Constantia, info needed	"Roger L. Lustig" <julierog@ix.netcom.com>	Wed, 31 Jul 1996 22:54:37 -0400	<32001C6D.76ED@ix.netcom.com>	<Pine.LNX.3.91.960731213109.22969C-100000-100000@felix.bbb.no>	1590	31""17072	Napa Crush Begins	"Brian Boulden" <boulden@community.net>	1 Aug 1996 04:50:45 GMT	<01bb7f64$195b6da0$a677ae8c@boulden.community.net>		1523	22""17073	Re: Alsace	zincats@aol.com (ZinCats)	1 Aug 1996 01:00:41 -0400	<4tpdlp$m8i@newsbf02.news.aol.com>	<31FD65C5.4774@widomaker.com>	992	8""17074	Re: Oregon Bound - Need Help	zincats@aol.com (ZinCats)	1 Aug 1996 01:14:38 -0400	<4tpefu$mog@newsbf02.news.aol.com>	<31FAFB21.2052@execpc.com>	793	5""17075	RE: Old Liebfraumich...	chris.anderson@dinosaur.com	Wed, 31 Jul 96 23:06:55 -0700	<9607312306.0WH1U00@dinosaur.com>	<4tnroe$m9m@mcmail.CIS.McMaster.CA>	1317	18"To read a single article, sendarticle 17000Ariticles may be any number of lines long, terminated by a final line that consists of <CR><LF>.<CR><LF>, or "\u000D000A\u.\u000D000A\u" in NS BASIC.See the sample code in Appendix B for an example of accessing a news group.5. WWW----------------To connect with a web server, use address "www.nsbasic.com" and port 80. (The address will be different depending on the web server you wish to access; the port will be standard. See Appendix A for a complete list of ports).To get a web page,GET http://www.nsbasic.com/The data will come back and the connection will be closed. Note that while News lines end with CR/LF, web information that returns may end in just LF. At the end of receiving a page of data, the server closes the connection, so to see if the page is complete, wait for the connection to be terminated.Web sites also have local programs that get run, using something called cgi. For example, to check a stock price, connect to location www.dbc.com and do the following command:GET /cgi-bin/htx.exe/squote?TICKER=DOCSFOne NS BASIC quirk to look out for: the "//" that often appears as part of a URL confuses the NS BASIC scanner, which also takes // to mean the beginning of a comment on a statement line. To get around this, you may need to enter the URL as "GET http:/" & "/www.nsbasic.com/.See the sample code in Appendix B for an example of accessing a web page.6. Getting Mail----------------The program most commonly used to read news on a server is called POP3. Documentation for this can be found at http://www.imc.org/rfc1939.To connect with a POP3 server, use address "netcom.ca" and port 110. (The address will be different depending on the web server you wish to access; the port will be standard. See Appendix A for a complete list of ports).Here's a sample of the underlying dialogue that takes place. In your NS BASIC program, you'll duplicate this dialog. Lines entered by the user start with U:U: telnet netcom.ca 110Trying 207.93.1.148...Connected to netcom.ca.Escape character is '^]'.+OK NETCOM v0.1 at tor-srs1 starting : built on Aug  2 1996 14:00:08.U: user ghenne+OK Password required for ghenne.U: PASS xxxxxx+OK ghenne has 0 message(s) (0 octets).U: STAT+OK 3 1766U: DELE 3+OK Message 3 has been deleted.U: LIST+OK 2 messages (1425 octets)1 8012 624.U: DELE 2+OK Message 2 has been deleted.U: RETR 1+OK 801 octetsReturn-Path: <gh@nsbasic.com>Received: from deliverator.io.com by tor-srs1.netcom.ca (8.7.5/SMI-4.1/Netcom)        id PAA17679; Tue, 27 Aug 1996 15:28:22 -0400 (EDT)From: gh@nsbasic.comReceived: from tor-srs1.netcom.ca (tor-srs1.netcom.ca [207.93.1.148]) by deliverator.io.com (8.7.5/8.7.3) with ESMTP id OAA16463 for <gh@nsbasic.com>; Tue, 27 Aug 1996 14:24:42 -0500 (CDT)Received: from pentagon.io.com by tor-srs1.netcom.ca (8.7.5/SMI-4.1/Netcom)        id PAA16699; Tue, 27 Aug 1996 15:23:18 -0400 (EDT)Date: Tue, 27 Aug 1996 15:23:18 -0400 (EDT)Message-Id: <199608271923.PAA16699@tor-srs1.netcom.ca>This is line 1 of my messageand line 2..U: QUIT+OK Pop server at  signing off.Connection closed by foreign host.See the sample code in Appendix B for an example of reading mail.7. Sending Mail----------------The most common program used to send mail is SMTP. Documentation for SMTP can be found at http://www.freesoft.org/Connected/RFC/821/1.htmlTo connect with a SMTP server, use address "netcom.ca" and port 25. (The address will be different depending on the web server you wish to access; the port will be standard. See Appendix A for a complete list of ports).Here's a sample of the underlying dialogue that takes place. In your NS BASIC program, you'll duplicate this dialog. Lines entered by the user start with U:U: telnet netcom.ca 25Trying 207.93.1.148...Connected to netcom.ca.Escape character is '^]'.220 tor-srs1.netcom.ca ESMTP Sendmail 8.7.5/SMI-4.1/Netcom ready at Tue, 27 Aug 1996 15:23:06 -0400 (EDT)U: HELO io.com250 tor-srs1.netcom.ca Hello nsbasic@pentagon.io.com [199.170.88.5], pleased to meet youU: MAIL FROM: gh@nsbasic.com250 gh@nsbasic.com... Sender okU: RCPT TO: gh@nsbasic.com250 Recipient okU: DATA354 Enter mail, end with "." on a line by itselfU: SUBJECT: This is some test dataU: This is line 1 of my messageU: and line 2.U: .250 PAA16699 Message accepted for deliveryU: QUIT221 tor-srs1.netcom.ca closing connectionConnection closed by foreign host.See the sample code in Appendix B for an example of sending mail.8. Testing Stuff out using Telnet---------------------------------Telnet is another of the basic services provided on the net. It allows you to establish a low level connection with any port on a service provider. There are a number of Telnet implementations available for for PCs and Macs.You can test most of this stuff out using Telnet and your PC or Mac. Connect to your service provider, and start up telnet. (Unfortunately, not all ISP's allow you to access Telnet: Netcom is a good example. Let them know how you feel!) Once in telnet, you can typetelnet netcom.ca 25The first argument is the address of the service provider and the second is the port number you want to connect to.Try testing the commands you want to issue manually before writing an NS BASIC program to perform them.Unfortunately, it's not so easy to create a Telnet application from NS BASIC. Telnet relies on special escape characters for its processing, which can appear at any point in the transmission. This requires character by character processing of the incoming data, which would need to be done a very low level routine - the standard code provided by Apple as part of the Newton Internet Enabler isn't set up for this.Appendix A: List of standard internet port numbers--------------------------------------------------tcpmux          1/tcp                           # TCP port multiplexer (RFC1078)echo            7/tcpecho            7/udpdiscard         9/tcp           sink nulldiscard         9/udp           sink nullsystat          11/tcp          usersdaytime         13/tcpdaytime         13/udpnetstat         15/tcpqotd            17/tcp          quotechargen         19/tcp          ttytst sourcechargen         19/udp          ttytst sourceftp             21/tcptelnet          23/tcpsmtp            25/tcp          mailtime            37/tcp          timservertime            37/udp          timserverrlp             39/udp          resource        # resource locationnameserver      42/tcp          name            # IEN 116whois           43/tcp          nicnamedomain          53/tcp          nameserver      # name-domain serverdomain          53/udp          nameservermtp             57/tcp                          # deprecatedbootps          67/udp          bootp           # bootp serverbootpc          68/udp                          # bootp clienttftp            69/udpgopher          70/tcprje             77/tcp          netrjsfinger          79/tcplink            87/tcp          ttylinksupdup          95/tcphostnames       101/tcp         hostname        # usually from sri-nictsap            102/tcp                         # part of ISODE.pop2            109/tcp                         # old pop portpop             110/tcp         pop3 postofficesunrpc          111/tcpsunrpc          111/udpident           113/tcp         auth tap authenticationsftp            115/tcpuucp-path       117/tcpnntp            119/tcp         readnews untp   # USENET News Transfer Protocolntp             123/udp         ntpdimap            143/tcpsnmp            161/udp                         # network time protocolsnmp-trap       162/udpsmux            199/tcpAppendix B: Program Listing---------------------------0010  rem demonstrate internet access -- IN0015  cls0020  print "Demonstrate Internet Access"0030  print0040  print "A. Get a news article"0050  print "B. Get something from a web site"0060  print "C. Get some mail"0061  print "D. Send some mail"0065  print "X. Exit"0070  print0080  print "Input Selection-"0090  input Sel$0100  if sel$="A" then gosub news0110  if sel$="B" then gosub web0120  if sel$="C" then gosub getMail0121  if sel$="D" then gosub sendMail0125  if sel$="X" then goto fin0130  GOTO 00201000 news: rem get news1010  LET bit:=getroot().|bit:nsbasic|1020  LET bit.fconfigRAddr="nntp.netcruiser"1030  LET bit.fconfigRPort=1191050  gosub WaitForConnect //1055  gosub waitForInputComplete //1070  u.bit:send("group alt.food.wine")1110  gosub waitForOneLine //1120  LET x=u.bit:receive()1130  u.bit:send("article" && substr(x,8,5))1140  gosub waitForPeriod //1150  PRINT u.bit:receive()1195  return1200 web: REM1210  LET bit:=getroot().|bit:nsbasic|1220  LET bit.fConfigRAddr="www.nsbasic.com"1230  LET bit.fconfigRPort=801240  gosub WaitForConnect //1250  gosub waitForInputComplete //1280  u.bit:send("GET http:/" & "/www.nsbasic.com/")1290  gosub waitForDisconnect //1300  print bit.fReceiveBuffer1395  return1400 getmail: REM1410  LET bit:=getroot().|bit:nsbasic|1420  LET bit.fConfigRAddr="netcom.ca"1430  LET bit.fconfigRPort=1101440  gosub waitForConnect //1450  gosub waitForInputComplete //1475  u.bit:send("USER ghenne")1480  gosub waitForOneLine //1495  u.bit:send("PASS xxxxxx")1500  gosub waitForOneLine //1510  PRINT u.bit:receive()1535  u.bit:send("RETR 1")1540  gosub waitForInputComplete //1550  PRINT u.bit:receive()1570  u.bit:send("QUIT")1580  gosub waitForDisconnect //1590  return1600 sendMail: REM1610  LET bit:=getroot().|bit:nsbasic|1620  LET bit.fConfigRAddr="netcom.ca"1625  LET bit.fconfigRPort=251630  gosub waitForConnect //1640  gosub waitForInputComplete //1675  u.bit:send("HELO io.com")1680  gosub waitForOneLine //1695  u.bit:send("MAIL FROM: gh@nsbasic.com")1700  gosub waitForOneLine //1715  u.bit:send("RCPT TO: ghenne@netcom.ca")1720  gosub waitForOneLine //1730  u.bit:send("DATA")1735  gosub waitForOneLine //1736  u.bit:send("SUBJECT: Test Message")1740  u.bit:send("This is line 1")1745  u.bit:send("This is another line")1750  u.bit:send(".")1755  gosub waitForOneLine //1760  u.bit:send("QUIT")1790  return2000 waitForConnect: REM2006  if bit.fendPointState=1 then return2007  temp:=u.bit:mConnect()2010  do while bit.fEndpointState<>12020    wait 10002030  loop2040  return2100 waitForInputComplete: REM2120  do2125    LET l=strLen(bit.fReceiveBuffer)2130    wait 30002140  loop until l=strLen(bit.fReceiveBuffer)2150  return2200 waitForPeriod: REM2210  LET termStr="\u000D000A\u.\u000D000A\u"2220  do while not endsWith(bit.fReceiveBuffer,termStr)2230    wait 10002240  loop2250  return2300 waitForOneLine: REM2320  do while strLen(bit.fReceiveBuffer)=02330    wait 10002340  loop2350  return2400 waitForDisconnect: REM2410  if bit.fEndpointState<>1 then return2420  do while bit.fEndpointState=12430    wait 10002440  loop2450  return9000 fin: REM9010  if u.bit then u.bit:cleanup()9020  end