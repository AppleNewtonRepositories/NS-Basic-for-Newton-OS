John - we held a programming contest, and I think you agreed to be a judge. There are just 3 entries, detailed below. I've got a brief description for each one, plus back up docs for a couple of them. The source code should not be distributed. Can you give me you ranking?GeorgeNS BASIC Announces Programming ContestNovember 20,1996We’re holding another programming contest, this time with Cash Prizes!There’s a lot of cool things being done with NS BASIC these days. People are hooking into the internet, collecting information, controlling machinery, hacking into the Newton, and organizing and analyzing data. We’d like to hear more about it, and we’d love to recognize those who are doing great stuff.To Enter: Send us a brief (200 word or so) description of what your program does, along with a working copy of it. You may send it as a source code listing or as a MAKEPACKAGE file. If you want us to keep the code confidential, please ask and we’ll do so.Please send the description in English - but if you would like to submit it in another language as well, please do so. We reserve the right to publish and otherwise use the descriptions.Deadline: 12:00 EST, December 23, 1996. Winners will be announced by December 31, in time for the New Year!Judging: We will judge based on our own arbitrary criteria, including creativity, usefulness, quality and all around coolness. Applications can be for business, education or whatever else you have done. Decisions of the judges are final.All projects are eligible - even ones that you completed before the contest started.Prizes: First prize is $100.00 US funds. Second and third prizes are genuine, limited edition NS BASIC T shirts.Submissions: Please send your entries to contest@nsbasic.com. If you have any questions, please send them to contest@nsbasic.com.1. Biology Field Research: Water Temperature in Cup PlantsThis project was done by Courtney Teska as part of the Howard HughesPre-Collegiate Summer Program. Ms. Teska interfaced an inexpensive Metex DigitalMultimeter with a Radio Shack temperature probe to NS BASIC. The equipment wasused to measure the temperature of the liquid inside Cup plants (Silphiumperofliatum), to determine how this effects what organisms are able to livewithin the plants. With further aid from her sponsors, Ms. Teska has taken theequipment into the field in Indonesia to perform the research. For fullinformation on this project, see the report and source code later in this document.2. Animal Tracking Project: South AfricaThe Animal Tracking Project was done by Jacqlyn Edge, Andrea Foster, LindsaySteventon, all students in the Computer Science Department at the University ofCapetown in South Africa. They interfaced NS BASIC to a GPS (Global PositioningSystem) to enable highly skilled (but illiterate) animal trackers to record theirobservations in the field. The trackers take the units out into the wild to countanimals: the program has graphic buttons for them to tap when they spot an animaland the GPS records their current position. For full information on this project,visit http://www.cs.uct.ac.za/~jedge/html/project/TrackFrames.html.3. ARM DisassemblerThis program was done by Jonathan(Kip) Knight, of Colorado Springs. It takes anycode within a Newton and reverse compiles it back to ARM assembly language. Itmake extensive use of the FUNCTION statement to perform some very clevermanipulation of the information. The resulting code is displayed in hex andascii: where possible, the instruction is displayed.Sample OutputType in native function location (return for example).?GetRoot().|Basic:NSBasic|.stepAllocateContext[1].commsCheckAddress |   Hex   |  Ascii : ARM Instruction10732 | E92D4FF0 |  -O  : STMFD R13!,{R4-R11,R14}10736 | E1A08001 |      : MOV R8,R110740 | E24DD040 |  M @ : SUB R13,R13,#6410744 | E3A00002 |      : MOV R0,#210748 | EBFFF5BD |      : BL 24810752 | E58D003C |    < : STR R0,[R13,#60]10756 | E3A00002 |      : MOV R0,#210760 | EBFFF5BA |      : BL 24810764 | E58D0038 |    8 : STR R0,[R13,#56]10768 | E3A00002 |      : MOV R0,#210772 | EBFFF5B7 |      : BL 24810776 | E58D0034 |    4 : STR R0,[R13,#52]10780 | E3A00002 |      : MOV R0,#210784 | EBFFF5B4 |      : BL 24810788 | E58D0030 |    0 : STR R0,[R13,#48]10792 | E3A00002 |      : MOV R0,#210796 | EBFFF5B1 |      : BL 24810800 | E58D002C |    , : STR R0,[R13,#44]10804 | E3A00002 |      : MOV R0,#210808 | EBFFF5AE |      : BL 24810812 | E58D0028 |    ( : STR R0,[R13,#40]Probe Report and CodeAPPLICATIONS OF THE APPLE NEWTON INTERFACED TO A DIGITAL VOLTMETER IN BIOLOGY FIELD RESEARCH: TEMPERATURE DATA ACQUISITION AND STORAGE USING A NSBASIC PROGRAMCourtenay TeskaHoward Hughes Pre-Collegiate  Summer Program ScholarBeloit College, Beloit, Wisconsin 53511Summer, 1996 	 Because of their compactness, Newtons are very useful for working on the move.  Many advancements have been made to adapt the Newton for use in medical, business, and educational environments, but very little has been done to use the Newton for scientific data gathering purposes.  My objective was to develop ways to make the Apple Newton a useful tool for scientific data collection in the field, especially in biology.  	The Newton's high level programming language, NS BASIC (see reference 1 for more information), is one of the simplest programming languages, and has been updated to include the ability to create windows, buttons, graphics, and accept pen input.  These features make it possible to write programs that are even more "field friendly" than other standard data collection programs.	I began testing the Newton in the field by developing a way to collect temperature data on the water found in the cups of the Cup plant, Silphium perofliatum. The leaves of the plant are very large and form small cups around the thick stem of the plant. Cup plants can reach up to nine feet in height, and have many cups, one above the other. The water in these cups contain many insect larvae and other organisms that make their home there.  Because these plants are so tall, the temperature of the water in each of the cups varies from cup to cup.  This temperature variation is due to differences in exposure to sun light, wind, rain, and other factors. It is hypothesized that the temperature of the water can greatly affect what is able to live in each of the cups. Therefore, the ability to collect accurate data on temperature differences, and then research what organisms are capable of living at what temperatures can tell us a great deal about the role of the Cup plant in the environment.	The equipment I used was an Apple Newton (100/120), a Metex Digital Multimeter M4650CR, and a thermistor temperature probe (see below). The Newton and the Metex were connected via modem cable from the Newton's standard 8 pin serial port to a specially modified cable connected to the serial port of the Metex (details can be found in reference 2).  Attached to the Metex was a thermistor probe. This probe was originally part of  an electronic thermometer (Radio Shack Cat. No. 63-854). The probe, however, was removed from the thermometer and instead attached to the Metex so that the measured resistance could be digitized and then transferred and stored on the Newton.  	In order for the Newton to collect the temperature data and store it, a NS BASIC program  was created on the Newton, which in effect sends a signal to the Metex telling it to send its digitized information back to the Newton. The program then converts the resistance (reading sent by the Metex) to temperature in degrees Celsius, based on an empirical, experimentally determined calibration equation.  The information sent is then collected by the Newton at certain time intervals selected by the user at the beginning of the program until the stop option is chosen. The Newton then offers a dialog box with three choices:  Transfer Data to Computer, View Data , or End (all data will be erased).REFERENCES1.  Henne, George W.P., John C. Schettino, Elizabeth O. Schettino, “NS BASIC 	Handbook,” NS BASIC Corporation, Toronto, 1995.2.  Viswanathan, R., Lisensky, G., Dobson, D.A.  “Off-The-Shelf Portable Data 	Acquisition: Interfacing a Serial-Port-Equipped Multimeter.”  Journal of 	Chemical Education, vol. 73, no. 2, p. A41(2), Feb., 1996. Full text can be found 	at http://jchemed.chem.wisc.edu/journal/issues/1996/feb/art987.html.BibliographyRohan, Rebecca,  "Notebooks, PDA's Get A Little Extra Serial; new PCMCIA 	Card Puts The Port In Portable."  Computer Shopper, vol.14, no.9, p.70(1), 	Sept., 1994.Schettino, John, Liz O’Hara,  “Basic For The Newton," AP Professional, Boston, 1995.http://www.nsbasic.com/hotzone.html – General information on NS BASIC.Improved version of temperature data acquisition, CUP.BAS0001 rem Copyright  © 1996 by Rama Viswanathan , Beloit College0002 rem This is a NSBASIC program that acquires data from Metex Multimeter 0003 rem  Customized  for biology field applications by0004 rem  Courtenay Teska version 1.2 7/1/960005 dim A[10], D[10,10,10], H[10,10], c[10]0010 environ inputprompt=""0011 cls0012 LET annotate={boxTitle:"ANNOTATIONS",text:"Please annotate your data acquisition below and tap the OK box when done. Double-tapping anywhere will bring up typewriter!"}0014 window w4,annotate,"scroller"0016 let OKA.viewbounds={left:120,right:200,top:265,bottom:275}0018 let OKA.viewvalue=false0020 let OKA.text="OK"0022 LET OKA.goto=400024 window w5,OKA,"checkbox"0026 LET CAncelA.goto=380027 let cancelA.viewbounds={left:120,right:200,top:280,bottom:290}0028 let CancelA.viewvalue=false0030 let CancelA.text="Quit Program"0032 window w6,CancelA,"checkbox"0033 show w40034 show w50035 show w60036 wait 10000037 GOTO 00360038 hide0039 end0040 LET a[pl]=annotate.notes.text0041 hide w40042 hide w50043 hide w60044 cls0045 print "How many cups are on plant # ";pl0046 input cn0047 for cup=1 to cn0048 print "Enter height for cup # ";cup0049 input H[pl,cup]0050 next cup0051 let c[pl]=cn0060 let ok.viewbounds={left:75,right:158,top:140,bottom:150}0061 hide w70070 let cancel.viewbounds={left:100,right:180,top:180,bottom:190}0080 let ok.vclickable=true0090 let cancel.viewvalue=false0100 LET OK.GOTO=02800110 let cancel.text="stop"0120 let ok.viewjustify=20130 LET cancel.VIEWFONT={FAMILY:'ESPY,FACE:1,SIZE:18}0140 let tr=00150 window w2,ok0160 window w3,cancel,"checkbox"0170 rem0180 cls0190 window w1,f0200 show w20210 show w30215 let c=00218 let y=200219 for cup=1 to cn0220 let me$= "temps of cup " & cup & " of plant " & pl0225 wprint w2, me$0226 let c=00230 show w10240 LET cp=env("s0")0250 LET cp.data=[1200,7,2,"no"]0260 LET cp.connect=nil0270 wait 10000273 if Cancel.viewvalue=true Then Goto 04800275 GOTO 02700280 CLS0290 HIDE W20300 environ s0=cp0310 environ io="s0"0320 let oldtime=ticks()0340 print "D";0350 rem0359 INPUT Q$,TRANS$0360 rem0361 LET trans$=substr(trans$,0,6)0362 LET num=stringtonumber(trans$)0363 LET num=1000*num0364 LET num=1/(6.46628e-4+3.19423e-4*log(num)+9.61791e-8*pow(log(num),3))0365 LET num=num-273.150366 LET trans$=substr(numberstr(num),0,5)0367 wprint w1,trans$ & " " & "deg.C"0370 LET newtime=(ticks()-oldtime)/600373 if Cancel.viewvalue=true Then Goto 04800374 let d[pl,cup,c]=trans$0375 if c=10 then goto 4800376 if (newtime/c)<y then goto 3400380 let c=c+10450 if Cancel.viewvalue=true Then Goto 04800470 GOTO 03400480 environ io="screen"0490 cls0540 hide0560 next cup0565 print "any more plants? y/n"0566 input choice$0567 if choice$= "n" then goto 5720570 let pl=pl+10571 goto 50572 if c=0 then print "Sorry,no data acquired. Program ends!"0573 if c=0 then end0580 LET choice={goto:590,pickitems:["Transfer Data to Computer","View Data","stop"]}0581 window w8,choice,"PICKER"0582 show w80583 wait 10000584 GOTO 05830590 cls0591 LET which=choice.viewvalue0592 if which=0 then goto 6000593 if which=1 then goto 7300600 let cp=env("s0")0610 let cp.data=[9600,8,1,"no"]0620 let cp.connect=nil0630 environ s0=cp0640 environ io="s0"0645 if which=2 then environ io="screen"0646 if which = 2 then stop0650 print "Number of plants "0651 print pl0652 for np=1 to pl0653 let cn=c[np]0654 print "Number of cups"0655 print cn0656 for cup=1 to cn0657 for temp=1 to 100658 print d[np,cup,temp]0659 next temp0660 next cup0661 print "notes"0662 print A[np]0664 next np0710 environ io="screen"0720 GOTO 05800730 cls0731 print "Number of plants "0732 print pl0733 for np=1 to pl0734 let cn=c[np]0735 print "Number of cups"0736 print cn0737 for cup=1 to cn0738 for temp=1 to 100739 print d[np,cup,temp]0740 next temp0741 next cup0742 print "notes"0743 print A[np]0744 next np0745 cls0910 environ io="screen"0920 GOTO 0580Arm Disassembler code0020  LET Cond=["EQ","NE","CS","CC","MI","PL","VS","VC","HI","LS","GE","LT","GT"," LE","AL","NV"] 0030  function GetAscii(i,incr) begin local ascii:=Array(incr,nil),char;foreach elem,val in ascii do begin char:=ExtractChar(u.b,i+elem);if Ord(char)<32 or Ord(char)>126 then char:=Chr(32);ascii[elem]:=char;end;stringer(ascii) end 0100  LET Regs:=["R0","R1","R2","R3","R4","R5","R6","R7","R8","R9","R10","R11","R12","R13","R14","PC"] 0110  LET OpCode:=["AND","EOR","SUB","RSB","ADD","ADC","SBC","RSC","TST","TEQ","CMP","CMN","ORR","MOV","BIC","MVN"]0120  LET shifts:=["LSL","LSR","ASR","ROR"]0130  LET blockXMods:=[["ED","EA","FD","FA"],["DA","IA","DB","IB"]]0140  LET masks:=[[201326592,264241248,246419296,134217728,134217728,100663296,67108864,33554432,16777232,16777216,0],[0,144,16777360,67108864,100663312,134217728,167772160,201326592,234881024,234881040,251658240]] 0150  Function IsMasked(instr,mask) (BAnd(BNot(instr),u.masks[0][mask])=u.masks[0][mask]) and (BAnd(instr,u.masks[1][mask])=u.masks[1][mask]) 0160  Function IsBitSet(instr,pos) BAnd(instr,1<<pos)>00170  Function WhichSet(code) begin local i:=10,instr:=U:GetLong(code);while Not U:IsMasked(instr,i) do i:=i-1;i end 0180  Function GetLong(code) begin local firstByte:=ExtractByte(code,0),cd:=Clone(code);if firstByte<0xC0 then StuffByte(cd,0,BOr(firstByte,0xC0));ExtractLong(cd,0) end 0190  Function GetCondition(code) begin local n;n:=ExtractByte(code,0)>>4;if n=14 then return "";else return u.cond[n];end 0200  Function GetOffSet(instr) begin local x:=BAnd(instr,0xFFFFFF)<<2;if x>=0x2000000 then x:=x- 0x4000000;x+u.addr+8 end 0210  Function GetOpCode(instr) BAnd(instr>>21,0xF)0220  Function GetReg(instr,pos) u.Regs[BAnd(instr>>pos,0xF)]0230  Function GetOp2(instr) begin local s,Rm,val,str,imm:=U:IsBitSet(instr,25);if imm then begin str:="#"&BAnd(instr,0xFF);val:=BAnd(instr>>8,0xF);if val<>0 then str:=str&&u.shifts[3]&&val<<1;end;else begin Rm:=U:GetReg(instr,0);s:=U:GetShift(instr);str:=Rm;if s then str:=str&$,&s;end;str end 0240  Function GetShift(instr) begin local val,isReg,str;isReg:=U:IsBitSet(instr,4);str:=u.shifts[BAnd(instr>>5,0x3 )];if isReg then begin return str&&U:GetReg(instr,8);end;else begin local val:=BAnd(instr>>7,0x1F); if val<>0 then return str&&"#"&val;else return nil;end;end 0250  Function MakeInstr(code) begin if U.cstring then return U:MakeCString();local val,set:=U:WhichSet(code);if set=0 then return U:MakeDataProc(code);if set=1 then return U:MakeMul(code);if set=2 then return U:MakeSwap(code);if set=3 then return U:MakeSingleDataX(code);if set=4 then return U:MakeUndefined(code);if set=5 then return U:MakeBlockDataX(code);if set=6 then return U:MakeBranch(code);if set=10 then return U:MakeSWInt(code);set end 0260  Function MakeCString() begin U.cstring:=nil;val:=ExtractCString(u.b,u.addr);u.addr:=u.addr+4*(1+(Length(val) div 4));val end 0270  Function MakeBranch(code) begin local instr:=U:GetLong(code),str:="B";if U:IsBitSet(instr,24) then str:=str&"L";str:=str&U:GetCondition(code);str&&U:GetOffSet(instr) end 0280  Function MakeDataProc(code) begin local instr:=U:GetLong(code),op:=U:GetOpCode(instr),str;str:=u.opcode[op]&U:GetCondition(code);if op>=8 and op<=11 and not U:IsBitSet(instr,20) then return U:GetPSRTransfer(code);if op<8 or op>11 then begin if U:IsBitSet(instr,20) then str:=str&"S";str:=str&&u:GetReg(instr,12);if op<>13 and op<>15 then str:=str&$,&u:GetReg(instr,16);end;else str:=str&&U:GetReg(instr,16);str&$,&U:GetOp2(instr) end 0290  Function GetPSRTransfer(code) begin local instr:=U:GetLong(code),SPSR:=U:IsBitSet(instr,22),str;if U:IsBitSet(instr,21) then begin str:="MSR"&U:GetCondition(code);if SPSR then str:=str&&"SPSR";else str:=str&&"CPSR";if U:IsBitSet(instr,16) then str:=str&$,&U:GetReg(instr,0);else str:=str&"_flg,"&U:GetOp2(instr);end;else begin str:="MRS"&U:GetCondition(code)&&U:GetReg(instr,12)&$,;if SPSR then str:=str&"SPSR";else str:=str&"CPSR";end;str end 0300  Function MakeMul(code) begin local instr:=U:GetLong(code),A:=U:IsBitSet(instr,21),str;if A then str:="MLA";else str:="MUL";str:=Str&U:GetCondition(code);if U:IsBitSet(instr,20) then str:=str&"S";str:=str&&U:GetReg(instr,16)&$,&U:GetReg(instr,0)&$,&U:GetReg(instr,8);if A then str:=str&$,&U:GetReg(instr,12);str end 0310  Function MakeSingleDataX(code) begin local str,instr:=U:GetLong(code),isLoad:=U:IsBitSet(instr,20),Rd:=U:GetReg(instr,12);if isLoad then str:="LDR";else str:="STR";str:=str&U:GetCondition(code);if U:IsBitSet(instr,22) then str:=str&"B";if U:IsBitSet(instr,21) and not U:IsBitSet(instr,24) then str:=str&"T";if StrEqual(Rd,"PC") and not isLoad then str:=str&&$#&(u.addr+12);else str:=str&&Rd;str&$,&U:GetAddress(instr) end 0320  Function GetAddress(instr) begin local val,Rn,Rm,P,str,I,W,V;Rn:=U:GetReg(instr,16);W:=U:IsBitSet(instr,21);V:= U:IsBitSet(instr,23);P:=U:IsBitSet(instr,24);I:=not U:IsBitSet(instr,25);if not I then begin Rm:=U:GetReg(instr,0);str:=$[&Rn;if not P then str:=str&$];val:=U:GetShift(instr);if val then begin str:=str&$,;if not V then str:=str&$-;str:=str&val;end;if P then str:=str&$];end;else begin val:=BAnd(instr,0xFFF);if not V then val:=-val;if StrEqual(Rn,"PC") then str:=$#&(u.addr+val+8);else begin str:=$[&Rn;if not P then str:=str&$];if val<>0 then begin str:=str&$,;if not V then str:=str&$- ;str:=str&$#&abs(val);end;if P then str:=str&$];end;end;if W then str:=str&$!;str end 0330  Function MakeSwap(code) begin local instr:=U:GetLong(code),str:="SWP"&U:GetCondition(code);if U:IsBitSet(instr,22) then str:=str&"B";str&&U:GetReg(instr,12)&$,&U:GetReg(instr,0)&",["&U:GetReg( instr,16)&"]" end 0340  Function MakeSWInt(code) begin local str,data,routine,instr;str:="SWI"&U:GetCondition(code);instr:=U:GetLong( code);data:=BAnd(instr,0xFF);routine:=BAnd(instr>>8,0xFFFF);str&&$#&routine&$+&$"&Chr(data)&$" end 0350  Function MakeUndefined(code) "UND"&U:GetCondition(code)&&"0x"&StrHexDump(ExtractBytes(code,1,3,'code) ,0) 0360  Function GetList(instr) begin local i,list,lastReg,L;L:=U:IsBitSet(instr,20);i:=0;list:="";repeat while not U:IsBitSet(instr,i) do i:=i+1;if i<=15 then begin lastReg:=i;if not StrEqual(list,"") then list:=list&$,;if not L and i=15 then list:=list&$#&(u.addr+12);else list:=list&U:GetReg(i,0);while U:IsBitSet(instr,i) do i:=i+1;if i<15 and (i-1)<>lastReg then begin if (i-2)>lastReg then list:=list&$-;else list:=list&$,;if not L and (i- 1)=15 then list:=list&$#&(u.addr+12);else list:=list&U:GetReg(i- 1,0);end;end;until i>=15;list end 0370  function MakeBlockDataX(code) begin local str,instr:=U:GetLong(code),L:=U:IsBitSet(instr,20);if L then str:="LDM";else str:="STM";str:=str&U:GetCondition(code);local m:=BAnd(instr>>23,3);if u.stackMode=0 and L then str:=str&u.blockXMods[u.stackMode][3-m];else str:=str&u.blockXMods[u.stackMode][m];str:=str&&U:GetReg(instr,16);if U:IsBitSet(instr,21) then str:=str&"!";str:=str&",{"&U:GetList(instr)&"}";if U:IsBitSet(instr,22) then str:=str&"^";str end 0380  PRINT "Type in native function location (return for example)."0390  input aStr$0400  if StrLen(aStr$)=0 then aStr$:="GetRoot().|Basic:NSBasic|.stepAllocateContext[1].commsCheck"0410  on error goto 03800420  LET afn:=Compile(aStr$)0430  LET a:=U:afn()0440  on error goto 00000445  if not IsFunction(a) then goto 4600450  if HasSlot(a,'code) then goto 04800460  PRINT "This is not a compiled native function"0470  GOTO 03800480  on error goto 00000485  LET stackmode:=00487  LET cstring:=nil0490  LET b:=a.code0500  LET endCode:=4*200510  PRINT aStr$0520  PRINT "Address |   Hex   |  Ascii : ARM Instruction"0530  LET start:=a.offset0540  LET ending:=MIN(start+endCode,length(b)-4)0550  for addr=start To ending step 40560    if addr>=Length(b)-3 then goto 06400570    LET snip:=ExtractBytes(b,addr,4,'code)0580    LET instruct:=U:MakeInstr(snip)0590    LET hex:=StrHexDump(snip,0)0600    LET ascii:=U:GetAscii(addr,4)0610    PRINT addr&" | "&hex&" | "&ascii&" : "&instruct0620  Next Addr0630  PRINT "input next starting address (<0 to quit, return for next 20 instructions)"0640  input start0650  if IsString(start) then LET start:=addr+40660  if start>=0 then goto 05400670  PRINT "Do you want to disassemble a new function? (Y/N)"0680  input str$0690  if BeginsWith(DownCase(str$),"y") then goto 03800700  end