{\rtf1 \pc {\fonttbl {\f1\fnil Times;}{\f2\fnil Helvetica;}{\f3\fnil Chicago;}{\f4\fnil Courier;}{\f5\fnil Geneva;}{\f6\fnil New York;}{\f7\fnil Symbol;}{\f8\fnil Tms Rmn;}{\f9\fnil Thames;}{\f10\fnil Symbols;}}{\colortbl \red0\green0\blue0\red0\green0\blue255\red0\green255\blue255\red0\green255\blue0\red255\green0\blue255\red255\green0\blue0\red255\green255\blue0\red255\green255\blue255}{\stylesheet {\s2 \qj \fi-1701 \li3402 \sl259 \tx3402 \plain \f9 \sbasedon0\snext2 Abbreviation;}{\s3 \sb135 \sa283 \sl388 \pagebb \tx0 \tx850 \tx1712 \tx2160 \tx3339 \tx4525 \tx5704 \tx6883 \plain \f9 \fs36 \b \sbasedon0\snext3 Appendix:1;}{\s4 \qj \fi-850 \li850 \sb215 \sa114 \sl259 \tx850 \tx1700 \tx2562 \tx3010 \tx4189 \tx5375 \tx6554 \tx7733 \plain \f9 \sbasedon0\snext4 Appendix:2;}{\s5 \qj \fi-283 \li1134 \ri850 \sa114 \sl259 \tx1134 \tx1724 \tx2313 \tx2904 \tx3499 \tx4088 \tx4678 \tx5267 \tx5857 \tx6446 \tx7036 \tqr \tx8419 \plain \f9 \sbasedon0\snext5 Bullet:1st;}{\s6 \qj \li1418 \sa114 \sl259 \tx1418 \tx2008 \tx2597 \tx3188 \tx3783 \tx4372 \tx4962 \tx5551 \tx6141 \tx6730 \tx7320 \tqr \tx8703 \plain \f9 \sbasedon0\snext6 Bullet:1stCont;}{\s7 \qj \fi-283 \li1417 \ri850 \sa114 \sl259 \tx1417 \tx2007 \tx2596 \tx3187 \tx3782 \tx4371 \tx4961 \tx5550 \tx6140 \tx6729 \tx7319 \tqr \tx8702 \plain \f9 \sbasedon0\snext7 Bullet:2nd;}{\s8 \fi-850 \li850 \sb264 \sl259 \keepn \tx850 \tqr \tx9354 \tqr \tx9638 \plain \f9 \b \sbasedon0\snext8 Conts:1 TITLE;}{\s9 \fi-850 \li1134 \sb94 \sl259 \keep \tx1134 \tqr \tx9354 \tqr \tx9638 \plain \f9 \sbasedon0\snext9 Conts:2 TITLE;}{\s10 \fi-850 \li1701 \sb37 \sl259 \keep \tx1701 \tqr \tx9354 \tqr \tx9638 \plain \f9 \sbasedon0\snext10 Conts:3 TITLE;}{\s11 \fi-702 \li1582 \sb264 \sl259 \tx1582 \tqr \tx8356 \tqr \tx8726 \plain \f9 \b \sbasedon0\snext11 Conts:Appendix;}{\s12 \fi-702 \li1582 \sb264 \sl259 \keep \tx1582 \tqr \tx8356 \tqr \tx8726 \plain \f9 \b \sbasedon0\snext12 Conts:Appendix:1;}{\s13 \fi-590 \li2178 \sb151 \sl259 \keep \tx2178 \tx8415 \tqr \tx8698 \plain \f9 \sbasedon0\snext13 Conts:Appendix:2;}{\s14 \fi-590 \li2744 \sb37 \sl259 \keep \tx2744 \tx8413 \tqr \tx8696 \plain \f9 \sbasedon0\snext14 Conts:Appendix:3;}{\s15 \qj \li1582 \sb151 \sa170 \sl259 \keep \keepn \tx1582 \tx8216 \plain \f9 \sbasedon0\snext15 Conts:Page;}{\s16 \fi-590 \li1417 \sb264 \sl259 \tx0 \tx1701 \tx8787 \tx9071 \plain \f9 \b \sbasedon0\snext16 Conts:Title:1;}{\s17 \fi-590 \li1984 \sb151 \sl259 \keep \tx2268 \tx8787 \tx9071 \plain \f9 \sbasedon0\snext17 Conts:Title:2;}{\s18 \fi-590 \li2551 \sb37 \sl259 \keep \tx0 \tx2835 \tx8787 \tx9071 \plain \f9 \sbasedon0\snext18 Conts:Title:3;}{\s19 \qj \fi-760 \li1610 \sl259 \tx1610 \tx2058 \tx2647 \tx3237 \tx3826 \tx4416 \tx5005 \tx5600 \tx6191 \tx6780 \tx7370 \tqr \tx8895 \plain \f9 \sbasedon0\snext19 Definition;}{\s20 \qj \sb37 \sa227 \sl259 \tx0 \tx448 \tx1037 \tx1627 \tx2216 \tx2806 \tx3395 \tx3990 \tx4581 \tx5170 \tx5760 \tqr \tx7285 \plain \f9 \sbasedon0\snext20 FigureText;}{\s21 \qj \fi-4933 \li4933 \sb95 \sa114 \sl259 \tx-169 \tx2098 \tx3515 \tx4933 \plain \f9 \sbasedon0\snext21 History:New;}{\s22 \qj \fi-4933 \li4933 \sb95 \sa114 \sl259 \tx-169 \tx2098 \tx3515 \tx4933 \plain \f9 \sbasedon0\snext22 History:Old;}{\s23 \qj \fi-4933 \li4933 \sb95 \sa114 \sl259 \tx-169 \tx2098 \tx3515 \tx4933 \plain \f9 \sbasedon0\snext23 History:Title;}{\s24 \qj \li850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \sbasedon0\snext24 Module:Team;}{\s25 \qj \fi-397 \li1417 \sa57 \sl259 \keep \tx1417 \tx2835 \tx4252 \tx5668 \tx7086 \tqr \tx52441 \plain \f9 \sbasedon0\snext25 NumberedPoint;}{\s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b \sbasedon0\snext26 Para:ByteCode;}{\s27 \qj \fi-566 \li1418 \ri850 \sb37 \sa227 \sl259 \keep \tx1418 \tx2836 \tx4253 \tx5669 \tx7087 \tqr \tx52442 \plain \f9 \sbasedon0\snext27 Para:Hanging;}{\s28 \qj \li850 \sb37 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \sbasedon0\snext28 Para:NoSpaceAfter;}{\s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \sbasedon0\snext29 Para:Normal;}{\s30 \qj \fi-850 \li850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \sbasedon0\snext30 Para:Num;}{\s31 \qj \li2216 \sa227 \sl259 \keep \tx2216 \tx2664 \tx3277 \plain \f9 \sbasedon0\snext31 Rationale;}{\s32 \qj \fi-850 \li1701 \ri850 \sb37 \sa114 \sl259 \keep \tx1701 \tx2267 \tx2835 \tx3402 \tx3968 \tx4536 \tx5103 \tx5669 \tx6237 \tx6803 \tx7370 \plain \f9 \sbasedon0\snext32 Reference;}{\s33 \qj \fi-1134 \li2267 \sb37 \sa114 \sl259 \keep \keepn \tx2267 \tx2715 \tx3304 \tx3894 \tx4483 \tx5073 \tx5662 \tx6257 \tx6848 \tx7437 \tx8027 \tqr \tx9552 \plain \f9 \sbasedon0\snext33 Reqt;}{\s34 \qj \fi-1134 \li2267 \sb37 \sa114 \sl259 \keep \keepn \tx2267 \tx2715 \tx3304 \tx3894 \tx4483 \tx5073 \tx5662 \tx6257 \tx6848 \tx7437 \tx8027 \tqr \tx9552 \plain \f9 \sbasedon0\snext34 ReqtRef;}{\s35 \fi-566 \li1418 \sb37 \sa227 \sl259 \keep \keepn \tx1418 \tx2836 \tx4253 \tx5669 \tx7087 \tqr \tx52442 \plain \f9 \sbasedon0\snext35 Routine:Assertions;}{\s36 \li850 \sb64 \sa170 \sl232 \keep \tx850 \tx1224 \tx1570 \tx1922 \tx2261 \tx2613 \tx2959 \tx3300 \tx3650 \tx3984 \tx4336 \tx4682 \tx5034 \tx5386 \tx5720 \tx6060 \plain \f4 \fs20 \sbasedon0\snext36 Routine:DataStruct;}{\s37 \qj \li850 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \sbasedon0\snext37 Routine:Description;}{\s38 \fi-283 \li1134 \sb8 \sa227 \sl232 \keep \tx1134 \tx1480 \tx1825 \tx2171 \tx2518 \tx2864 \tx3203 \tx3548 \tx3896 \tx4241 \tx4587 \tx4932 \tx5278 \tx5624 \tx5969 \tx6316 \tx6662 \tx7008 \tx7353 \tx7699 \tx8044 \tx8390 \tx8737 \plain \f4 \fs20 \sbasedon0\snext38 Routine:Operation;}{\s39 \li1134 \sb25 \sa114 \sl232 \keep \keepn \tx1134 \tx1508 \tx1854 \tx2206 \tx2545 \tx2897 \tx3243 \tx3584 \tx3934 \tx4268 \tx4620 \tx4966 \tx5318 \tx5670 \tx6004 \tx6344 \plain \f4 \fs20 \sbasedon0\snext39 Routine:Parameters;}{\s40 \li850 \sb25 \sa113 \sl232 \keep \keepn \tx850 \tx1417 \tx2268 \tx3685 \tx5101 \plain \f4 \fs20 \sbasedon0\snext40 Routine:Signature;}{\s41 \sl259 \plain \f9 \sbasedon0\snext41 Special:Approver;}{\s42 \sl259 \plain \f9 \sbasedon0\snext42 Special:Author;}{\s43 \qc \sl302 \plain \f9 \fs28 \b \sbasedon0\snext43 Special:Cluster;}{\s44 \qc \sb21 \sl259 \plain \f9 \sbasedon0\snext44 Special:Date;}{\s45 \sl259 \tqr \tx51024 \plain \f9 \sbasedon0\snext45 Special:Doc Classif;}{\s46 \qc \sl388 \plain \f9 \fs36 \b \sbasedon0\snext46 Special:Doc Name;}{\s47 \sb101 \sl259 \plain \f9 \sbasedon0\snext47 Special:Doc Number;}{\s48 \sl259 \tqr \tx51024 \plain \f9 \sbasedon0\snext48 Special:Doc Status;}{\s49 \qc \sl259 \plain \f9 \sbasedon0\snext49 Special:Frame Ctr;}{\s50 \sl259 \tqr \tx51024 \plain \f9 \sbasedon0\snext50 Special:Frame Rgt;}{\s51 \qj \sl240 \tx0 \tx1418 \tx2835 \tx4251 \plain \f9 \sbasedon0\snext51 Special:Last;}{\s52 \qc \sl259 \tx-6150 \tx-3634 \tx-1814 \tx0 \plain \f9 \sbasedon0\snext52 Special:Old Date;}{\s53 \qc \sl259 \tx-6150 \tx-3634 \tx-1814 \tx0 \plain \f9 \sbasedon0\snext53 Special:Old Version;}{\s54 \qc \sl388 \plain \f9 \fs36 \b \caps \sbasedon0\snext54 Special:Proj Name;}{\s55 \sb101 \sl259 \plain \f9 \sbasedon0\snext55 Special:Reviewer;}{\s56 \qj \fi-850 \li850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \i \sbasedon0\snext56 Special:TBD;}{\s57 \qc \sl379 \plain \f9 \fs36 \b \sbasedon0\snext57 Special:Version No;}{\s58 \qj \li566 \sb120 \sa1701 \sl240 \tx566 \tx1156 \tx1745 \tx2336 \tx2931 \tx3520 \tx4110 \tx4699 \tx5289 \tx5878 \tx6683 \tx7120 \tx7403 \tx8243 \plain \f9 \sbasedon0\snext58 TITLE:Blank;}{\s59 \sa114 \sl302 \keep \tx0 \tx850 \tx1712 \tx2160 \tx3339 \tx4518 \tx5698 \tx6877 \plain \f9 \fs28 \b \sbasedon0\snext59 TITLE:Left;}{\s60 \qc \sb62 \sa170 \sl388 \keep \tx0 \tx1077 \tx2160 \tx3237 \tx4320 \tx5397 \tx6480 \tx7557 \tx8640 \tx9717 \tx10800 \tx11877 \tx12960 \tx14037 \plain \f9 \fs36 \b \caps \sbasedon0\snext60 TITLE:Middle;}{\s61 \qr \sb58 \sa114 \sl302 \keep \tx0 \tx850 \tx1712 \tx2160 \tx3339 \tx4525 \tx5704 \tx6883 \plain \f9 \fs28 \b \sbasedon0\snext61 TITLE:Right;}{\s62 \fi-850 \li850 \sb175 \sa283 \sl388 \keep \tx850 \tx1700 \tx2562 \tx3010 \tx4189 \tx5375 \tx6554 \tx7733 \plain \f9 \fs36 \b \sbasedon0\snext62 Title:1;}{\s63 \fi-850 \li850 \sb228 \sa170 \sl302 \keepn \tx850 \tx1700 \tx2268 \tx3685 \tx5101 \tx6519 \tx7936 \tx9354 \plain \f9 \fs28 \b \sbasedon0\snext63 Title:2;}{\s64 \fi-850 \li850 \sb135 \sa114 \sl259 \keep \keepn \tx850 \tx1700 \tx2268 \tx3685 \tx5101 \tx6519 \tx7936 \tx9354 \tx10772 \tx12189 \plain \f9 \b \sbasedon0\snext64 Title:3;}{\s65 \li850 \sb169 \sa114 \sl185 \tx850 \tx1224 \tx1570 \tx1922 \tx2261 \tx2613 \tx2959 \tx3300 \tx3650 \tx3984 \tx4336 \tx4682 \tx5034 \tx5386 \tx5720 \tx6060 \plain \f4 \fs16 \sbasedon0\snext65 Type:Code;}{\s66 \li850 \sa56 \sl232 \tx850 \tx2268 \tx3685 \tx5101 \plain \f4 \fs20 \sbasedon0\snext66 Type:Paragraph;}{\s67 \qj \sl259 \keep \keepn \tx0 \tx1077 \tx2154 \tx3232 \tx4309 \tx5386 \tx6462 \tx7541 \tx8618 \tx9694 \tx10771 \tx11850 \tx12926 \tx14003 \plain \f9 \sbasedon0\snext67 a4_pysty;}{\s68 \qj \sl259 \keep \keepn \tx0 \tx1077 \tx2154 \tx3232 \tx4309 \tx5386 \tx6462 \tx7541 \tx8618 \tx9694 \tx10771 \tx11850 \tx12926 \tx14003 \plain \f9 \sbasedon0\snext68 a4_vaaka;}{\s69 \qj \sb16 \sa43 \sl267 \tx0 \tx720 \tx1440 \tx2160 \plain \f9 \sbasedon0\snext69 micro:caption;}{\s70 \sb74 \sa56 \sl222 \tx0 \tx283 \plain \f9 \fs20 \sbasedon0\snext70 micro:ftnote;}}\paperw11904 \paperh16837 \margl1440 \margr1440 \margt850 \margb850 \widowctrl \ftnbj \margmirror \sectd \pgndec \colsx475 \titlepg {\footerf }{\header }{\footer \pard\plain \s69 \qc \sa38 \sl267 \tx0 \tx720 \tx1440 \tx2160 \plain \f9 -\chpgn -\par }{\headerf }\pard\plain \s60 \qc \sb22 \sa170 \sl388 \keep \tx0 \tx1077 \tx2160 \tx3237 \tx4320 \tx5397 \tx6480 \tx7557 \tx8640 \tx9717 \tx10800 \tx11877 \tx12960 \tx14037 \plain \f9 \fs36 \b \b0 NewtonScript ByteCode\par \pard\plain \s60 \qc \sb142 \sa170 \sl388 \keep \tx0 \tx1077 \tx2160 \tx3237 \tx4320 \tx5397 \tx6480 \tx7557 \tx8640 \tx9717 \tx10800 \tx11877 \tx12960 \tx14037 \plain \f9 \fs36 \b \caps \fs28 \b0 \caps M\plain \f9 \fs28 atthew Faupel\line \line Draft 0\line \line 15 Nov 1994\par \pard\plain \s15 \qj \sb92 \sa114 \sl302 \keep \keepn \tx0 \tx8277 \plain \f9 \fs28 \b Contents\par \pard\plain \s16 \fi-590 \li1417 \sb304 \sl259 \tx0 \tx1701 \tx8787 \tx9071 \plain \f9 \b 1\tab Background to ByteCode\tab \tab 2\par \pard\plain \s17 \fi-590 \li1984 \sb151 \sl259 \keep \tx2268 \tx8787 \tx9071 \plain \f9 1.1\tab The Representation of Compiled NewtonScript\tab \tab 2\par \pard\plain \s17 \fi-590 \li1984 \sb151 \sl259 \keep \tx2268 \tx8787 \tx9071 \plain \f9 1.2\tab How Values are Encoded in NewtonScript\tab \tab 3\par \pard\plain \s16 \fi-590 \li1417 \sb264 \sl259 \tx0 \tx1701 \tx8787 \tx9071 \plain \f9 \b 2\tab ByteCode\tab \tab 4\par \pard\plain \s17 \fi-590 \li1984 \sb151 \sl259 \keep \tx2268 \tx8787 \tx9071 \plain \f9 2.1\tab The General Format of ByteCode\tab \tab 4\par \pard\plain \s17 \fi-590 \li1984 \sb151 \sl259 \keep \tx2268 \tx8787 \tx9071 \plain \f9 2.2\tab Explanation of the Description of Individual ByteCodes\tab \tab 4\par \pard\plain \s17 \fi-590 \li1984 \sb151 \sl259 \keep \tx2268 \tx8787 \tx9071 \plain \f9 2.3\tab ByteCode Descriptions\tab \tab 5\par \pard\plain \s60 \qc \sb22 \sa170 \sl388 \keep \tx0 \tx1077 \tx2160 \tx3237 \tx4320 \tx5397 \tx6480 \tx7557 \tx8640 \tx9717 \tx10800 \tx11877 \tx12960 \tx14037 \plain \f9 \fs36 \b \caps \par \pard\plain \s60 \qc \sb142 \sa170 \sl388 \keep \tx0 \tx1077 \tx2160 \tx3237 \tx4320 \tx5397 \tx6480 \tx7557 \tx8640 \tx9717 \tx10800 \tx11877 \tx12960 \tx14037 \plain \f9 \fs36 \b \caps \plain \f9 Abstract\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 This technical report details my discoveries about NewtonScript bytecode.  It is not an official Apple document and as the information was discovered by observation only, it may be neither accurate nor complete.  This document is distributed in the hope that it will be useful, but \i without any warranty\i0 ; without even the implied warranty of \i merchantability\i0  or \i fitness for a particular purpose\i0 .\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 The discoveries detailed in this technical report cover how compiled NewtonScript\f10 \up6  \f9 \up0 is represented on the Apple MessagePad platform, how values are encoded, the general format of bytecode, and the behaviour of individual bytecodes.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 The author is indebted to Jason Harper for his ViewFrame Demo program, which made me realise that bytecode might not be as impenetrable as I first thought.  Any omissions or errors in this document are though, entirely my responsibility.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Apple and Newton are trademarks of Apple Computer, Inc., registered in the United States and other countries.  MessagePad, NewtonScript and Newton ToolKit are trademarks of Apple Computer, Inc.  ViewFrame is a trademark of Jason Harper. \par \pard\plain \s62 \fi-850 \li850 \sb135 \sa283 \sl388 \keep \pagebb \tx850 \tx1700 \tx2562 \tx3010 \tx4189 \tx5375 \tx6554 \tx7733 \plain \f9 \fs36 \b {\plain \f9 \fs36 \b \caps 1\tab }\plain \f9 \fs36 \b Background to ByteCode\par \pard\plain \s29 \qj \li850 \ri850 \sb157 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 In order to understand fully the description of NewtonScript bytecode given in the second section of this report a number of things first need to be made clear.\par \pard\plain \s63 \fi-850 \li850 \sb108 \sa170 \sl302 \keepn \tx850 \tx1700 \tx2268 \tx3685 \tx5101 \tx6519 \tx7936 \tx9354 \plain \f9 \fs28 \b {\plain \f9 \fs28 \b 1.1\tab }The Representation of Compiled NewtonScript\par \pard\plain \s29 \qj \li850 \ri850 \sb77 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 A compiled NewtonScript function is represented on the MessagePad as a frame with the following fixed format:\par \pard\plain \s36 \li850 \sb64 \sa170 \sl232 \keep \tx850 \tx1224 \tx1570 \tx1922 \tx2261 \tx2613 \tx2959 \tx3300 \tx3650 \tx3984 \tx4336 \tx4682 \tx5034 \tx5386 \tx5720 \tx6060 \plain \f4 \fs20 \{\line \tab class: 'CodeBlock,\line \tab instructions: <bytecode of type 'instructions>,\line \tab literals: [...],\line \tab argFrame: \{\line \tab \tab _nextArgFrame: \{\}\line \tab \tab _Parent: \{\},\line \tab \tab _implementor: \{\},\line \tab \tab ...\line \tab \tab \},\line \tab numArgs: <integer>\line \}\par \pard\plain \s5 \qj \fi-283 \li1134 \ri850 \sa114 \sl259 \tx1134 \tx1724 \tx2313 \tx2904 \tx3499 \tx4088 \tx4678 \tx5267 \tx5857 \tx6446 \tx7036 \tqr \tx8419 \plain \f9 {\plain \f9 \f10 \fs20 D\f9 \fs24 \tab \f4 \fs20 }\fs22 class\f9 \fs24  is always set to the symbol \f4 \fs22 'CodeBlock\f9 \fs24 .\par \pard\plain \s5 \qj \fi-283 \li1134 \ri850 \sa114 \sl259 \tx1134 \tx1724 \tx2313 \tx2904 \tx3499 \tx4088 \tx4678 \tx5267 \tx5857 \tx6446 \tx7036 \tqr \tx8419 \plain \f9 {\plain \f9 \f10 \fs20 D\f9 \fs24 \tab \f4 \fs20 }\fs22 instructions\f9 \fs24  is a block of bytecode bytes, the meaning of which we will get to a little later.\par \pard\plain \s5 \qj \fi-283 \li1134 \ri850 \sa114 \sl259 \tx1134 \tx1724 \tx2313 \tx2904 \tx3499 \tx4088 \tx4678 \tx5267 \tx5857 \tx6446 \tx7036 \tqr \tx8419 \plain \f9 {\plain \f9 \f10 \fs20 D\f9 \fs24 \tab \f4 \fs20 }\fs22 literals\f9 \fs24  is an array of all the literal values used in the NewtonScript function (symbols, staticly defined frames, sub?functions and so on).\par \pard\plain \s5 \qj \fi-283 \li1134 \ri850 \sa114 \sl259 \tx1134 \tx1724 \tx2313 \tx2904 \tx3499 \tx4088 \tx4678 \tx5267 \tx5857 \tx6446 \tx7036 \tqr \tx8419 \plain \f9 {\plain \f9 \f10 \fs20 D\f9 \fs24 \tab \f4 \fs20 }\fs22 numArgs\f9 \fs24  is the number of arguments to the function.\par \pard\plain \s5 \qj \fi-283 \li1134 \ri850 \sa114 \sl259 \tx1134 \tx1724 \tx2313 \tx2904 \tx3499 \tx4088 \tx4678 \tx5267 \tx5857 \tx6446 \tx7036 \tqr \tx8419 \plain \f9 {\plain \f9 \f10 \fs20 D\f9 \fs24 \tab \f4 \fs20 }\fs22 argFrame\f9 \fs24  consists of three sections:\par \pard\plain \s7 \qj \fi-283 \li1417 \ri850 \sa114 \sl259 \tx1417 \tx2007 \tx2596 \tx3187 \tx3782 \tx4371 \tx4961 \tx5550 \tx6140 \tx6729 \tx7319 \tqr \tx8702 \plain \f9 {\plain \f9 \f10 S\f9 \tab \f4 \fs20 }\f9 \fs24 The first three items are always the fixed slots \f4 \fs22 _nextArgFrame\f9 \fs24 , \f4 \fs22 _Parent\f9 \fs24  and \f4 \fs22 _implementor\fs20 .\par \pard\plain \s7 \qj \fi-283 \li1417 \ri850 \sa114 \sl259 \tx1417 \tx2007 \tx2596 \tx3187 \tx3782 \tx4371 \tx4961 \tx5550 \tx6140 \tx6729 \tx7319 \tqr \tx8702 \plain \f9 {\plain \f9 \f10 S\f9 \tab \f4 \fs20 }\f9 \fs24 The next \f4 \fs22 numArgs\f9 \fs24  slots (i.e. possibly none if \f4 \fs22 numArgs\f9 \fs24  is zero) are arguments of the function in the order that they appear in the source code.\par \pard\plain \s7 \qj \fi-283 \li1417 \ri850 \sa114 \sl259 \tx1417 \tx2007 \tx2596 \tx3187 \tx3782 \tx4371 \tx4961 \tx5550 \tx6140 \tx6729 \tx7319 \tqr \tx8702 \plain \f9 {\plain \f9 \f10 S\f9 \tab \f4 \fs20 }\f9 \fs24 Any remaining slots (again possibly none) represent the local variables declared within the function.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 To give a concrete example, here is a short NewtonScript function and the frame that represents it:\par \pard\plain \s36 \li850 \sb64 \sa170 \sl232 \keep \tx850 \tx1224 \tx1570 \tx1922 \tx2261 \tx2613 \tx2959 \tx3300 \tx3650 \tx3984 \tx4336 \tx4682 \tx5034 \tx5386 \tx5720 \tx6060 \plain \f4 \fs20 func( foo, bar )\tab \tab \tab \tab \tab \tab \tab \tab \{\line begin\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab class: 'CodeBlock,\line \tab local\tab fred := '[];\tab \tab \tab \tab \tab \tab \tab instructions: <instructions>,\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab /* 18 A5 7D 02 */\line \tab return fred\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab literals: [ '[] ],\line end\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab argFrame: \{\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab _nextArgFrame: \{\},\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab _Parent: \{\},\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab _implementor: \{\},\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab foo: NIL,\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab bar: NIL,\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab fred: NIL\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \},\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab numArgs: 2\line \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \}\par \pard\plain \s63 \fi-850 \li850 \sb68 \sa170 \sl302 \keepn \tx850 \tx1700 \tx2268 \tx3685 \tx5101 \tx6519 \tx7936 \tx9354 \plain \f9 \fs28 \b {\plain \f9 \fs28 \b 1.2\tab }How Values are Encoded in NewtonScript\par \pard\plain \s29 \qj \li850 \ri850 \sb77 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 A knowledge of how NewtonScript encodes values is useful for understanding some of the bytecodes.  Certain simple values such as integers, and the constants True and Nil are encoded as immediate values.  More complex values such as floats, icons, frames and arrays are encoded as separate data blocks and then referred to via a pointer.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 NewtonScript has a uniform way of encoding both the simple values and the pointers to more complex values within a 32 bit field.  It achieves this by using the lowest two bits of the field as a type identifier.  What the value means for each of the four possible types is as follows:\par \pard\plain \s27 \qj \fi-566 \li1418 \ri850 \sb37 \sa227 \sl259 \keep \tx1418 \tx2836 \tx4253 \tx5669 \tx7087 \tqr \tx52442 \plain \f9 00\tab The field represents a signed integer in the range -2\up6 29\up0  to +2\up6 29\up0 -1.  i.e. if the low two bits of the 32 bit value are zero, the integer value that it represents can be obtained by performing \f4 \fs22 value\f9 \fs24  \f4 \fs22 >>\f9 \fs24  \f4 \fs22 2\f9 \fs24 .\par \pard\plain \s27 \qj \fi-566 \li1418 \ri850 \sb37 \sa227 \sl259 \keep \tx1418 \tx2836 \tx4253 \tx5669 \tx7087 \tqr \tx52442 \plain \f9 01\tab The field represents a pointer to a complex structure.  The pointer value can be obtained by performing \f4 \fs22 value\f9 \fs24  \f4 \fs22 &\f9 \fs24  \f4 \fs22 0xFFFFFFFC\f9 \fs24 .\par \pard\plain \s27 \qj \fi-566 \li1418 \ri850 \sb37 \sa227 \sl259 \keep \tx1418 \tx2836 \tx4253 \tx5669 \tx7087 \tqr \tx52442 \plain \f9 10\tab The field represents a unique system value.  As far as I'm aware the possible values are:\par \pard\plain \s27 \qj \fi-566 \li1418 \ri850 \sb37 \sa227 \sl259 \keep \tx1418 \tx2836 \tx4253 \tx5669 \tx7087 \tqr \tx52442 \plain \f9 \tab \f4 \fs22 0x00000002\f9 \fs24 \tab Nil\line \f4 \fs22 0x0000001A\f9 \fs24 \tab True\line \f4 \fs22 0x000UUUU6\f9 \fs24 \tab The Unicode character \f4 \fs22 \\uUUUU\f9 \fs24 , e.g. the NewtonScript constant\line \tab \f4 \fs22 $A\f9 \fs24  translates to the immediate value \f4 \fs22 0x00000496\f9 \fs24 .\par \pard\plain \s27 \qj \fi-566 \li1418 \ri850 \sb37 \sa227 \sl259 \keep \tx1418 \tx2836 \tx4253 \tx5669 \tx7087 \tqr \tx52442 \plain \f9 11\tab The field represents a magic pointer.  These are the constants that are reperesented as \f4 \fs22 @<number>\f9 \fs24  and have names beginning with \f4 \fs22 ROM_\f9 \fs24  in the NTK definitions file.  The number is encoded in the top 30 bits of the field.  As an example, \f4 \fs22 ROM_asciishift\f9 \fs24  (\f4 \fs22 @7\f9 \fs24 ) is encoded as \f4 \fs22 0x0000001F\f9 \fs24 , i.e. ....\f4 \fs22 000111\f9 \fs24  \f4 \fs22 11\f9 \fs24 .\par \pard\plain \s62 \fi-850 \li850 \sb135 \sa283 \sl388 \keep \pagebb \tx850 \tx1700 \tx2562 \tx3010 \tx4189 \tx5375 \tx6554 \tx7733 \plain \f9 \fs36 \b {\plain \f9 \fs36 \b \caps 2\tab }\plain \f9 \fs36 \b ByteCode\par \pard\plain \s63 \fi-850 \li850 \sb228 \sa170 \sl302 \keepn \tx850 \tx1700 \tx2268 \tx3685 \tx5101 \tx6519 \tx7936 \tx9354 \plain \f9 \fs28 \b {\plain \f9 \fs28 \b 2.1\tab }The General Format of ByteCode\par \pard\plain \s29 \qj \li850 \ri850 \sb77 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 All NewtonScript bytecodes are either one or three bytes long.  If the low three bits of the first byte in the sequence are all 1 then the following two bytes are also part of the instruction, otherwise it is a single byte instruction.  The following are all examples of valid byte codes (shown in hexadecimal):\par \pard\plain \s36 \li850 \sb64 \sa170 \sl232 \keep \tx850 \tx1224 \tx1570 \tx1922 \tx2261 \tx2613 \tx2959 \tx3300 \tx3650 \tx3984 \tx4336 \tx4682 \tx5034 \tx5386 \tx5720 \tx6060 \plain \f4 \fs20 \tab 00\tab \tab \tab 73\tab \tab \tab 5F 02 15\tab \tab \tab 37 00 10\par \pard\plain \s29 \qj \li850 \ri850 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Very often (but not always) the low three bits are used as a count value and if the required value exceeds 6 then all three bits are set and the following two bytes are used instead for the value.  Hence this initially rather odd seeming format is actually quite useful for keeping bytecode compact.  The use of this count field is explained in more detail below.\par \pard\plain \s63 \fi-850 \li850 \sb108 \sa170 \sl302 \keepn \tx850 \tx1700 \tx2268 \tx3685 \tx5101 \tx6519 \tx7936 \tx9354 \plain \f9 \fs28 \b {\plain \f9 \fs28 \b 2.2\tab }Explanation of the Description of Individual ByteCodes\par \pard\plain \s29 \qj \li850 \ri850 \sb77 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 All of the bytecode descriptions given below follow the same format:\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Octal value\tab (Hex value) Name\line \line \tab Stack behaviour\line \line \tab Longer description.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 The bytecodes are given as octal values first, because this makes it easier to show the low three bits of the code as a separate digit.  As mentioned above, these three bits often act as a count field.  When this is the case, the letter `N' will be used instead of a digit and the role played by the count field will be explained in the stack behaviour and description sections.  Remember that any bytecode listed as xxN can be either one or three bytes long!\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 The hex value of the bytecode is also given as tools such as ViewFrame tend to show raw data in hex format rather than octal.  In the case of bytecodes with a count field, the hex value given will be with the count set to zero.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Bytecode is executed on a virtual machine that uses a stack of NewtonScript values (see section 1.2), hence how each instruction modifies the stack important.  The stack behaviour is shown as:\line \line \{items removed from stack by execution\} -> \{items placed on stack after execution\}\line \line The items are listed in the order that they are pushed onto the stack, i.e. the leftmost is the first item pushed and the rightmost the last.  Repetition of items is indicated by braces (...) followed by a repetition count.  If an item on the stack must be of a certain type, the description says so, otherwise placeholders such as \'7fX" are used.  References to arrays, frames and symbols are indicated by [], \{\} and ' respectively.  An empty stack is indicated by the symbol \'d8.\par \pard\plain \s63 \fi-850 \li850 \sb108 \sa170 \sl302 \keepn \tx850 \tx1700 \tx2268 \tx3685 \tx5101 \tx6519 \tx7936 \tx9354 \plain \f9 \fs28 \b {\plain \f9 \fs28 \b 2.3\tab }ByteCode Descriptions\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb77 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 000\tab (00) pop\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> \'d8\line \line Removes the top item from the stack.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 001\tab (01) dup\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> X, X\line \line Duplicates the top item on the stack.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 002\tab (02) return\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> \'d8\line \line Exits from a routine.  By convention, the top item on the stack is the return value of the routine.  It is possible to return from a routine with more items on the stack (or none at all), however the current Apple NewtonScript compiler ensures that the functions that it produces always leave one and only one value on the stack.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 003\tab (03) self\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> self\line \line Pushes a reference to the frame containing the current function onto the stack.  In other words this pushes the value represented by the NewtonScript value \f4 \fs22 self\f9 \fs24 .\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 004\tab (04) Create closure (?)\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \{CodeBlock\} -> \{CodeBlock\}\line \line This bytecode is inserted by the compiler whenever it has just pushed a CodeBlock frame either as a parameter to a function call or message send, or as the target of a \f4 \fs22 call...with\f9 \fs24  statement.  My guess is that this initialises the three reserved fields in the \f4 \fs22 argFrame\f9 \fs24  of the CodeBlock (see 1.1), but I haven't yet attempted to verify this.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 005\tab (05) foreach next\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 [iterator] -> \'d8\line \line Steps to next item in iteration.  See 307 000 021 - foreach for a full explanation.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 006\tab (06) foreach complete\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 [iterator] -> Boolean\line \line Checks if iteration complete.  See 307 000 021 - foreach for a full explanation.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 007\tab 000 007 (07 00 07) End exception handling (?)\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> \'d8\line \line See 31N - onexception for a full explanation.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 01N\tab (08) Apparently unused\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 02N\tab (10) Apparently unused\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 03N\tab (18) Push literal value\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> literal N\line \line Pushes the literal which is element N of the literals array of this code block onto the stack.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 04N\tab (20) Push immediate value\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> N\line \line N here is treated as an immediate value as described in section 1.2.  This instruction is used to push any immediate value that can be represented in 16 (sign extended) bits or less.  Values that require the full 32 bits are stored as literals and pushed using 03N.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Some examples of the use of this instruction:\line \line \f4 \fs22 20\f9 \fs24 \tab push 0\line \f4 \fs22 22\f9 \fs24 \tab push Nil\line \f4 \fs22 23\f9 \fs24 \tab push @0\line \f4 \fs22 24\f9 \fs24 \tab push 1\line \f4 \fs22 27\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 1A\f9 \fs24 \tab push True\line \f4 \fs22 27\f9 \fs24  \f4 \fs22 02\f9 \fs24  \f4 \fs22 86\f9 \fs24 \tab push $(\line \f4 \fs22 27\f9 \fs24  \f4 \fs22 FF\f9 \fs24  \f4 \fs22 F8\f9 \fs24 \tab push -2\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 05N\tab (28) Call global\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (Arg)N, 'FunctionSymbol -> \'d8\line \line N arguments to the function are expected on the stack (pushed in the same order that they are listed in the function parameter list), followed by a reference to the symbol that represents the name of the function (this is stored in the literals array and pushed using 03N).  Although the stack description indicates that the instruction itself pushes nothing onto the stack, remember that all NewtonScript functions conventionally push a single item onto the stack before returning.\line \line Example:\line \line \f4 \fs22 max(\f9 \fs24  \f4 \fs22 foo,\f9 \fs24  \f4 \fs22 bar\f9 \fs24  \f4 \fs22 )\f9 \fs24  translates to:\line \line \f4 \fs22 7B\f9 \fs24 \tab push \f4 \fs22 foo\f9 \fs24  (assuming it to be the first parameter of the function)\line \f4 \fs22 7C\f9 \fs24 \tab push \f4 \fs22 bar\f9 \fs24  (assuming it to be the second)\line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 'max\f9 \fs24  (assuming it to be the first literal in the function)\line \f4 \fs22 2A\f9 \fs24 \tab Call a global function with two arguments.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 06N\tab (30) Call ... with\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (Arg)N, \{004'd CodeBlock\} -> \'d8\line \line This directly translates the NewtonScript \'7f\f4 \fs22 call\f9 \fs24  \f4 \fs22 ...\f9 \fs24  \f4 \fs22 with\f9 \fs24  \f4 \fs22 ()\f9 \fs24 "  construct.  N arguments to the function are expected on the stack (pushed in the same order that they are listed in the function parameter list), followed by a reference to a CodeBlock frame that has had the 004 instruction called on it (qv).  As before, remember that all NewtonScript functions conventionally push a single item onto the stack before returning.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Example:\line \line \f4 \fs22 call func(foo) return foo with (1)\f9 \fs24  translates to:\line \line \f4 \fs22 24\f9 \fs24 \tab push 1\line \f4 \fs22 18\f9 \fs24 \tab push func (assuming it to be the first literal in the containing function)\line \tab Note that inline function definitions like this are encoded as a\line \tab CodeBlock frame in the literals array of the containing function.\line \f4 \fs22 04\f9 \fs24 \tab Form a closure for the func (?)\line \f4 \fs22 31\f9 \fs24 \tab Call ... with passing one argument.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 07N\tab (38) Send message\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (Arg)N, \{Receiver\}, 'Message -> \'d8\line \line This directly translates the NewtonScript \'7f\f4 \fs22 :\f9 \fs24 " construct.  N arguments to the message are expected on the stack (pushed in the same order that they are listed in the function parameter list), followed by a reference to the receiving frame and then the symbol of the message.  Again, remember that all NewtonScript functions conventionally push a single item onto the stack before returning.\line \line Example:\line \line \f4 \fs22 :Open()\f9 \fs24  translates to:\line \f4 \fs22 \line 03\f9 \fs24 \tab push \f4 \fs22 self\f9 \fs24 \line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 'Open\f9 \fs24  (assuming it to be the first literal in the function)\line \f4 \fs22 38\f9 \fs24 \tab Send message with zero parameters.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 10N\tab (40) Conditional send message\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (Arg)N, \{Receiver\}, 'Message -> \'d8 or Nil\line \line This directly translates the NewtonScript \'7f\f4 \fs22 :?\f9 \fs24 " construct.  N arguments to the message are expected on the stack (pushed in the same order that they are listed in the function parameter list), followed by a reference to the receiving frame and then the symbol of the message to be sent if the given function exists.  If the function doesn't exist, Nil is placed on the stack else it's left up to the function to put something there.\line \line Example:\line \line \f4 \fs22 child:?DoItIfYouCan()\f9 \fs24  translates to:\line \line \f4 \fs22 7B\f9 \fs24 \tab push \f4 \fs22 child\f9 \fs24  (assuming it to be the first parameter of the function)\line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 'DoItIfYouCan\f9 \fs24  (assuming it to be the first literal in the function)\line \f4 \fs22 40\f9 \fs24 \tab Send message with zero parameters if possible.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 11N\tab (48) Inherited send message\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (Arg)N, 'Message -> \'d8\line \line This directly translates the NewtonScript \'7f\f4 \fs22 inherited:\f9 \fs24 " construct.    N arguments to the message are expected on the stack (pushed in the same order that they are listed in the function parameter list), followed by the symbol of the message.  Again, remember that all NewtonScript functions conventionally push a single item onto the stack before returning.\line \line Example:\line \line \f4 \fs22 inherited:Open()\f9 \fs24  translates to:\line \f4 \fs22 \line 18\f9 \fs24 \tab push \f4 \fs22 'Open\f9 \fs24  (assuming it to be the first literal in the function)\line \f4 \fs22 48\f9 \fs24 \tab Send message with zero parameters to inheritance parent.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 12N\tab (50) Conditional inherited send message\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (Arg)N, 'Message -> \'d8 or Nil\line \line This directly translates the NewtonScript \'7f\f4 \fs22 inherited:?\f9 \fs24 " construct.  N arguments to the message are expected on the stack (pushed in the same order that they are listed in the function parameter list), followed by the symbol of the message to be sent if the given function exists.  If the function doesn't exist, Nil is placed on the stack else it's left up to the function to put something there.\line \line Example:\line \line \f4 \fs22 inherited:?DoItIfYouCan()\f9 \fs24  translates to:\line \line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 'DoItIfYouCan\f9 \fs24  (assuming it to be the first literal in the function)\line \f4 \fs22 50\f9 \fs24 \tab Send message with zero parameters to inheritance parent (if possible).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 13N\tab (58) Goto\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> \'d8\line \line This instruction causes execution to pass to location N, where N is the offset from the start of the block of bytecode (i.e. gotos are absolute, not relative).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 14N\tab (60) Goto if Nil\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> \'d8\line \line X is removed from the stack and examined.  If it is not Nil, execution continues with the next instruction in sequence.  If it is Nil, execution passes to location N where N is the offset from the start of the block of bytecode.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 15N\tab (68) Goto if not Nil\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> \'d8\line \line X is removed from the stack and examined.  If it is Nil, execution continues with the next instruction in sequence.  If it is not Nil, execution passes to location N where N is the offset from the start of the block of bytecode.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 16N\tab (70) Push external variable\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> value of external variable named by literal N\line \line This bytecode pushes onto the stack the value contained in a variable or slot from outside of the function.  The name of the variable to push is given by literal N in the function's literals array; this literal should be a symbol reference.\line \line Example:\line \line \f4 \fs22 length(\f9 \fs24  \f4 \fs22 functions\f9 \fs24  \f4 \fs22 )\f9 \fs24  translates to:\line \line \f4 \fs22 70\f9 \fs24 \tab push value of \f4 \fs22 functions\f9 \fs24  (assuming \f4 \fs22 'functions\f9 \fs24  is the first entry in\line \tab the literals array of the containing CodeBlock)\line \f4 \fs22 C7\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 12\f9 \fs24 \tab Return the length of \f4 \fs22 functions\f9 \fs24 .\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 17N\tab (78) Push local variable\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \'d8 -> value of local variable in slot N of argFrame\line \line This bytecode pushes onto the stack the value contained in the Nth slot of the CodeBlock's argFrame frame.  In other words, this bytecode is commonly used to push either the value of an argument to the function or that of a local variable.\line \line Example:\line \line \f4 \fs22 func(\f9 \fs24  \f4 \fs22 foo\f9 \fs24  \f4 \fs22 )\f9 \fs24  \f4 \fs22 return\f9 \fs24  \f4 \fs22 foo\f9 \fs24  translates to:\line \line \f4 \fs22 73\f9 \fs24 \tab push value of \f4 \fs22 foo\f9 \fs24  (remember argument slots start after the three fixed\line \tab slots in argFrame, hence the index is 3 not 0).\line \f4 \fs22 02\f9 \fs24 \tab Return\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 20N\tab (80) Create frame\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (SlotValue)N, [frameMap] -> \{frame\}\line \line This bytecode creates a frame given N slot values on the stack plus a frame map describing the slots in the frame.  The frame map is an array whose first item is Nil and then each subsequent item is a reference to a symbol giving the name of the corresponding slot in the frame being created.  The values are pushed onto the stack in the order of the slot names in the frame map.  If this is as clear as mud, maybe the example will help:\line \line Example:\line \line \f4 \fs22 local\f9 \fs24  \f4 \fs22 fr\f9 \fs24  \f4 \fs22 :=\f9 \fs24  \f4 \fs22 \{\f9 \fs24  \f4 \fs22 size:\f9 \fs24  \f4 \fs22 4,\f9 \fs24  \f4 \fs22 count:\f9 \fs24  \f4 \fs22 7\f9 \fs24  \f4 \fs22 \}\f9 \fs24  translates to:\line \f4 \fs22 \line 27\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 10\f9 \fs24 \tab push 4\line \f4 \fs22 27\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 1C\f9 \fs24 \tab push 7\line \f4 \fs22 18\f9 \fs24 \tab push frame map (assuming it to be the first literal in the CodeBlock)\line \tab The frame map is an array thus: \f4 \fs22 [Nil,\f9 \fs24  \f4 \fs22 'size,\f9 \fs24  \f4 \fs22 'count]\line 82\tab \f9 \fs24 Create a frame with two slots\line \f4 \fs22 A6\f9 \fs24 \tab Store in \f4 \fs22 fr\f9 \fs24  (assumed to be the 6th slot in argFrame)\line \line A final NB.  The frame map array isn't a normal array of class Array.  Its class is a small integer, whose value seems to be made up from three possible flags.  I'm investigating the meaning of these flags at the moment.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 21N\tab (88) Create array\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 (Element)N, 'Class -> [Class: ...]\tab or\line Integer, 'Class -> [Class: ...]\tab for 8F FF FF\line \line This bytecode creates an array given N element values on the stack plus a reference to a symbol defining the class of the array.  The class of the array is specified in NewtonScript with an initial \'7f\f4 \fs22 <class>:\f9 \fs24 " inside the array, e.g.: \f4 \fs22 [stepChildren:]\f9 \fs24 .  If no class is specified, then the default class of Array is used.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 In the special case of N being 0xFFFF, the instruction takes a single NewtonScript integer from the stack instead of N element values and creates an empty array (i.e. each element is Nil) with the given number of elements.\line \line Example:\line \line \f4 \fs22 local\f9 \fs24  \f4 \fs22 foo\f9 \fs24  \f4 \fs22 :=\f9 \fs24  \f4 \fs22 [\f9 \fs24  \f4 \fs22 4,\f9 \fs24  \f4 \fs22 7\f9 \fs24  \f4 \fs22 ]\f9 \fs24  translates to:\line \f4 \fs22 \line 27\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 10\f9 \fs24 \tab push 4\line \f4 \fs22 27\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 1C\f9 \fs24 \tab push 7\line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 'Array\f9 \fs24  (assuming it to be the first literal in the CodeBlock)\line \f4 \fs22 8A\tab \f9 \fs24 Create an array with two elements\line \f4 \fs22 A5\f9 \fs24 \tab Store in \f4 \fs22 foo\f9 \fs24  (assumed to be the 5th slot in argFrame)\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 221\tab (91) Push slot value\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \{frame\}, 'SlotName -> slot value\line \line This takes a frame and the name of a slot in that frame and pushes the value contained in the slot.  If the slot name is a single name then it is represented by a symbol reference.  If the slot name is a path expression (e.g. \f4 \fs22 foo.bar\f9 \fs24 ) then it is represented by an array of class pathExpr with one element per section of the path.  Each element is then a reference to the symbol for that part of the path.\line \line Example:\line \line \f4 \fs22 return self.foo.bar\f9 \fs24  translates to:\line \line \f4 \fs22 03\f9 \fs24 \tab push \f4 \fs22 self\f9 \fs24 \line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 '[pathExpr:\f9 \fs24  \f4 \fs22 'foo,\f9 \fs24  \f4 \fs22 'bar]\f9 \fs24  (assuming it to be the first literal)\line \f4 \fs22 91\f9 \fs24 \tab Get slot value\line \f4 \fs22 02\f9 \fs24 \tab Return\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 230\tab (98) Assign to slot\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \{X\}, 'SlotName, Y -> \'d8\line \line This assigns the value Y to the slot SlotName of frame X, i.e. \f4 \fs22 X.SlotName := Y\f9 \fs24 .\line As with 221 (push slot value) the slot name is represented either by a simple symbol reference or a pathExpr array for a complex path expression.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 231\tab (99) Assign to slot and push result\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \{X\}, 'SlotName, Y -> Y\line \line Identical to 230 except that the value assigned to the slot is also pushed onto the stack.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 24N\tab (A0) Assign to local variable\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> \'d8\line \line Value X is assigned to the Nth slot of the CodeBlock's argFrame frame.  In other words, this bytecode is usually used to set the value of a local variable.\line \line Example:\line \line \f4 \fs22 local x := '[]\f9 \fs24  translates to:\line \line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 '[]\f9 \fs24  (assuming it to be the first literal)\line \f4 \fs22 A7\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 10\f9 \fs24 \tab Assign to \f4 \fs22 x\f9 \fs24  (assuming it to be 16th slot in argFrame)\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 25N\tab (A8) Assign to external variable\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> \'d8\line \line Value X is assigned to a variable or slot from outside of the function.  The name of the variable to assign to is given by literal N in the function's literals array; this literal should be a symbol reference.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 26N\tab (B0) Increment local variable\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Increment -> Increment, local variable N + Increment\line \line This bytecode adds the given integer increment to the local variable in the Nth slot of the CodeBlock's argFrame and the returns both the increment and the new value of the local variable.  This instruction is used internally as part of the coding of for loops.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 27N\tab (B8) for loop goto\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Increment, value, limit -> \'d8\line \line This instruction is placed at the end of a for loop construct.  It takes the increment, current value of the counter (after having been incremented by 26N) and the limit value of the loop.  If the counter value now exceeds the loop limit,  execution continues with the next instruction in sequence.  If it does not, execution passes to location N where N is the offset from the start of the block of bytecode.  This instruction is used internally as part of the coding of for loops.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 300\tab (C0) Add\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> X+Y\line \line The 30N bytecode series encodes a number of different low?level system function calls.  Any NewtonScript operator or built?in function not explicitly mentioned here is implemented by using a standard function call (bytecode 05N).  This first bytecode of the series implements addition (of integers or floats).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 301\tab (C1) Subtract\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> X-Y\line \line Subtraction of integers or floats.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 302\tab (C2) Dereference array element\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 [X], Y -> X[Y]\line \line This pushes the array element Y of array X.  Y should be an integer.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 303\tab (C3) Assign to array element and push\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 [X], Y, Z -> Z\line \line This assignes value Z to the pushes the array element Y of array X i.e. \f4 \fs22 X[Y] := Z\f9 \fs24 .  Y should be an integer.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 304\tab (C4) Comparison for equality\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Boolean (X=Y)\line \line This compares X and Y for equality and pushes a Boolean result (True or Nil).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 305\tab (C5) Not\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> Boolean (not X)\line \line This takes any value X and returns not X.  Not Nil is True, not anything else is Nil.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 306\tab (C6) Comparison for inequality\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Boolean (X<>Y)\line \line This compares X and Y for inequality and pushes a Boolean result (True or Nil).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 007 (C7 00 07) Multiply\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> X*Y\line \line This implements multiplication (of integers or floats).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 010 (C7 00 08) Divide (with float result)\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Float (X/Y)\line \line This implements division (of integers or floats) with a float result, i.e. it corresponds to the \'7f\f4 \fs22 /\f9 \fs24 " operator in NewtonScript.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 011 (C7 00 09) Divide (with integer result)\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Integer (X div Y)\line \line This implements division of integers with an integer result, i.e. it corresponds to the \'7f\f4 \fs22 div\f9 \fs24 " operator in NewtonScript.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 012 (C7 00 0A) Compare less than\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Boolean (X < Y)\line \line This checks if X is less than Y and pushes a Boolean result (True or Nil).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 013 (C7 00 0B) Compare greater than\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Boolean (X > Y)\line \line This checks if X is greater than Y and pushes a Boolean result (True or Nil).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 014 (C7 00 0C) Compare greater than or equal\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Boolean (X >= Y)\line \line This checks if X is greater than or equal to Y and pushes a Boolean result (True or Nil).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 015 (C7 00 0D) Compare less than or equal\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Y -> Boolean (X <= Y)\line \line This checks if X is less than or equal to Y and pushes a Boolean result (True or Nil).\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 016 (C7 00 0E) Binary and\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Integer X, integer Y -> Integer band(X,Y)\line \line This performs a binary and of the two integers X and Y.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 017 (C7 00 0F) Binary or\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Integer X, integer Y -> Integer bor(X,Y)\line \line This performs a binary or of the two integers X and Y.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 020 (C7 00 10) Binary not\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 Integer X -> Integer bnot(X)\line \line This performs a binary not of the integer X.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 021 (C7 00 11) foreach\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, Boolean  -> [Iterator]\line \line This is the fundamental instruction used to implement all NewtonScript foreach loops.  If the Boolean is Nil it begins a normal foreach loop and if it is True it begins a foreach deeply loop.  The iterator returned is then passed to the other two related instructions 005 (foreach next) and 006 (foreach complete).  The iterator itself is an array containing various useful state information about what is being iterated over and how far the iteration has progressed.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 005 (foreach next) takes the iterator and modifies it so that the next item in the iteration becomes the current item.  006 (foreach complete) checks the state of the iterator and returns True if all items have been iterated over and Nil if not.\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 So, a foreach loop is implemented in bytecode as:\line \line \f4 \fs22 ??\f9 \fs24 \tab push thing being iterated over\line \f4 \fs22 27\f9 \fs24 ?\f4 \fs22 00\f9 \fs24 ?\f4 \fs22 1A/22\f9 \fs24 \tab push True or Nil (for deeply or not)\line \f4 \fs22 C7\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 11\f9 \fs24 \tab Create foreach iterator\line \f4 \fs22 A?\tab \f9 \fs24 Assign it to a local variable.\line \f4 \fs22 ...\tab \f9 \fs24 Perform other initialisation (depends on the loop type)\line \f4 \fs22 5F\f9 \fs24  \f4 \fs22 ??\f9 \fs24  \f4 \fs22 ??\f9 \fs24 \tab Goto end of loop check (Y:)\line \f4 \fs22 X:\f9 \fs24  \f4 \fs22 ...\tab \f9 \fs24 Code executed each time round the iteration.\line \f4 \fs22 7?\tab \f9 \fs24 Push the local variable referencing the iterator\line \f4 \fs22 05\tab \f9 \fs24 And move to the next thing to be iterated\line \f4 \fs22 Y:\f9 \fs24  \f4 \fs22 7?\tab \f9 \fs24 Push the iterator again\line \f4 \fs22 06\tab \f9 \fs24 And check if we've finished iterating\line \f4 \fs22 6F\f9 \fs24  \f4 \fs22 ??\f9 \fs24  \f4 \fs22 ??\f9 \fs24 \tab Go round the loop again if not (X:)\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 022 (C7 00 12) length\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> Integer length(X)\line \line This implements the length function.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 023 (C7 00 13) clone\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> clone(X)\line \line This implements the clone function.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 024 (C7 00 14) SetClass\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X, 'Symbol -> modified X\line \line This implements the SetClass function e.g. \f4 \fs22 SetClass(\f9 \fs24  \f4 \fs22 data,\f9 \fs24  \f4 \fs22 'Binary\f9 \fs24  \f4 \fs22 )\f9 \fs24 .  X is a complex data structure (frame, array or data block); SetClass sets the class of that structure and then returns a reference to the now modified structure.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 025 (C7 00 15) AddArraySlot\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 [X], Y -> Y\line \line This implements the AddArraySlot function e.g. \f4 \fs22 AddArraySlot(\f9 \fs24  \f4 \fs22 foo,\f9 \fs24  \f4 \fs22 2\f9 \fs24  \f4 \fs22 )\f9 \fs24 .  Y is added as the last element of the array X.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 026 (C7 00 16) Make string\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 [Array of strings] -> String\line \line This takes an array of strings and combines them into a single string.  This function is used to implement the NewtonScript operators \'7f\f4 \fs22 &\f9 \fs24 " and \'7f\f4 \fs22 &&\f9 \fs24 ".  \'7f\f4 \fs22 &&\f9 \fs24 " is currently done by inserting an extra single space string into the array of strings to be translated.\line \line Example:\line \f4 \fs22 \line fred && "me"\f9 \fs24  translates to:\line \line \f4 \fs22 70\f9 \fs24 \tab push value of \f4 \fs22 fred\f9 \fs24  (\f4 \fs22 'fred\f9 \fs24  is the first literal)\line \f4 \fs22 19\f9 \fs24  \f4 \fs22 1A\f9 \fs24  \f4 \fs22 1B\f9 \fs24 \tab push \f4 \fs22 " "\f9 \fs24  (second), \f4 \fs22 "me"\f9 \fs24  (third) and \f4 \fs22 'Array\f9 \fs24  (fourth)\line \f4 \fs22 8B\f9 \fs24 \tab Make an array from 3 parameters and a class symbol\line \f4 \fs22 C7\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 16\f9 \fs24 \tab Make a string from the array\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 027 (C7 00 17) Slot exists\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \{X\}, 'SlotName -> Boolean (True if X contains the given slot)\line \line This implements the exists operator, but only when checking for the existance of a slot in a frame (e.g. \f4 \fs22 foo.bar\f9 \fs24  \f4 \fs22 exists\f9 \fs24 ).  When checking for the existance of a variable, a function call (bytecode 05N) to the function HasVar is used instead.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 307\tab 000 030 (C7 00 18) ClassOf\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 X -> ClassOf(X)\line \line This implements the ClassOf function.\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 31N\tab  (C8) onexception\par \pard\plain \s29 \qj \li850 \ri850 \sb37 \sa227 \sl259 \keep \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 ('Exception, byte offset)N -> \'d8\line \line This takes N pairs of an exception symbol and an offset into the bytecode to jump to if that exception occurs.  This is used to encode the high level \f4 \fs22 try\f9 \fs24  \f4 \fs22 ...\f9 \fs24  \f4 \fs22 onexception\f9 \fs24  construct.  Note that unlike all the goto bytecodes, the offset is encoded as a standard NewtonScript integer.  At the end of both the normal and the exception code, the bytecode 007 000 007 is executed - I guess it clears whatever state was set up.\line \line Example:\line \line \f4 \fs22 try 1/0 onexception |evt.ex.div0| do nil\f9 \fs24  becomes:\line \line \f4 \fs22 18\f9 \fs24 \tab push \f4 \fs22 '|evt.ex.div0|\f9 \fs24  (first literal)\line \f4 \fs22 27\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 40\f9 \fs24 \tab push integer 16\line \f4 \fs22 C9\f9 \fs24 \tab \f4 \fs22 onexception\f9 \fs24  \f4 \fs22 '|evt.ex.div0|\f9 \fs24  \f4 \fs22 goto\f9 \fs24  \f4 \fs22 16\f9 \fs24 \line \f4 \fs22 24\f9 \fs24  \f4 \fs22 20\f9 \fs24 \tab push 1, push 0\line \f4 \fs22 C7\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 08\f9 \fs24 \tab 1/0\line \f4 \fs22 07\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 07\f9 \fs24 \tab End exception block (?)\line \f4 \fs22 5F\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 14\f9 \fs24 \tab Goto 20 (i.e. the end of this block)\line \f4 \fs22 16:\f9 \fs24  \f4 \fs22 22\f9 \fs24 \tab Push Nil\line \f4 \fs22 07\f9 \fs24  \f4 \fs22 00\f9 \fs24  \f4 \fs22 07\f9 \fs24 \tab End exception block (?)\par \pard\plain \s26 \qj \fi-850 \li850 \ri850 \sb37 \sa227 \sl259 \keep \keepn \tx850 \tx2268 \tx3685 \tx5101 \tx6519 \tqr \tx51874 \plain \f9 \b 320\tab - 377 (D0 - FF) Apparently unused\par \pard\plain \s51 \qj \sl240 \tx0 \tx1418 \tx2835 \tx4251 \plain \f9 \par }