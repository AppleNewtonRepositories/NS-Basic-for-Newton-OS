Description of the Newton Package file formatversion 3 - This document is copyright 1994 by David Fedor.Packages are composed of a package header, then a header for each part in the package, thena string section (of variable length), and then the contents of each part.  First I willgive a pseudo-C description of the headers, then I'll explain how the parts are encoded.#define uchar int						// Unicode characters are two bytes each#define PF_UNCOMPRESSED  0x10000000		// package will not be compressed on the newt#define PF_COPYPROTECTED 0x40000000		// Can't copy this package#define PF_DISPATCHONLY  0x80000000		// Set on a dispatch-only auto part (run&delete)// ----- package header -----char[8]	verify_text			// 'package0' - lets us know this is a package!char[4] unknown_text        // 'xxxx' or ' no ' or 'none' - unknown usagelong	package_flags		// a combination of the PF_ flags #define'd abovelong	pkg_version			// version # of package from NTK dialogint		unknown_1			// 0int		copyright_len		// length of copyright textint		copyright_len2		// length of copyright textint		packname_len		// length of name of packagelong	package_len			// length of entire packagelong	build_time			// time/date of build of package (NTK 1.01 and later)long	build_time2			// time/date of build of package (perhaps modification date?)long	unknown_2			// 0long	hdr_length			// length of package headerlong	num_parts			// number of parts in the package// ----- following section repeats for each part in the package -----long	part_offset			// offset of start of part data (within the package)long	part_length			// length of partlong	part_length2		// length of partchar[4]	part_code			// 'form', 'book', 'auto', etclong	unknown_3			// 0long	unknown_4			// 0x00000081int		part_sym_offset		// offset from start of text section of the "part symbol"int		part_sym_len		// length of "part symbol"long	unknown_5			// 0// ----- string section; is variable length -----uchar[]	dev_copyright		// copyright string from NTK project window.  Null terminated.uchar[]	packname			// name of package as seen in "Remove Software"char[]	part_symbol			// 'form' or 'Monaco' or freeform text - seemingly not used.char[]	NTK_copyright		// 'Newtonª Toolkit Package © 1992-1994, Apple Computer, Inc.'----- Part Frames -----First I'll tell you the general structure of what you see, then I'll go into the specificsand describe everything byte-by-byte.Parts are a flattened frame. This is defined by three different types of "chunks" - onefor arrays (type 0x41), one for frames (0x43), and one for data (0x40). Each chunk startswith a long word, the upper 3 bytes of which are the size of the chunk, and the lower byteis the type (0x40, 0x41, 0x43).  I'll explain them later.Chunks are padded to be a multiple of 8 bytes long, but that padding is not included in thesize as recorded in those first three bytes.  The size is the way to tell how many elementsare in the array or frame (divide by 4), but strings are null terminated as well.Inside of all three chunk types, you will have things that I call "vpum"s, as they can bevalues, pointers, unicode or something unusual, or magic pointers.  You tell them apart bylooking at the low two bits - if they are 00, it is a value; 01 is a pointer, 10 is aunicode character or something unusual, and 11 is a magic pointer.	Low 2 bits   Description	----------   -----------------------------------------------------------------------	00 (zero)  - value (immediate data).  Divide this by 4 to get the value.				 example: vpum 0x00000100 is 0x0040 = decimal 64.	01 (one)   - pointer.  Mask off that bit and use it as an offset within the package.				 example: vpum 0x00000105 means offset 0x0104 in the package.	10 (two)   - unicode character or unusual object.  NIL is 0x0002 and TRUE is 0x001a;				 if (thevpum & 0xf)==6 then divide by 0x10 to get the unicode character.	11 (three) - magic pointer.  Mask off the low two bits, divide by 4, and you get				 a number as seen in the NTK Defs file 				 example: vpum 0x0000029a is @166 which is the protoCloseboxFollowing are the descriptions of the three chunk types.  In the descriptions, byteoffsets start after the 40 or 41 or 43.40:  binary data - that is, an immediate that isn't an integer.	 First four bytes are always zero.	 Second four bytes are a vpum indicating this object's data type.  This is a pointer	 within the package, or else is 0x00055552, indicating that this chunk contains the	 ascii text of a symbol (i.e. is a symbol definition).	 Following is the data; whatever is appropriate for the data type.	 	 Symbols, with pointer 0x00055552, have four bytes of what I call SymbolHash.  Frames 	 get re-sorted automatically by the Newton after they have 20 elements, and they're 	 sorted based upon this hash value.	 The formula used to generate the SymbolHash is: (Sum of toupper((c))*0x9e3779b9.  I	 have not rigorously checked this, but it works so far.  Following the SymbolHash is 	 the ASCII of the symbol itself.	 	 Unicode strings are type 'String, and this symbol is defined in the package itself.	 Their data starts immediately after the pointer to their symbol.	 	 Other data types I have found are: bits, code, instructions, mask and real.  I	 have not had the need or desire to decipher their formats; should be fairly obvious.	 	 An example chunk:	 00002440		24 hex bytes long, type 40 = data.	 00000000		These are always zero (unknown purpose)	 00000285		vpum to data type - symbol chunk is at offset 0x0284	 00420065		Now comes the data itself.  This happens to be unicode,	 0079006F		but it could theoretically be anything at all.	 006E0064...	 	 Second example:	 00001440 		14 hex bytes long, type 40 = data.	 00000000 		These are always zero	 00055552 		vpum to data type - this special value means "Symbol"	 0EC1FB99 		SymbolHash	 61707000 		Ascii for 'app' plus a null	 BABABABA		Garbage inserted to pad to 8 bytes.41:  an array.  Each element is a vpum (4 bytes).	 The first four bytes are always zero.	 If this is a "normal" array, the next four bytes are a pointer to the data type (this	 might well point to the symbol "Array", or else to "StepChildren" etc).	 Otherwise, if this is an array holding slot names for a frame, things are different.	 These four bytes might be 0, 2, or something else.	 If they are 0:  the four bytes after it point to another array which holds the first	                 few slot names.  Those slot names come first, then come the ones in	                 this array.  This might be recursive, but I haven't seen that (yet).	                 NTK 1.01 doesn't produce this sort of thing, as far as I have seen, 	                 so you might not have to deal with it.  Perhaps this was a relic of 	                 beta software... however, the Newton does understand it.  Ask me if 	                 you need more details and I'll send you code.	 If they are 2:  the data starts right away after the 2.	 Otherwise:      This is a bit mask.  The following vpum is the value 2 (nil), and the	                 "real" data starts after it.  The bit mask settings are:	                    Bit 0: unused?	                    Bit 1: (discussed above)	                    Bit 2: Set if this frame has more than 20 slots (i.e. is sorted	                           by the SymbolHash	                    Bit 3: Unknown meaning	                    Bit 4: Set if this frame has a _proto slot	 The remaining items are vpum's; they are the elements in the array.	 	 Example:  NewtonScript array  [6, nil, @180]	 00001841		18 hex bytes long, type 41 = array.	 00000000		These are always zero	 00000709		vpum to symbol - like "StepChildren", or "Array" for unnamed arrays	 00000018		vpum 0x18 is value 6	 00000002		vpum 0x2 is nil	 000002D3		vpum 0x2d3 is magic ptr @180	 	 An example of the other type of array (holding slot names) is below.43:  A frame.	 The first four bytes are always zero.	 Second long is a vpum pointing to an array with the slot names; these are in 	 the same order as the slot values in this chunk (i.e. parallel arrays).	 Remaining bytes are the vpum's which are the values of the slots.	 	 Example:  NewtonScript frame {s0:3, s1: [222,333], s2:true, s3:@212}	 00001C43		Length 0x1c; type 43=frame	 00000000		This is always zero	 00000691		vpum to array holding slot names (see just below)	 0000000C		vpum 0xc is 3	 00000711		vpum 0x711 points to another chunk which holds that array	 0000001A		vpum 0x1a is TRUE	 00000353		vpum 0x353 is @212	 ADBADBAD		garbage to pad chunk to a multiple of 8 bytes long	 	 And now for the array (at 0x0690; see above) with the frame's slot names:	 00002041		Length 0x20; type 41=array	 00000000		This is always zero	 00000008		0x8 - unknown bit setting  (see above in array description)	 00000002		NIL - means values in the array are starting now	 000006B1		vpum to "s0" symbol	 000006C9		vpum to "s1" symbol	 000006E1		vpum to "s2" symbol	 000006F9		vpum to "s3" symbolThere you have it, the package file format.  There are a few things here and there which I have not yet figured out, but that's mostly because they were either always set a certain way, or I didn't have a need to spend the time investigating.  If you have someinsights or discoveries of your own, please let me know!----- Hints and tips -----What I do in Paperback, which works wonderfully well, is build my Newton applicationwith the NTK as normal.  The data for it is hard-coded into slots in the package.  Then Iwrote a Mac application which has the package in its resource fork.  The mac applicationthen modifies the package as appropriate, by changing the values in the slots and/or addingslots and/or removing slots.  Packages are complex enough that it is usually not trivial tocreate them from scratch; it is fairly easy to update pointers and lengths to achieve theend result.I'll be maintaining this document as things come to my attention; please let me know if youeither discover something or need something clarified.  I'll send updates out to folks asappropriate.  I'm sure my technical writing style isn't perfect; hey, I'm a programmer!Good luck; let me know how things go.-David Fedor