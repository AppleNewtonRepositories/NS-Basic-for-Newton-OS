Newton Serial IR EndpointIncluded in the latest platforms file release (1.1d2 and later) are two functions which enable developers to open the IR port as if it were a half-duplex async serial port.  This may help alleviate the need for the SharpIR or NewtIR protocol specifications.  However, it is up to the developer to implement the packetizing and error correction necessary for reliable serial IR communication.  Their use is as follows:1.	Turn on the SCC & IRDCU:     call kEnableIRModuleFunc with (true); 2.	Instantiate the endpoint with an option slot for SCC port B:     ep := {        _proto:         myEndpointTemplate,        _parent:        self,   // whatever you want to inherit from        configOptions:  [                {   label:  "aser",                    type:   'service,                    opCode: opSetRequired, },                 {   label:  "scc ",                    type:   'option,                    opCode: opSetRequired,                    data:   call kGetSCCSideBFunc with (), }, ],        };    local err := ep:Instantiate(ep, nil); 3.	Set up your exception handler to deal with -18003 errors.  You'll get a lot of them because of parity and frame errors.     if exception.data = -18003 then... 4.	Do your I/O (remember you can't SetInputSpec and Output simultaneously):     if passive then        ep:SetInputSpec(ep.myInputSpec);    ...    ep:SetInputSpec(nil);   // wait 5ms before outputting (not a problem    ep:Output(data, nil);   // with the current speed of NewtonScript) 5.	Turn off the SCC after the endpoint Dispose in your delayed action:     ep:Disconnect();    ep:Dispose();    call kEnableIRModuleFunc with (nil);The code which packetizes and error corrects should transmit 5 or so 0xFF characters before each packet, to give the receiver a chance to synchronize with the sender.  One-bits are "clock-only" bits, whereas zero-bits are "double-clock" bits (they have anextra phase transition).  When the receiver is trying to phase-lock to thesender's clock, all it really wants is the clock signal.Sample code to follow.EnableIRModuleEnableIRModule(enable)This function enables or disables the infrared module, independent of the serial chip. This call should be made before attempting to use the infrared port as a serial port only (see the GetSCCSideB function). It is called automatically when using the Newton infrared communication driver.enable	Set to true to enable the infrared module. Set to nil to disable the infrared module.This function returns nil.The infrared module consumes a small amount of power when enabled; make sure you disable it when you are finished using it.GetSCCSideBGetSCCSideB()This function returns a special endpoint option which allows the serial driver to be opened on SCC channel B (the side connected to the infrared module).This endpoint will be a plain half-duplex serial endpoint, running over the infrared module instead of the DIN-8 connector.Here is an example of how this function is used:foo := { _proto: protoEndpoint,configOptions: [ 	{label: "aser", 	 type: 'service, 	 opCode: opSetRequired 	},	{label: "scc ", 	 type: 'option, 	 opCode: opSetRequired,	 data: call kGetSCCSideBFunc with ()	} ] };