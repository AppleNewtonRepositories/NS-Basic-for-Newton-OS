constant debug:=TRUE;constant kAppSymbol := '|IRExIm|;constant kPackageName := "IRExIm";constant kAppObject := '["line","lines"];constant kSoupName := "SCRATCH.BAS:NSBASIC";constant kSoupIndexes := '[{structure: slot, path: recNo, type: int}];// this turns on tracing of transactions received: slows things downconstant kTrace:=TRUE;// ---- End Project Data ----// ---- File IRExImBase ----IRExImBaseView :=   {viewBounds: {left: -2, top: 213, right: 235, bottom: 308},    epInit:      func()      begin      	local anErr;      	call kEnableIRModuleFunc with (true);         if kTrace then :newStatus("Instantiating IR endpoint...");      	IRCommEndpt := {              _proto:         protoEndpoint,              _parent:        self,   // whatever you want to inherit from              configOptions:  [                      {   label:  "aser",                          type:   'service,                          opCode: opSetRequired, },                             {   label:  "scc ",                          type:   'option,                          opCode: opSetRequired,                          data:   call kGetSCCSideBFunc with (), }, ],              };               anErr := IRCommEndpt:Instantiate(IRCommEndpt, nil);      	if anErr then :newStatus("Error: " & anErr);          if kTrace then :newStatus("Opening connection...");         anErr:=IRcommEndpt:Connect(nil,nil);               if anErr then begin            getRoot():Notify(kNotifyAlert, "NS BASIC", "Couldn't connect");            return;         end;         if kTrace then :newStatus("Ready to connect...");      	if debug then print(IRCommEndPt);      end,    title: "IR ExIm",    newStatus:      func(msg)      begin         getroot().(kAppSymbol).statusBox:newMsg(msg);         RefreshViews();      end,    gCurrSoupName: kSoupName,    exportScript:      func()      begin        local myCursor;          		        :epInit();        :newStatus("Sending text file...");        local mySoup:=getUnionSoup(gCurrSoupName);        myCursor:=query(mySoup,{type:'index, indexPath: 'lineNo});        local myEntry:=myCursor:entry();       :exportLine(gCurrSoupName);             :newStatus("Sending detail records...");         while myEntry<>NIL do begin          :exportLine(myEntry.LineNo && myEntry.text);          myEntry:=myCursor:next();          if hasSlot(myEntry,'text)=nil then myEntry:=nil;        end;              :newStatus("Send complete. Cleaning up.");      	:epDisconnect();      end,    exportLine:      func(text)      begin        if debug then print(text);        for i:=0 to strLen(text)-1 do begin      		IRcommEndpt:output(subStr(text,i,1),1);      		if i mod 5=0 then IRcommEndPt:flushOutput();      		end;              IRcommEndpt:output(unicodeCR,1);        IRcommEndpt:output(unicodeLF,1);        IRcommEndpt:flushOutput();      end,    importScript:      func()      begin         :newStatus("Start sending file from the other end");                endImport:open();         :epInit();         :newStatus("Setting input spec...");      	IRcommEndPt:SetInputSpec(waitForEntries);         :newStatus("Waiting for entries...");       end,    importLine:      // importLine -- Add a new entry into the soup.              func(s)      begin      	if kTrace then :newStatus(s);         if debug then print(s);      end,    viewQuitScript:      func()      begin      if IRcommEndPt then begin        :newStatus("epDisconnect");        IRcommEndPt:Release();        :newStatus("Released");        IRcommEndPt:flushOutput();        IRcommEndpt:flushInput();        IRcommEndpt:setInputSpec(NIL);        IRcommEndpt:abort();        :newStatus("go do delayed");        AddDelayedAction(          func() begin            IRcommEndpt:disconnect();            IRcommEndpt:Dispose();                  end,[],1000);        :newStatus("Ok to Import or Export");        end;      inherited:?viewQuitScript()      end,    IRcommEndPt: nil,    epDisconnect:      func()      begin      	IRCommEndPt:Release();      	IRCommEndPt:disconnect();      	IRCommEndPt:dispose();      	call kenableIRModuleFunc with (nil);      	IRCommEndPt:=nil;      end,    waitForEntries:      {            InputForm: 'string,            endCharacter: UnicodeCR,            InputScript: func(endpoint, s)            begin      			local baseView:=endpoint._parent._parent._proto;               baseView:newStatus("block received");               baseView:importLine(s);               endPoint:SetInputSpec(baseView.waitForEntries);             end,            discardAfter: 1000,         },    _proto: protoApp,    debug: "IRExImBaseView"   };ImportBtn := /* child of IRExImBaseView */   {text: "Import",    buttonClickScript:      func()      begin         :importScript()      end,    viewBounds: {left: 17, top: 72, right: 78, bottom: 91},    _proto: protoTextButton,    debug: "ImportBtn"   };// View ImportBtn is declared to IRExImBaseViewExportBtn := /* child of IRExImBaseView */   {text: "Export",    buttonClickScript:      func()      	begin         :exportScript()      	end,    viewBounds: {left: 82, top: 72, right: 143, bottom: 91},    _proto: protoTextButton,    debug: "ExportBtn"   };// View ExportBtn is declared to IRExImBaseViewstatusBox := /* child of IRExImBaseView */   {text: "",    viewBounds: {left: 15, top: 22, right: 224, bottom: 71},    newmsg:      func(s)      begin            	local theState:="";            	//try theState:=IRcommEndPt:State()      	//onexception |evt.ex.fr.type| do nil;            	if classOf(theState)='int       		then theState:=stateLabels[theState]      		else theState:="undefined";            	if theState=nil then theState:="no link";      	setValue(self, 'text, s);      	if debug then print(s);      end,    viewJustify: 0,    stateLabels:      [ "Uninitialized",                              "Unbound",                              "Idle",                              "Out Conn Pending",                              "In Conn Pending",                              "Data Transfer",                              "Out Release Pending",                              "In Release Pending",                              "In Flux"],    _proto: protoStaticText,    debug: "statusBox"   };// View statusBox is declared to IRExImBaseViewendImport := /* child of IRExImBaseView */   {text: "End Import",    buttonClickScript:      func()      begin      	:newStatus("End Import");        AddDelayedAction(func() begin getroot().IRexim:close(); end, [], 0);      end,    viewBounds: {left: 146, top: 72, right: 221, bottom: 92},    viewFlags: 514,    _proto: protoTextButton,    debug: "endImport"   };// View endImport is declared to IRExImBaseView// ---- Beginning of section for non used Layout files ----// End of output