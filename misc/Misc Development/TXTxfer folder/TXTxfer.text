constant debug:=TRUE;constant kAppSymbol := '|TXTxfer:NSBASIC|;constant kPackageName := "TXTxfer:NSBASIC";constant kAppObject := '["line","lines"];constant kSoupName := kPackageName;constant kSoupIndexes := '[{structure: slot, path: recNo, type: int}];// this turns on tracing of transactions received: slows things downconstant kTrace:=nil;// ---- End Project Data ----// ---- File TXTxferBase ----SlurpBaseView :=   {newEntry: nil,    viewSetupDoneScript:      func()      begin         :newStatus("Initiate the program at the other end and click Receive... or Send...");               self.commEndPt := { _proto:   protoSerialProtocol,                             _parent:  self,                             SlurpBaseView:  self};            end,    epDisconnect:      func()      begin      //   RemoveSlot(commEndPt, 'slurpBaseView);               commEndPt:Abort();               commEndPt:Release();      end,    viewQuitScript:      func()      begin      //in your viewQuitScript, call      //   :UnRegisterCardSoup(kSoupName);               if StrEqual(receiveBtn.text, "Disconnect") then begin            RemoveSlot(commEndPt, 'slurpBaseView);            :epDisconnect();         end;               inherited:?viewQuitScript();      end,    RegisterCardSoup:      func(soupName,soupIndexes,appSymbol,appObject)        //returns a union-soup for your app to use        begin          //first check for system provided function          if functions.RegisterCardSoup then            return RegisterCardSoup(soupName,soupIndexes,appSymbol,appObject);                CreateAppSoup(soupName,soupIndexes,EnsureInternal([appSymbol]),EnsureInternal(appObject));                           //ensure your soup will exist on stores which later become available          AddArraySlot(CardSoups,soupName);          AddArraySlot(CardSoups,soupIndexes);                    //ensure your soup exists on all currently available stores          local store;          foreach store in GetStores() do            if NOT store:IsReadOnly() AND NOT store:HasSoup(soupName) then              store:CreateSoup(soupName,soupIndexes);                    GetUnionSoup(soupName);        end,    addNewEntry:      // addNewEntry -- Add a new entry into the soup.              func(s)      begin         // Setup the input buffer.  Our inputScripts give us         // a line at a time.         entryIndex := 0;         entryString := s;         if ktrace then :newStatus("addNewEntry: before currentEntryDisplay");         currentEntryDisplay:newMsg(s);         if ktrace then :newStatus("addNewEntry: after currentEntryDisplay");               newEntry := {recNo: numEntries, text: s};         if ktrace then :newStatus("addNewEntry: after buildEntry");         targetSoup:AddToDefaultStore(newEntry);         if ktrace then :newStatus("addNewEntry: after AddToDefaultStore");               // Flush our changes...         targetSoup:Flush();         if ktrace then :newStatus("addNewEntry: after targetSoup");               SetValue(entriesSlurped, 'text, "" & numEntries);         numEntries := numEntries + 1;               if ktrace then :newStatus("addNewEntry: after addNewEntry");      end,    targetSoup: nil,    newSoupName:      func(s)      begin        :newStatus("Setting new soup name...");        if endsWith(s,".TXT\n")=nil        	 then self.targetSoupName := SubStr(s, 0, StrPos(s, "\n", 0)) & ".TXT"        	 else self.targetSoupName := SubStr(s, 0, StrPos(s, "\n", 0));               foreach store in getstores() do begin            targetSoup:=store:getSoup(targetSoupName);            if targetSoup<>nil then begin               targetSoup:removeAllEntries();               targetSoup:flush()            end         end;               self.targetSoup := GetUnionSoup(targetSoupName);         if self.targetSoup=nil then            self.targetSoup:=:registerCardSoup(self.targetsoupName,kSoupIndexes,kAppSymbol,kAppObject);               SetValue(soupNameDisplay, 'text, targetSoupName);         :newStatus("Waiting for entries...");         numEntries:=1;      end,    viewBounds: {left: 0, top: 0, right: 239, bottom: 307},    _proto: protoApp,    epInit:      func()      begin         local   epErr := nil;               commEndPt := { _proto:   protoSerialProtocol,                        _parent:  self,                        slurpBaseView:  self};               :newStatus("Instantiating endpoint...");         epErr := commEndPt:Instantiate(commEndPt, nil);                Perform(epState, 'showState, ["After Instantiate:"]);               if epErr then         begin            :newStatus("Instantiate Error:" && NumberStr(epErr));            return;         end;         else            :newStatus("Instantiating endpoint...done.");               :newStatus("Ready to connect...");               numEntries := 0;      end,    protoSerialProtocol:      {         _proto: protoEndpoint,         // the basic endpoint               configOptions: [            { label: kCMSAsyncSerial, type: 'service, opCode: opSetRequired },            { label: kCMOSerialIOParms, type: 'option, opCode: opSetNegotiate,               data: { bps: k2400bps, dataBits: k8DataBits, stopBits: k1StopBits, parity: kNoParity } },            { label: kCMOInputFlowControlParms, type: 'option, opCode: opSetNegotiate,               data: { xonChar: unicodeDC1, xoffChar: unicodeDC3, useSoftFlowControl: true, useHardFlowControl: nil } },            ],                  exceptionHandler: func(exception)         begin            Perform(endpoint.slurpBaseView, 'newStatus, ["exceptionHandler called..."]);         end,               waitForSoupName:         {            InputForm: 'string,            endCharacter: UnicodeCR,                   InputScript: func(endpoint, s)            begin               Perform(endpoint.slurpBaseView, 'newSoupName, [s]);               endpoint:SetInputSpec(endpoint.waitForEntries);            end,            discardAfter: 1000,         },               waitForEntries:         {            InputForm: 'string,            endCharacter: UnicodeCR,            InputScript: func(endpoint, s)            begin               //:newStatus("block received");               if BeginsWith(s, "BYE!") then               begin                  Perform(endpoint.slurpBaseView, 'epDisconnect, []);                  SetValue(endpoint.slurpBaseView.receiveBtn, 'text, "Receive...");                  Perform(endpoint.slurpBaseView, 'newStatus, ["TextXfer complete - Tap Receive... to TextXfer another..."]);               end;               else               begin                 Perform(endpoint.slurpBaseView, 'addNewEntry, [s]);                 endpoint:SetInputSpec(endpoint.waitForEntries);               end;            end,            discardAfter: 1000,         }      },    nextInputString:      func()      begin         local sPos, s;               sPos := StrPos(entryString, "\n", entryIndex);               s := SubStr(entryString, entryIndex, sPos - entryIndex);         entryIndex := sPos + 1;         s;      end,    entryString: "Text",    title: "TXTxfer",    commEndPt: nil,    epConnect:      func()      begin         local   epErr := nil;               :newStatus("Connecting...");         epErr := commEndPt:Connect(nil, nil);         Perform(epState, 'showState, ["After Connect:"]);         if epErr then            :newStatus("Error trying to connect:" && NumberStr(epErr));         else begin            :newStatus("Connecting...done.");            :newStatus("Setting input spec...");            commEndPt:SetInputSpec(commEndPt.waitForSoupName);            Perform(epState, 'showState, ["After SetInputSpec:"]);            :newStatus("Setting input spec...done.");            :newStatus("Waiting for soup name...");         end;      end,    epDeferredDisconnect:      func()      begin         commEndPt:Abort();               commEndPt:Release();            //   commEndPt:Dispose();      end,    newStatus:      func(msg)      begin         statusBox:newMsg(msg);         RefreshViews();      end,    entryIndex: nil,    numEntries: nil,    targetSoupName: nil,    UnRegisterCardSoup:      func(soupName)        begin          //first check for system provided function          if functions.UnRegisterCardSoup then            return UnRegisterCardSoup(soupName);                local pos := ArrayPos(CardSoups,soupName,0,func(x,y) ClassOf(y)='String AND StrEqual(x,y));          if pos then ArrayRemoveCount(CardSoups,pos,2);        end   };statusBoxLabel := /* child of SlurpBaseView */   {text: "Status:",    viewBounds: {left: 81, top: 37, right: 151, bottom: 53},    viewFont: simpleFont9+tsBold,    viewJustify: 8388610,    _proto: protoStaticText   };// ---- File protoVT42 ----protoVT42 :=   {viewFlags: 67108923,    viewFormat: 337,    newmsg:      func(msg)      begin         if lastChat then            while Ticks() - lastChat < 10 do begin               // Nothing...            end;         else            lastChat := Ticks();               SetValue(self.term, 'text, msg);         SetValue(self.term, 'viewBounds, viewBounds);               RefreshViews();      end,    lastChat: nil,    viewclass: 77   };term := /* child of protoVT42 */   {viewFlags: 67108923,    viewFormat: 257,    viewlinespacing: 13,    viewFont: simpleFont9,    viewSetupFormScript:      func()      begin         inherited:?viewSetupFormScript();         self.viewBounds := Clone(viewBounds);         viewBounds.right := viewBounds.right - viewBounds.left - 2;         viewBounds.left := 2;         viewBounds.bottom := viewBounds.bottom - viewBounds.top - 2;         viewBounds.top := 2;      end,    viewclass: 81   };// View term is declared to protoVT42// ---- Back in File TXTxferBase ----statusBox := /* child of SlurpBaseView */   {viewBounds: {left: 11, top: 53, right: 224, bottom: 82}, _proto: protoVT42};// View statusBox is declared to SlurpBaseViewepStateLabel := /* child of SlurpBaseView */   {text: "Connection State:",    viewBounds: {left: 63, top: 185, right: 170, bottom: 199},    viewClickScript:      func(unit)      begin         epState:showState("Current state:");      end,    viewFlags: 515,    viewFont: simpleFont9+tsBold,    viewJustify: 8388610,    _proto: protoStaticText   };// View epStateLabel is declared to SlurpBaseViewepState := /* child of SlurpBaseView */   {viewBounds: {left: 15, top: 199, right: 216, bottom: 216},    lastShowTime: nil,    showState:      func(msg)      begin         local theState := commEndPt:State();               if theState then begin            if lastShowTime then               while Ticks() - lastShowTime < 10 do begin                  // Nothing...               end;                  :newMsg(msg && stateLabels[theState]);            RefreshViews();                  lastShowTime := Ticks();         end;      end,    stateLabels:      [ "Uninitialized",                              "Unbound",                              "Idle",                              "Out Conn Pending",                              "In Conn Pending",                              "Data Transfer",                              "Out Release Pending",                              "In Release Pending",                              "In Flux"],    _proto: protoVT42   };// View epState is declared to SlurpBaseView_view000 := /* child of SlurpBaseView */   {text: "Soup:",    viewBounds: {left: 10, top: 92, right: 42, bottom: 108},    _proto: protoStaticText   };soupNameDisplay := /* child of SlurpBaseView */   {text: "",    viewBounds: {left: 41, top: 93, right: 98, bottom: 107},    viewFont: simpleFont9,    viewFormat: 337,    _proto: protoStaticText   };// View soupNameDisplay is declared to SlurpBaseView_view001 := /* child of SlurpBaseView */   {text: "Entries Xfered:",    viewBounds: {left: 98, top: 92, right: 188, bottom: 108},    viewJustify: 8388610,    _proto: protoStaticText   };entriesSlurped := /* child of SlurpBaseView */   {text: "0",    viewBounds: {left: 185, top: 93, right: 224, bottom: 107},    viewFont: simpleFont9,    viewFormat: 337,    viewJustify: 8388610,    _proto: protoStaticText   };// View entriesSlurped is declared to SlurpBaseView_view002 := /* child of SlurpBaseView */   {text: "Current Entry:",    viewBounds: {left: 75, top: 109, right: 156, bottom: 124},    _proto: protoStaticText   };currentEntryDisplay := /* child of SlurpBaseView */   {viewBounds: {left: 12, top: 125, right: 222, bottom: 183}, _proto: protoVT42   };// View currentEntryDisplay is declared to SlurpBaseViewreceiveBtn := /* child of SlurpBaseView */   {text: "Receive...",    buttonClickScript:      func()      begin         :newStatus("Start sending the file from the other end");         numEntries := 0;         if StrEqual(self.text, "Receive...") then         begin            Perform(self._parent, 'epInit, []);                  Perform(self._parent, 'epConnect, []);                  SetValue(self, 'text, "Disconnect");         end;         else         begin            Perform(self._parent, 'epDisconnect, []);            SetValue(self, 'text, "Receive...");         end;      //   PlaySound(slurpSound);      end,    viewBounds: {left: 15, top: 20, right: 76, bottom: 39},    _proto: protoTextButton   };// View receiveBtn is declared to SlurpBaseViewsendBtn := /* child of SlurpBaseView */   {text: "Send...",    buttonClickScript:      func()      	begin         pourBase:open()      	end,    viewBounds: {left: 156, top: 22, right: 217, bottom: 41},    _proto: protoTextButton   };// View sendBtn is declared to SlurpBaseViewpourBase := /* child of SlurpBaseView */   {viewBounds: {left: 0, top: 130, right: 203, bottom: 212},    declareSelf: 'base,    gCurrSoupName: nil,    myEndpoint: nil,    sendIt:      func(text,shouldDoCr)      begin        myEndpoint:output(text,NIL);        if shouldDoCr then          begin          myEndpoint:output(unicodeCR,NIL);          myEndpoint:output(unicodeLF,NIL);          end;        myEndpoint:flushOutput();      end,    setSoupNames:      func()      begin          local names:=array(0,NIL);          local namesOnThisStore;          for count:=0 to length(getStores())-1 do begin            namesOnThisStore:=getStores()[count]:getSoupNames();            for count2:=0 to length(namesOnThisStore)-1 do begin              if findStringInArray(names,namesOnThisStore[count2])=nil                and (endsWith(namesOnThisStore[count2],".TXT") or                	   endsWith(namesOnThisSTore[count2],".BAS:NSBASIC")) then                addArraySlot(names,namesOnThisStore[count2]);              end;            end;          soupNames.listItems:=names;          soupNames:setUpList();          soupNames.selection:=0;                soupNames:syncChildren();      end,    viewClickScript:      func(unit)      begin        if self=base then          self:drag(unit,NIL);      end,    viewFlags: 580,    viewQuitScript:      func()      begin        // I don't know how we could get here with an endpoint that exists        // but there doesn't seem to be any harm in having this stuff here.        gCurrSoupName:=NIL; // May as well get the RAM back.                myEndpoint:flushInput();        myEndpoint:setInputSpec(NIL);        myEndpoint:abort();                    AddDelayedAction(          func() begin            myEndpoint:Disconnect();            myEndpoint:Dispose();            end,[],1000);                     end,    viewScrollDownScript:      func()      begin        :newstatus("pourBasic:viewScrollDownScript");        soupNames:viewScrollDownScript();      end,    viewScrollUpScript:      func()      begin        soupNames:viewScrollUpScript();      end,    viewSetupDoneScript:      func()      begin        :setSoupNames();        :newStatus("Select name of file to send:                              ");        if length(soupNames.listItems)>0           then gCurrSoupName:=soupNames.listItems[0];            end,    _proto: protoFloatNGo   };// View pourBase is declared to SlurpBaseViewsoupNames := /* child of pourBase */   {viewBounds: {left: 1, top: 1, right: 205, bottom: 61},    viewSetupFormScript:      func()      begin        self.listItems:=[];      end,    viewFont: ROM_fontSystem9,    viewLines: 6,    buttonClickScript:      func(textIndex)      begin        gCurrSoupName:=self.listItems[textIndex];      end,    viewScrollUpScript:            func()            begin               if debug then print ("overView.viewScrollup" & soupNames.viewOriginY);               If viewOriginY>0 then               soupNames:SetOrigin(viewOriginX,viewOriginY-26);            end,    viewScrollDownScript:            func()            begin               if debug then print ("soupNames.viewScrolldown" & soupNames.viewOriginY);               soupNames:SetOrigin(viewOriginX,viewOriginY+26);            end,    viewOriginX: 0,    viewOriginY: 0,    _proto: protoTextList   };// View soupNames is declared to SlurpBaseViewprintSoup := /* child of pourBase */   {text: "Send",    buttonClickScript:      func()      begin        local anErr,s,myCursor;        // do a connect         :newStatus("Opening connection for sending...");         myEndpoint := {_proto: protoSerialProtocol, _parent: self};         anErr:=myEndpoint:Instantiate(myEndpoint,nil);         anErr:=myEndpoint:Connect(nil,nil);               if anErr then         begin            getRoot():Notify(kNotifyAlert, "TXTxfer", "Check your cables and terminal emulator, couldn't connect");            return;         end;                :newStatus("Sending text file...");        local mySoup:=getUnionSoup(gCurrSoupName);        setValue(soupNameDisplay, 'text, gCurrSoupName);        if strPos(gCurrSoupName,".BAS",0)         		then myCursor:=query(mySoup,{type:'index, indexPath: 'lineNo});        if strPos(gCurrSoupName,".TXT",0)         		then myCursor:=query(mySoup,{type:'index, indexPath: 'recNo});        local myEntry:=myCursor:entry();       :sendit(gCurrSoupName, TRUE);             :newStatus("Sending detail records...");         while myEntry<>NIL do begin        	 if hasSlot(myEntry, 'text) then begin        	 	if hasSlot(myEntry, 'LineNo) then begin        	 		s:=myEntry.LineNo && myEntry.text;         		:sendit(s,TRUE);        	 		end        	 	else begin        	 		s:=myEntry.text;        	 		if endsWith(s,"\n") then s:=substr(s,0,strLen(s)-1);          		:sendit(s,TRUE);          		end;          	if hasSlot(myEntry, 'recno) then setValue(entriesSlurped, 'text, "" & myEntry.recno);          	end;          myEntry:=myCursor:next();        end;              :sendIt("BYE!",TRUE);        :newStatus("Send complete. Cleaning up.");        myEndpoint:flushInput();        myEndpoint:setInputSpec(NIL);        myEndpoint:abort();              AddDelayedAction(          func() begin            myEndpoint:Disconnect();            myEndpoint:Dispose();            end,[],1000);            end,    viewBounds: {left: 6, top: 70, right: 65, bottom: 81},    protoSerialProtocol:      {         _proto: protoEndpoint,         // the basic serial endpoint with the serial port configuration      	      configOptions: [      		   { label: kCMSAsyncSerial, type: 'service, opCode: opSetRequired },      		   { label: kCMOSerialIOParms, type: 'option, opCode: opSetNegotiate,      		              data: { bps: k2400bps, dataBits: k8DataBits, stopBits: k1StopBits, parity: kNoParity } },      		   { label: kCMOInputFlowControlParms, type: 'option, opCode: opSetNegotiate,      		              data: { xonChar: unicodeDC1, xoffChar: unicodeDC3, useSoftFlowControl: true, useHardFlowControl: nil } },      	]      }      ,    _proto: protoTextButton   };_view003 := /* child of SlurpBaseView */   {viewFlags: 513,    icon: GetPictAsBits("NSBASIC", nil),    viewFormat: 1,    viewBounds: {top: 2, left: 2, right: 239, bottom: 135},    viewclass: 76   };// ---- Beginning of non-used User Protos ----// ---- File VT42.t ----VT42 :=   {viewFlags: 51,    viewFormat: 337,    newmsg:      func(msg)      begin         SetValue(self.term, 'text, msg);         SetValue(self.term, 'viewFlags, self.term._proto.viewFlags);      end,    viewclass: 77   };term := /* child of VT42 */   {viewFlags: 1,    viewFormat: 257,    viewlinespacing: 20,    viewFont: simpleFont9+tsBold,    viewBounds: {left: 0, top: 0, right: 0, bottom: 0},    viewJustify: 240,    viewclass: 81   };// View term is declared to VT42// ---- End of non-used User Protos ----// ---- Beginning of section for non used Layout files ----// End of output