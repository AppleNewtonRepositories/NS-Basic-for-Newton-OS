constant debug:=TRUE;constant kAppSymbol := '|ExIm|;constant kPackageName := "ExIm";constant kAppObject := '["line","lines"];constant kSoupName := "SCRATCH.BAS:NSBASIC";constant kSoupIndexes := '[{structure: slot, path: recNo, type: int}];// this turns on tracing of transactions received: slows things downconstant kTrace:=TRUE;// ---- End Project Data ----// ---- File ExImBase ----ExImBaseView :=   {viewBounds: {left: -2, top: 213, right: 235, bottom: 308},    epInit:      func()      begin      	local anErr;               if kTrace then :newStatus("Instantiating endpoint...");         anErr:=commEndpt:Instantiate(commEndpt,nil);                  if kTrace then :newStatus("Opening connection...");         anErr:=commEndpt:Connect(nil,nil);               if anErr then begin            getRoot():Notify(kNotifyAlert, "NS BASIC", "Check your cables and terminal emulator, couldn't connect");            return;         end;         getGlobals().iobusy:=TRUE;         if kTrace then :newStatus("Ready to connect...");      end,    protoSerialProtocol:      {         _proto: protoEndpoint,         // the basic endpoint               configOptions: [            { label: kCMSAsyncSerial, type: 'service, opCode: opSetRequired },            { label: kCMOSerialIOParms, type: 'option, opCode: opSetNegotiate,               data: { bps: k9600bps, dataBits: k8DataBits, stopBits: k1StopBits, parity: kNoParity } },            { label: kCMOInputFlowControlParms, type: 'option, opCode: opSetNegotiate,               data: { xonChar: unicodeDC1, xoffChar: unicodeDC3, useSoftFlowControl: true, useHardFlowControl: nil } },            ],                  exceptionHandler: func(exception)         begin         	if exception.data<>-16013 then begin             	  :getroot():Notify(3, ensureInternal("NS BASIC"),             		ensureInternal("Communications Error " & sPrintObject(exception.data)));            		perform(endpoint,'epDisconnect,[]);            		end         end,               waitForEntries:         {            InputForm: 'string,            endCharacter: UnicodeCR,            InputScript: func(endpoint, s)            begin               endPoint.exImBaseView:newStatus("block received");               endPoint.exImBaseView:importLine(s);               endPoint:SetInputSpec(endPoint.waitForEntries);             end,            discardAfter: 1000,         }      },    title: "ExIm",    newStatus:      func(msg)      begin         statusBox:newMsg(msg);         RefreshViews();      end,    gCurrSoupName: kSoupName,    exportScript:      func()      begin        local myCursor;                if getGlobals().iobusy then begin        		:newStatus("The serial port is already in use.");        		return nil;        		end;        		        :epInit();        :newStatus("Sending text file...");        local mySoup:=getUnionSoup(gCurrSoupName);        myCursor:=query(mySoup,{type:'index, indexPath: 'lineNo});        local myEntry:=myCursor:entry();       :exportLine(gCurrSoupName);             :newStatus("Sending detail records...");         while myEntry<>NIL do begin          :exportLine(myEntry.LineNo && myEntry.text);          //:exportLine(myEntry);          myEntry:=myCursor:next();          if hasSlot(myEntry,'text)=nil then myEntry:=nil;        end;              :newStatus("Send complete. Cleaning up.");        AddDelayedAction(func() begin getroot().exim:close(); end, [], 0);      end,    exportLine:      func(text)      begin        if kTrace then :newStatus(text);        commEndpt:output(text & unicodeCR & unicodeLF,NIL);        //commEndpt:outputframe(text,NIL);        commEndpt:flushOutput();      end,    importScript:      func()      begin         :newStatus("Start sending file from the other end");         if getGlobals().iobusy then begin        		:newStatus("The serial port is already in use.");        		return nil;         end;               endImport:open();         :epInit();         :newStatus("Setting input spec...");      	commEndPt:SetInputSpec(commEndPt.waitForEntries);         :newStatus("Waiting for entries...");       end,    importLine:      // importLine -- Add a new entry into the soup.              func(s)      begin         if ktrace then :newStatus("importLine");         :newStatus(s);      end,    commEndPt: nil,    viewSetupDoneScript:      func()      begin         self.commEndPt := { _proto:   protoSerialProtocol,                             _parent:  self,                             exImBaseView:  self};      end,    viewQuitScript:      func()      begin      if commEndPt then begin        :newStatus("epDisconnect");        commEndPt:Release();        :newStatus("Released");        commEndPt:flushOutput();        commEndpt:flushInput();        commEndpt:setInputSpec(NIL);        commEndpt:abort();        :newStatus("go do delayed");        AddDelayedAction(          func() begin            commEndpt:disconnect();            commEndpt:Dispose();                  end,[],1000);        :newStatus("Ok to Import or Export");        getglobals().ioBusy:=NIL;        end;      inherited:?viewQuitScript()      end,    _proto: protoApp,    debug: "ExImBaseView"   };ImportBtn := /* child of ExImBaseView */   {text: "Import",    buttonClickScript:      func()      begin         :importScript()      end,    viewBounds: {left: 17, top: 72, right: 78, bottom: 91},    _proto: protoTextButton,    debug: "ImportBtn"   };// View ImportBtn is declared to ExImBaseViewExportBtn := /* child of ExImBaseView */   {text: "Export",    buttonClickScript:      func()      	begin         :exportScript()      	end,    viewBounds: {left: 82, top: 72, right: 143, bottom: 91},    _proto: protoTextButton,    debug: "ExportBtn"   };// View ExportBtn is declared to ExImBaseViewstatusBox := /* child of ExImBaseView */   {text: "",    viewBounds: {left: 15, top: 22, right: 224, bottom: 71},    newmsg:      func(s)      begin      	local theState:=nil;      	if getglobals().iobusy then begin      							theState:=commEndPt:State();      							if theState then theState:=stateLabels[theState]      							end;      	if theState=nil then theState:="no link";      	setValue(self, 'text, s & chr(13) & theState);      end,    viewJustify: 0,    stateLabels:      [ "Uninitialized",                              "Unbound",                              "Idle",                              "Out Conn Pending",                              "In Conn Pending",                              "Data Transfer",                              "Out Release Pending",                              "In Release Pending",                              "In Flux"],    _proto: protoStaticText,    debug: "statusBox"   };// View statusBox is declared to ExImBaseViewendImport := /* child of ExImBaseView */   {text: "End Import",    buttonClickScript:      func()      begin      	:newStatus("End Import");        AddDelayedAction(func() begin getroot().exim:close(); end, [], 0);      end,    viewBounds: {left: 146, top: 72, right: 221, bottom: 92},    viewFlags: 514,    _proto: protoTextButton,    debug: "endImport"   };// View endImport is declared to ExImBaseView// ---- Beginning of section for non used Layout files ----// End of output