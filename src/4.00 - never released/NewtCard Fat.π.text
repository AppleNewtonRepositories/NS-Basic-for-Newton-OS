// Text of project NewtCard Fat.¹ written on 11/22/97 at 7:03 AM
// Beginning of text file Project Data
// This next field can be "None", a date in format MMM DD,YYYY or "DEMO"// Remember to change first field in Settings to "BASIC Demo"constant kTimeOut:="None";//constant kTimeOut:="Nov 1,1997";constant kUpdate:=nil;constant debug:=TRUE;constant kChunkTrace:=nil;constant kShowCompile:=nil; // display code to be compiledif kAppSymbol<>'|NewtCard:NSB| and kAppSymbol<>'|NewtCardShell:NSB| then begin	// NS BASIC only definitions	// The format of this next field must start "Version X.Y" & anything els
£Gø£GÀe ok	defconst('kkVersion,"Version 4.00 Alpha 0");	defconst('kkSignature,"NSB");	defconst('kkShellSymbol,'|BASIC:NSB|);	defconst('kRunTime, if kAppSymbol='|BASIC:NSB| then NIL else TRUE);	defconst('kFat, if kAppSymbol='|Fat:NSB| then TRUE else NIL);  endelse begin // NewtCard Definitions	defconst('kkVersion, "Version 1.00 beta 9b");	defconst('kkSignature,"NewtCard");	defconst('kkShellSymbol,'|NewtCard:NSB|);	defconst('kRunTime,NIL);	defconst('kFat,NIL);		end;	print("AppSymbol:" & sPrint
£Gø£GÀObject(kAppSymbol));defconst('kShortPath,"getroot().|" & kPackageName & "|.");defconst('kShortPathA,"getroot().|" & kPackageName & "|");defconst('kStepChildren,"getroot().|" & kPackageName & "|.stepchildren");defconst('kPath,"getroot().|" & kPackageName & "|.screenview.");defconst('kMakePkgSym, '|makePkg:NSB|);defconst('kUpdater, '|updater:NSB|);defconst('kToolsSymbol, '|tools:NSB|);knownGlobalFunctions.getPkgRef:=2;knownGlobalFunctions.ConvertToUniJ:=3;knownGlobalFunctions.StrHexDump:=2;
£Gø£GÀknownGlobalFunctions.charPos:=3;knownGlobalFunctions.NSDEnableBreakpoints:=1;knownGlobalFunctions.makeFontMenu:=4;knownGlobalFunctions.setClipboard:=1;knownGlobalFunctions.getClipboard:=0;partData:={}; // used for runtimedefconst('kBuildTime, sPrintObject(time()));print(datentime(time()));defconst('kU, 'U);constant kMaxChunkSize:=400; // max number of bytes in each SAVE chunk (approx)constant kAppObject:='["statement","statements"];constant kMainSub:=0;defconst('kSysEntry, {tag: "",				
£Gø£GÀ			userLevel: 1,   					  inputPrompt: "? ",   					  io: "SCREEN",   					  printDepth: 1,   					  listWidgets: NIL,   					  programName: "",   					  extr: {connect: "Connected." & unicodeCR & "* "},   					  mdem: {connect: "Connected." & unicodeCR & "* ",   					  	phone: NIL},   					  mmnp: {connect: "Connected." & unicodeCR & "* ",   					  	HWflow: nil, SWFLOW: nil, phone: NIL},						  infr: {connect: "Connected. * "},							slt1: {connect: "Connected." & unicodeCR & "* "},   	
£Gø£GÀ				  slt2: {connect: "Connected." & unicodeCR & "* "},	 					  serialNumber: 0,	 					  showKeyboard: NIL,	    					  store: 1,   					  useScratch: TRUE,   					  enableBreak: NIL,						  makeFatPackage: NIL, 						  lastUser: "",						     					  });defconst('kEmptyRF, {	 		 _ch: NIL,			 _codePos: NIL,			 _codeRecPos: NIL,			 _context: 'main,			 _data: NIL,			 _dataPos: NIL,			 _dataRecPos: NIL,			 _doStack: [],			 _doStackTop: NIL,			 _errorCounter: 0,			 _forNextStack: [],		
£Gø£GÀ	 _forNextTop: NIL,			 _gosubStack: [],			 _hideUserViewsRunning: NIL,			 _inputCompiled: NIL,			 _inputError: NIL,			 _inputFlag: NIL,			 _inputLineHold: "",			 _inputPtr: NIL,			 _inputStack: [],			 	// _inputStack holds results from the input stream until an INPUT statement can get it.				// It is used in the exInputArg function			 _lastLineNo: 0, // used in execution			 _lastStmtNo: 0, // used in editing			 _loading: NIL,  // set during program load for SUB statements			 _openFiles:
£Gø£GÀ [],			 _printLine: "",			 _printPending: NIL,			 _runFlag: NIL,			 /* This says how program execution should go next.					It is set to NIL if there is an INPUT statement or the program is stopped.					It is set to 0 to go to the next line number in the program					Setting it to a line number causes a GOTO that line number */				 _runState: NIL,			 /* _runState says if the program is running. It stays TRUE, even if in an INPUT statement */			 			 _thenLevel: 0,			 _trace: nil,			 _userVie
£Gø£GÀws: [],		 	 _waitOutstanding: nil,		 	 FSTAT: nil;				});defconst('kEmptySubRF, {	 		 _ch: NIL,			 _codePos: NIL,			 _codeRecPos: NIL,			 _context: 'TBA,			 _data: NIL,			 _dataPos: NIL,			 _dataRecPos: NIL,			 _doStack: [],			 _doStackTop: NIL,			 _errorCounter: 0,			 _forNextStack: [],			 _forNextTop: NIL,			 _gosubStack: [],			 _hideUserViewsRunning: NIL,			 _lastLineNo: 0, // used in execution			 _lastStmtNo: 0, // used in editing			 _runFlag: NIL,			 _thenLevel: 0,			 _use
£Gø£GÀrViews: [],				});			 constant kSoupIndexes:='[{structure: slot, path: ID, type: int, rev: 4},												 {structure: slot, path: name, type: string}];defconst('kWorkQuerySpec, {indexPath: 'ID});constant kAlpha:="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$'.";constant kNumeric:="0123456789.";defconst('kAlphaNumeric,kAlpha & kNumeric);constant kOperator:="+-/*()=<>&";constant kCompareOps:="=<>";defconst('kSeparators, kOperator & kCompareOps & " ");constant spaces:="          ";
£Gø£GÀdefconst('quote,sPrintObject(chr(34)));defconst('CR,sPrintObject(chr(13)));defconst('LF,sPrintObject(chr(10)));defconst('BS,sPrintObject(chr(8)));defconst('kCharList,kalpha & "9876543210" & kOperator & " abcdefghijklmnopqrstuvwxyz");defconst('kcharListLen, strLen(kCharList));//defconst('printFormat, protoPrintFormat);constant kExpertBrowse := 0;constant kExpertScript := 1;constant kExpertExpert := 2;defconst('kError1,["Error 1 - Incorrect Data Type" & CR]);defconst('kError2,["Error 2 - S
£Gø£GÀtatement or syntax invalid" & CR]);defconst('kError3,["Error 3 - READ/DATA types inconsistant" & CR]);defconst('kError4,["Error 4 - Invalid Checksum on Runtime" & CR]);defconst('kError5,["Error 5 - Statement Number" & CR]);defconst('kError6,["Error 6 - Internal Error saving line" & CR]);defconst('kError7,["Error 7 - Label already exists" & CR]);defconst('kError8,["Error 8 - Renumber overlap" & CR]);defconst('kError9,["Error 9 - Invalid Label" & CR]);defconst('kError10,["Error 10 - Expected a 
£Gø£GÀvariable" & CR]);defconst('kError11,["Error 11 - Parenthesis" & CR]);defconst('kError12,["Error 12 - Label not found" & CR]);defconst('kError13,["Error 13 - Line Number" & CR]);defconst('kError14,["Error 14 - Out of Memory" & CR]);defconst('kError15,["Error 15 - End of DATA" & CR]);defconst('kError16,["Error 16 - Arithmetic" & CR]);defconst('kError17,["Error 17 - Expected a Number" & CR]);defconst('kError18,["Error 18 - Undefined Variable" & CR]);defconst('kError19,["Error 19 - RETURN - No G
£Gø£GÀOSUB" & CR]);defconst('kError20,["Error 20 - Unknown Func or Sub" & CR]);defconst('kError21,["Error 21 - FOR - No Next" & CR]);defconst('kError22,["Error 22 - NEXT - No FOR" & CR]);defconst('kError23,["Error 23 - No such widget" & CR]);defconst('kError24,["Error 24 - Invalid WindowSpec" & CR]);defconst('kError25,["Error 25 - Unknown Window" & CR]);defconst('kError26,["Error 26 - Must be 1st stmt in sub" & CR]);defconst('kError27,["Error 27 - Sub already exists" & CR]);defconst('kError29,["Er
£Gø£GÀror 29 - Expression" & CR]);defconst('kError30,["Error 30 - Object is read only" & CR]);defconst('kError31,["Error 31 - Subscript or Frame error" & CR]);defconst('kError32,["Error 32 - Program must be SAVEd" & CR]);defconst('kError34,["Error 34 - Not a bitmap" & CR]);defconst('kError35,["Error 35 - MakePkg not installed" & CR]);defconst('kError36,["Error 36 - VisualDesigner not installed" & CR]);defconst('kError37,["Error 37 - PackMan not installed" & CR]);defconst('kError46,["Error 46 - Inpu
£Gø£GÀt Error" & CR]);defconst('kError48,["Error 48 - Incorrect SAVE version" & CR]);defconst('kError59,["Error 59 - Zero step" & CR]);defconst('kError60,["Error 60 - LOOP without DO" & CR]);defconst('kError61,["Error 61 - EXIT not in loop" & CR]);defconst('kError63,["Error 63 - Incorrect # of args" & CR]);defconst('kError87,["Error 87 - Missing ELSE or ENDIF" & CR]);defconst('kError88,["Error 88 - Unexpected ELSE,ENDIF" & CR]);defconst('kError99,["Error 99 - Unexpected Error" & CR]);defconst('kEr
£Gø£GÀrorM1,["I/O Error 1 - Illegal file name" & CR]);defconst('kErrorM2,["I/O Error 2 - Illegal key" & CR]);defconst('kErrorM3,["I/O Error 3 - Opened without keys" & CR]);defconst('kErrorM4,["I/O Error 4 - Incorrect key type" & CR]);defconst('kErrorM5,["I/O Error 5 - File already Exists" & CR]);defconst('kErrorM6,["I/O Error 6 - End of file" & CR]);defconst('kErrorM9,["I/O Error 9 - App not found" & CR]);defconst('kErrorM10,["I/O Error 10 - File not found" & CR]);defconst('kErrorM11,["I/O Error 11
£Gø£GÀ - Not a Newton Book" & CR]);defconst('kErrorM12,["I/O Error 12 - no key on OPEN" & CR]);defconst('kErrorM13,["I/O Error 13 - Channel not open" & CR]);defconst('kErrorM14,["I/O Error 14 - Error creating file" & CR]);defconst('kErrorM20,["I/O Error 20 - Connect failed" & CR]);defconst('kErrorM21,["I/O Error 21 - Buffer overrun" & CR]);defconst('kErrorM22,["I/O Error 22 - Comms timed out" & CR]);defconst('kErrorM23,["I/O Error 23 - Port in use" & CR]);defconst('kErrorM24,["I/O Error 24 - No suc
£Gø£GÀh port" & CR]);defconst('kErrorM25,["I/O Error 25 - Comms output overun" & CR]);defconst('kErrorM26,["I/O Error 26 - Modem not found" & CR]);defconst('kErrorM27,["I/O Error 27 - No dial tone" & CR]);defconst('kErrorM28,["I/O Error 28 - No answer" & CR]);defconst('kErrorM29,["I/O Error 29 - Line busy" & CR]);defconst('kErrorM30,["I/O Error 30 - Modem not responding" & CR]);defconst('kErrorM31,["I/O Error 31 - Modem connect failed" & CR]);defconst('kErrorM32,["I/O Error 32 - Error correct faile
£Gø£GÀd" & CR]);defconst('kErrorM33,["I/O Error 33 - Lost connection" & CR]);defconst('kErrorM34,["I/O Error 34 - Invalid phone number" & CR]);defconst('kErrorM35,["I/O Error 35 - Port not connected" & CR]);defconst('kKeyword,["REM","LET","IF","GOTO","GOSUB","RETURN","FOR","NEXT","ON","READ","DATA","RESTORE","DIM","INPUT","PRINT","DELETE","RANDOMIZE","CHAIN","CLS","END","STOP","BYE","THEN","TO","STEP","AND","OR","NOT","NIL","TRUE","BEEP","ELSE","ERROR","TRACE","OFF","OPEN","GET","PUT","DEL","CREAT
£Gø£GÀE","ENTER","MOD","DIV","HWINPUT","WINDOW","SHOW","HIDE","WPRINT","ESPY","NEWYORK","GENEVA","WAIT","ENVIRON","FUNCTION","DEF","WDRAW", "ERASE","HPPRINT","CLOSE","EDIT","SETICON","MAKEPACKAGE","DO","LOOP","UNTIL","WHILE","EXIT","ELSEIF","ENDIF","CALL","SUB","ENDSUB"]);// These statements require no further interpretationconstant kREM:=1;constant kDATA:=2;// These statements get run through the interpreterconstant kLET:=21;constant kRANDOMIZE:=22;constant kTRACE:=23;constant kWINDOW:=24;c
£Gø£GÀonstant kSHOW:=25;constant kHIDE:=26;constant kWPRINT:=27;constant kFUNCTION:=28;constant kDEF:=29;constant kWDRAW:=30;constant kBEEP:=31;constant kFOR:=32;constant kNEXT:=33;constant kGOTO:=34;constant kGOSUB:=35;constant kRETURN:=36;constant kBYE:=37;constant kCHAIN:=38;constant kCLS:=39;constant kCREATE:=40;constant kOPEN:=41;constant kGET:=42;constant kPUT:=43;constant kDEL:=44;constant kEND:=45;constant kSTOP:=46;constant kPRINT:=47;constant kIF:=48;constant kDIM:=49;con
£Gø£GÀstant kWAIT:=50;constant kHPPRINT:=51;constant kENVIRON:=52;constant kDELETE:=53;constant kENTER:=54;constant kERASE:=55;constant kHWINPUT:=56;constant kINPUT:=57;constant kON:=58;constant kREAD:=59;constant kRESTORE:=60;constant kCLOSE:=61;constant kSETICON:=62;constant kMAKEPACKAGE:=63;constant kIFblock:=64;constant kELSE:=65;constant kDO:=66;constant kEXIT:=67;constant kLOOP:=68;constant kEndIf:=69;constant kWidgetDef:=70;constant kSub:=71;constant kEndSub:=72;constant kCall
£Gø£GÀ:=73;constant kSet:=74;constant kFind:=75;constant kGo:=76;defconst('kStatements,["REM","DATA",			"LET","RANDOMIZE","TRACE","WINDOW","SHOW","HIDE","WPRINT","FUNCTION","DEF","WDRAW","BEEP",			"IF","GOTO","GOSUB","RETURN","FOR","NEXT","ON","READ","RESTORE","DIM","INPUT",			"PRINT","DELETE","CHAIN","CLS","END","STOP","BYE","OPEN","GET","PUT","DEL",			"CREATE","ENTER","HWINPUT","WAIT","ENVIRON","ERASE","HPPRINT","CLOSE","SETICON",			"MAKEPACKAGE","IFBLOCK","ELSE","DO","EXIT","LOOP","ENDIF","W
£Gø£GÀIDGETDEF",			"SUB","ENDSUB","CALL","SET","FIND","GO"]);defconst('kstatementCodes,[kREM,kDATA,			kLET,kRANDOMIZE,kTRACE,kWINDOW,kSHOW,kHIDE,kWPRINT,kFUNCTION,kDEF,kWDRAW,kBEEP,			kIF,kGOTO,kGOSUB,kRETURN,kFOR,kNEXT,kON,kREAD,kRESTORE,kDIM,kINPUT,kPRINT, 			kDELETE,kCHAIN,kCLS,kEND,kSTOP,kBYE,kOPEN,kGET,kPUT,kDEL,kCREATE,kENTER,			kHWINPUT,kWAIT,kENVIRON,kERASE,kHPPRINT,kCLOSE,kSETICON,kMAKEPACKAGE,			kIFblock,kELSE,kDO,kEXIT,kLOOP,kENDIF,kWIDGETDEF,kSUB,kENDSUB,kCALL,kSET,			kFIND,KGO]);d
£Gø£GÀefconst('kConstants,{        name: ["VFFILLWHITE","VFFILLLTGRAY","VFFILLGRAY",                         "VFFILLDKGRAY","VFFILLBLACK",                         "VFFRAMEWHITE", "VFFRAMELTGRAY", "VFFRAMEGRAY",                         "VFFRAMEDKGRAY", "VFFRAMEBLACK","VFFRAMEMATTE",                         "VFNONE","VFWHITE","VFLTGRAY","VFGRAY","VFDKGRAY","VFBLACK",                         "VFPEN","VFSHADOW","VFROUND",                         "VFFILLCUSTOM","VFFRAMECUSTOM",                         
£Gø£GÀ"RGB_GRAY0","RGB_GRAY1","RGB_GRAY2","RGB_GRAY3",                         "RGB_GRAY4","RGB_GRAY5","RGB_GRAY6","RGB_GRAY7",                         "RGB_GRAY8","RGB_GRAY9","RGB_GRAY10","RGB_GRAY11",                         "RGB_GRAY12","RGB_GRAY13","RGB_GRAY14","RGB_GRAY15",                         "VVISIBLE","VAPPLICATION","VCALCULATEBOUNDS", "VCLIPPING","VFLOATING","VREADONLY","VCLICKABLE","VNOFLAGS","VNOTHINGALLOWED","VANYTHINGALLOWED",                         "VSTROKESALLOWED","VGESTURESALL
£Gø£GÀOWED","VSHAPESALLOWED","VSINGLEUNIT",                         "VCHARSALLOWED","VLETTERSALLOWED","VNAMEFIELD",                         "VPUNCTUATIONALLOWED","VCAPSREQUIRED","VNUMBERSALLOWED","VPHONEFIELD",                         "VDATEFIELD","VTIMEFIELD","VNOSPACES"],        value:[VFFILLWHITE,VFFILLLTGRAY,VFFILLGRAY,                         VFFILLDKGRAY, VFFILLBLACK,                         VFFRAMEWHITE, VFFRAMELTGRAY, VFFRAMEGRAY,                         VFFRAMEDKGRAY, VFFRAMEBLACK, VFFRAME
£Gø£GÀMATTE,                         VFNONE,VFWHITE,VFLTGRAY,VFGRAY,VFDKGRAY,VFBLACK,                         256,262144,16777216,                         VFFILLCUSTOM,VFFRAMECUSTOM,                         KRGB_GRAY0,KRGB_GRAY1,KRGB_GRAY2,KRGB_GRAY3,                         KRGB_GRAY4,KRGB_GRAY5,KRGB_GRAY6,KRGB_GRAY7,                         KRGB_GRAY8,KRGB_GRAY9,KRGB_GRAY10,KRGB_GRAY11,                         KRGB_GRAY12,KRGB_GRAY13,KRGB_GRAY14,KRGB_GRAY15,                         VVISIBLE,VAP
£Gø£GÀPLICATION,VCALCULATEBOUNDS, VCLIPPING,VFLOATING,                         VREADONLY,VCLICKABLE,VNOFLAGS,VNOTHINGALLOWED,VANYTHINGALLOWED,                         VSTROKESALLOWED,VGESTURESALLOWED,VSHAPESALLOWED,VSINGLEUNIT,                         VCHARSALLOWED,VLETTERSALLOWED,VNAMEFIELD,                         VPUNCTUATIONALLOWED,VCAPSREQUIRED,VNUMBERSALLOWED,VPHONEFIELD,                         VDATEFIELD,VTIMEFIELD,VNOSPACES]});			 defconst('kCommand,["LIST","SAVE","LOAD","REPLACE","RENUM","
£Gø£GÀRUN","BYE","REVUP",         "STATS","NEW","NEWPROGRAM","DIR","VARS","CON","STRIP","EDIT","TOOLS",         "MODULE"]);defconst('kCommandPickList, ["RUN","CON","LIST","REPLACE",	"NEW","NEWPROGRAM","MODULE [subroutineName]",	"RENUM","MAKEPACKAGE","REVUP","STRIP",	'pickSeparator,	"DIR","STATS","TOOLS","VARS",	'pickSeparator,	"LOAD filename",	"LIST",	"LIST [stmt[,stmt[,filename]]]",	"SAVE filename",	"ENTER filename[.BAS]",	"RENUM [from[,to[,step[,base]]]]",	"RUN lineNo or filename",	"DELE
£Gø£GÀTE filename"]);	defconst('kCommandPickListNewtCard, ["RUN","CON","LIST",	"RENUM",	'pickSeparator,	"DIR","STATS","TOOLS","VARS",	'pickSeparator,	"LIST",	"LIST [stmt[,stmt[,filename]]]",	"ENTER filename[.BAS]",	"RENUM [from[,to[,step[,base]]]]",	"RUN lineNo or filename",	"DELETE filename"]);	defconst('kStatementPickList, 	["next lineNo", 	"next lineNo in Edit Box", 	'pickSeparator,		"CLS",	"REM text",	"IF cond",	"THEN [stmt]",	"ELSE [stmt]",	"END IF",	"GOTO lineNo",	"GOSUB lin
£Gø£GÀeNo",	"FOR var=start TO end STEP",	"NEXT var",	"EXIT [FOR|DO]",	"DO [ |UNTIL|WHILE]",	"LOOP [ |UNTIL|WHILE]",	"ON cond THEN GOTO stmtList",	"READ var[,var...]",	"DATA const[,const]",	"INPUT var[,var...]",	"PRINT exp[, or ; exp...]",		'pickSeparator,	"OPEN ch,file[,key]",	"GET ch,var[,key]",	"PUT ch,var",	"DEL ch,var",		'pickSeparator,	"WIDGETDEF wSpec",	"WINDOW wNum[,wSpec[,wName]",	"SHOW wNum[,wNum...]",	"WPRINT wNum,var",	"HIDE [wNum[,wNum...]]",	"HWINPUT var[,prompt[,list]]
£Gø£GÀ"]);	defconst('kRenumWords,["GOTO ","GOSUB ","RESTORE","GOTO:",".GOTO","GOSUB:",".GOSUB"]);defconst('kBeeps, [ROM_bootsound, ROM_alarmwakeup, ROM_click, ROM_crumple, ROM_drawerclose,                   ROM_draweropen, ROM_flip, ROM_funbeep, ROM_hilitesound, ROM_plinkbeep,                   ROM_simpleBeep, ROM_wakeupbeep, ROM_plunk, ROM_poof]);defconst('kProgramTemplate, [ "0010 REM program template", "0020 appSpec={goto:'endProgram,title:" & quote & "Demo" & quote &"}", "0030 window app,app
£Gø£GÀSpec," & quote & "APP" & quote, "0040 show app", "0050 widgetdef Layout_0", "0060 window wlist,Layout_0", "0070 show wlist", "0100 wait -1 // indefinitely", "9000 endProgram: rem", "9010 hide", "9020 stop"  ]);  // used by draw module  DefConst('delta, 36);DefConst('scrollInfo, {	up:		{x: 0, y: -delta},						down:	{x: 0, y: delta},						left:	{x: -delta, y: 0},						right:	{x: delta, y: 0}					});  // used by newButton protoPickerprint(home);if kkShellSymbol='|newtcard:NSB| then
£Gø£GÀ begin	if kAppSymbol='|newtcard:NSB|		then print(OpenResFile(home & "NewtCard Shell:resource.rsrc"));		else print(OpenResFile(home & "resource.rsrc"));	//DefConst('iconPickerBitmap, getPictAsBits("iconPicker", nil));	DefConst('packItIcon, getPictAsBits("packItIcon", nil));	CloseResFile();	end;
 0, y: -delta},						down:	{x: 0, y: delta},						left:	{x: -delta, y: 0},						right:	{x: delta, y: 0}					});  // used by newButton protoPickerprint(home);if kkShellSymbol='|newtcard:NSB| then
// End of text file Project Data
// Beginning of text file Routing Data
constant kMyMainDataDefSym 	:= '|myDataDef:NewtCard:NSB| ;constant kMyMainViewDefSym 	:= '|myViewDef:NewtCard:NSB| ;constant kMyFrameViewDefSym := '|myFrameViewDef:NewtCard:NSB| ;/* * This is a routing format which handles 'text and 'frame (despite the name, protoFrameFormat * handles both types. If you want to handle just 'frames, override the dataTypes slot with ['frame]. * * This will be registered in the application installScript with RegisterViewDef(...). * * Note that we won't necessarily be
£Gø£GÀ able to view the item in the iobox unless we write a  * NON-ROUTING viewDef for kMyMainDataDefSym so that it can be viewed in the iobox item viewer. */DefConst('kMyFrameRoutingFormat, {		_proto:		protoFrameFormat,	title:		"CustomRoute - picture choice", 	version:	1, 	symbol:		kMyFrameViewDefSym, 	SetupItem:	func(item, targetInfo) begin			inherited:?SetupItem(item, targetInfo);			/*If you have any "preprocessing" to do like set anything in the item or add			 * extra body slots like version
£Gø£GÀ slots, or extra data, you can do it here, but if you are			 * trying to actually prep visual shapes, do that in formatInitScript.					 * 			 * Note that by calling inherited, we get the equivalent of:			 *		item.body := targetInfo.target;			 * ...plus if the target is a soup entry alias, it resolves it...			 *			 * Only modify the item, not the target.			 */			// set the title; note that the string will be editable by the user...			item.title := "CustomRoute item: " & datentime(time());	
£Gø£GÀ		if debug then print("setup Item" & item.title);			item;		end,	textScript: func(fields, target)		clone(target.data);	// our target.data should always be plain text});
ited, we get the equivalent of:			 *		item.body := targetInfo.target;			 * ...plus if the target is a soup entry alias, it resolves it...			 *			 * Only modify the item, not the target.			 */			// set the title; note that the string will be editable by the user...			item.title := "CustomRoute item: " & datentime(time());	
// End of text file Routing Data
// Beginning of file PrintFormat
printForm :=
    {
     printNextPageScript:
       func() begin	if debug then print("printNextPageScript");		if printFormat='app then begin		if not base.newtCard			then nil //no next page			else begin				if base.cardsToPrint=0 then begin // all					if base.card.nextCardStack						then begin							base.funcs:go(base.card.nextCardStack & "");							backgroundLayer:close();							cardLayer:close();							:redoChildren()							end						else return nil						end				else if base.cardsToPrint=1 then begin // marked cards					markedCardIndex:=markedCardIndex+1;					if markedCardIndex<length(base.stack.markedCards)						then begin 							base.funcs:go(base.stack.markedCards[markedCardIndex] & "");							backgroundLayer:close();							cardLayer:close();							:redoChildren();							end						else return nil					end				else return nil			end		end			else if printFormat='list then		while lastLineNo do begin			myPageCounter := myPageCounter + 1;			turningPages := true;			:RedoChildren();	// rebuild all our views in preparation for the next page			turningPages := nil;			return true;			end;end
       ,
     symbol: kMyMainViewDefSym,
     viewSetupFormScript:
       func() begin	if debug then print("printFormat:viewSetupFromScript");	if debug then getglobals().pf:=self;	base:=getroot().(kAppSymbol);	printFormat:=base.screenview.printFormat;	if base.newtCard then begin		if base.cardsToPrint=0 then begin // all			base.funcs:go('first);			end		else if base.cardsToPrint=1 and length(base.stack.markedCards)>0 then begin // marked			markedCardIndex:=0;			base.funcs:go(base.stack.markedCards[markedCardIndex] & "");			end		end;			if base.newtCard and not visible(base.screenview) then printFormat:='app;	if printFormat='list then lastLineNo:=0;	if not turningPages then myPageCounter := 1;	if not hasSlot(self, 'stepChildren) then self.stepChildren:=clone(self.stepchildren);	inherited:?viewSetupFormScript();	end
       ,
     formatInitScript:
       func(fields,theTarget)begin	/* If you need to do prep something which takes a long time, and you are 	 * worried about "timing out" a fax machine, do it here, not	 * in viewSetupFormScript!!!	 */end
     ,
     SetupItem:
       func(item, tInfo) begin	/* If you have any "preprocessing" to do like set anything in the item or add	 * extra slots like version slots, or extra data, you can do it here, but if you are	 * trying to actually prep the visual shapes, you should do that in formatInitScript.	 */	inherited:?SetupItem(item, tInfo);		if getroot().(kAppSymbol).newtCard then		getroot().(kAppSymbol).cardsToPrint:=modalConfirm("Which cards should be included?",["All","Marked","Current"]);		// set the title; note that the string will be editable by the user...	item.title := "NewtCard: " & datentime(time());		item;end
       ,
     title: "NewtCard",
     myPageCounter: nil,
     turningPages:
       nil	// a flag to distinguish between initialization and RedoChildren in viewSetupFormScript
       ,
     printFormat: nil,
     lastLineNo: nil,
     margins: {left: 25, top: 25, right: 25, bottom: 25},
     base: nil,
     cardsToPrint: nil,
     markedCardIndex: nil,
     _proto: @200 /* protoPrintFormat */
    };

widgets :=
    {viewFlags: 1,
     viewFont: {family: 'monaco, size: 9, face: 0},
     viewFormat: 0,
     viewBounds: {left: 5, top: 5, right: 5, bottom: -5},
     viewJustify: 240,
     viewLineSpacing: 11,
     viewSetupFormScript:
       func() begin	local results;	local lpp:=((self:localBox().bottom-self:localBox().top) DIV viewLineSpacing)-4;		if printformat='app then begin		if not base.NewtCard then begin			foreach widget in base._RF._userviews do				if NOT hasVariable(widget, 'dontRoute) then addStepView(self, widget);			end		else begin //NewtCard			backgroundLayer.shapeArray:=base.backgroundlayer.shapeArray;			backgroundLayer.styleFrame:=base.backgroundlayer.styleFrame;			backgroundLayer:open();						foreach widget in base.executor._bgcd.background._userviews do				if NOT hasVariable(widget, 'dontRoute) then addStepView(self, widget);							cardLayer.shapeArray:=base.card.shapeArray;			cardLayer.styleFrame:=base.card.styleFrame;			cardLayer:open();							foreach widget in base.executor._bgcd.card._userviews do				if NOT hasVariable(widget, 'dontRoute) then addStepView(self, widget);					end		end			else if printFormat='list then begin		base.editor.newStmt:=lastLineNo+1 & ",," & quote & "_action" & quote & "," & lpp;		results:=base.interpreter:doList();		if debug then print(results);		setValue(self, 'text, base.systemEntry.ProgramName & spaces & spaces													& datenTime(time())          & spaces & spaces													& "Page:" & myPageCounter & CR & CR 													& stringer(results[0]));		lastLineNo:=results[1];	endend
       ,
     viewClass: 81 /* clParagraphView */
    };
AddStepForm(printForm, widgets);



wrapper :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewFlags: 0,
     viewFormat: 0,
     viewJustify: 240,
     viewSetupFormScript:
       func() begin	if debug then print("wrapper opening");	local a := GetAppParams();	self.viewBounds := RelBounds(a.appAreaLeft, a.appAreaTop, a.appAreaWidth, a.appAreaHeight);	end
     ,
     viewClass: 74 /* clView */
    };
AddStepForm(printForm, wrapper);

backgroundLayer :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewFlags: 0,
     viewFormat: 0,
     viewJustify: 240,
     viewSetupFormScript:
       func() begin	if debug then print("backgroundLayer opening");	shapeArray:=base.backgroundlayer.shapeArray;	styleFrame:=base.backgroundlayer.styleFrame;	self.stepChildren:=[];	end
     ,
     drawShapes: func() begin	:drawShape(shapeArray, nil);end,
     shapeArray: [],
     styleFrame: nil,
     viewDrawScript: func() :doDrawing('drawShapes, NIL);,
     viewClass: 74 /* clView */
    };
AddStepForm(wrapper, backgroundLayer);
StepDeclare(printForm, backgroundLayer, 'backgroundLayer);



cardLayer :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewFlags: 1,
     viewFormat: 0,
     viewJustify: 240,
     viewSetupFormScript:
       func() begin	if debug then print("cardLayer opening");	shapeArray:=base.cardlayer.shapeArray;	styleFrame:=base.cardlayer.styleFrame;	self.stepChildren:=[];	end
     ,
     drawShapes: func() begin	:drawShape(shapeArray, nil);end,
     shapeArray: [],
     styleFrame: nil,
     viewDrawScript: func() :doDrawing('drawShapes, NIL);,
     viewClass: 74 /* clView */
    };
AddStepForm(wrapper, cardLayer);
StepDeclare(printForm, cardLayer, 'cardLayer);






constant |layout_PrintFormat| := printForm;
// End of file PrintFormat
// Beginning of text file unitDeclares
DefConst('kCommsUnitFrame, {commsUnit:	0, BITUnit: 1});declaration := Clone(kCommsUnitFrame);declaration.commsUnit := 0;declaration.BITUnit := 1;DeclareUnit('|commsUnit:NSB|, 1, 0, declaration);DefConst('kEditorUnitFrame, {editorUnit: nil,});declaration := Clone(kEditorUnitFrame);declaration.editorUnit := 0;DeclareUnit('|editorUnit:NSB|, 1, 0, declaration);DefConst('kExecutorUnitFrame, {executorUnit: nil,});declaration := Clone(kExecutorUnitFrame);declaration.executorUnit := 0;DeclareUnit('|e
£Gø£GÀxecutorUnit:NSB|, 1, 0, declaration);DefConst('kInterpreterUnitFrame, {interpreterUnit: nil,});declaration := Clone(kInterpreterUnitFrame);declaration.interpreterUnit := 0;DeclareUnit('|interpreterUnit:NSB|, 1, 0, declaration);DefConst('kVisualDesignerUnitFrame, {visualDesignerUnit: nil,});declaration := Clone(kVisualDesignerUnitFrame);declaration.visualDesignerUnit := 0;DeclareUnit('|visualDesignerUnit:NSB|, 1, 0, declaration);DeclareUnit('|Draw:NEWTON|, 1, 0, {	protoDrawTool:	0,	align
£Gø£GÀSlip:		1,	dataDef:		2,	baseView:		3,	canvasView:		4,	horzRuler:		5,	vertRuler:		6,	printPage:		7,	ShapeFillPicker:8,});/*// warn user that we can't work without unitsSetPartFrameSlot('RemovalApproval, func(unitName, major, minor)  begin "This operation will also disable NewtCard." end);  // when editor is gone, we close up shopSetPartFrameSlot('ImportDisabled, func(unitName, major, minor)  begin GetRoot().(kAppSymbol):Close();  end);*/
Draw:NEWTON|, 1, 0, {	protoDrawTool:	0,	align
// End of text file unitDeclares
// Beginning of file aboutNewtCard
aboutNewtCard :=
    {viewFlags: 612,
     viewFormat: 67110641,
     viewLineSpacing: 20,
     viewFont: 18434,
     viewClickScript:
       func(unit)	begin		local timeout:=TRUE;		if NOT strEqual(kTimeOut,"None") then   		if time()>stringtodate(kTimeOut) then timeout:=NIL;   	if TimeOut then self:close();	end
     ,
     viewBounds: {left: 1, top: 6, right: 227, bottom: 200},
     notRunTime: 'aboutNC,
     ReorientToScreen: ROM_defRotateFunc,
     viewSetupDoneScript: func() getroot().(kAppSymbol).aboutNC:=self;,
     _proto: @179 /* protoFloater */
    };

Details :=
    {
     text:
       "\nUse of this product is \nsubject to the terms of \nthe Licence Agreement in \nthe NewtCard Handbook.\n\u00A9\u Copyright 1994-1997\nNS BASIC Corporation."
     ,
     viewBounds: {left: 92, top: 105, right: 233, bottom: 190},
     viewFont: simpleFont9,
     viewJustify: 8,
     viewFlags: 35,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(aboutNewtCard, Details);



Version :=
    {text: "",
     viewBounds: {left: 92, top: 73, right: 233, bottom: 107},
     viewFont: simpleFont9+tsBold,
     viewJustify: 4,
     viewSetupFormScript:
       func() begin	if debug then print("version.viewSetupFormScript");	local v:=kVersion;	if kUpdate then v:=kVersion && "U";	text:=v & CR & "Timeout:" && kTimeOut & CR &				"Serial#:" && getroot().(kAppSymbol).systementry.serialnumber	end
     ,
     viewFlags: 35,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(aboutNewtCard, Version);
StepDeclare(aboutNewtCard, Version, 'Version);



Numbers :=
    {
     text:
       "NS BASIC\nCorporation\n77 Hill Crescent\nToronto, Canada\nM1M 1J3\n\ntel  416 264-5999\nfax 416 264-5888\ninfo@nsbasic.com\n"
     ,
     viewBounds: {left: 1, top: 72, right: 108, bottom: 190},
     viewFont: simpleFont9,
     viewJustify: 8,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(aboutNewtCard, Numbers);



logo :=
    {viewBounds: {left: 0, top: 2, right: 81, bottom: 82},
     buttonClickScript:
       func()begin	myPicture:open();	refreshViews();	sleep(180);	myPicture:close();end
     ,
     icon:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 143}),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 143}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u70", resource: })
             ,bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u70", resource: })
             ,bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u70", resource: })
             ,bitDepth: 8}]);,
     viewFormat: 1,
     _proto: @198 /* protoPictureButton */
    };
AddStepForm(aboutNewtCard, logo);



myPicture :=
    {viewBounds: {left: 82, top: 2, right: 232, bottom: 199},
     buttonClickScript: func()beginend,
     viewFlags: 514,
     icon: GetPictAsBits("smallFace", nil),
     _proto: @198 /* protoPictureButton */
    };
AddStepForm(aboutNewtCard, myPicture);
StepDeclare(aboutNewtCard, myPicture, 'myPicture);



aboutNewtCard_v166_0 := {_proto: @166 /* protoCloseBox */};
AddStepForm(aboutNewtCard, aboutNewtCard_v166_0);



aboutNewtCard_v198_0 :=
    {viewBounds: {left: 92, top: 2, right: 198, bottom: 70},
     icon:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 130}),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 130}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u70", resource: })
             ,bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u70", resource: })
             ,bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u70", resource: })
             ,bitDepth: 8}]);,
     viewFormat: 1,
     _proto: @198 /* protoPictureButton */
    };
AddStepForm(aboutNewtCard, aboutNewtCard_v198_0);




constant |layout_aboutNewtCard| := aboutNewtCard;
// End of file aboutNewtCard
// Beginning of file thingsToDo
thingsToDoBase :=
    {viewFlags: 1,
     viewFormat: 0,
     viewBounds: {left: 0, top: 0, right: 200, bottom: 56},
     viewJustify: 10368,
     soundPath: nil,
     effectPath: nil,
     viewClass: 74 /* clView */
    };

Sound :=
    {labelCommands: nil,
     text: "Play a Sound",
     viewBounds: {left: 8, top: 1, right: 208, bottom: 20}
     ,
     alwaysCallPickActionScript: true,
     viewFont: ROM_fontSystem9,
     indent: 70,
     viewSetupDoneScript: func() begin	print(entryline);end,
     labelActionScript:
       func(cmd) begin	target.(soundPath):=labelCommands[cmd].value;	if not target.(soundPath) then return;	PlaySound(GetGlobals().SoundRegistry.(target.(soundPath)));	end
     ,
     textSetup:
       func()begin	local sound;	if not hasSlot(target, soundPath) then		"None";	else if (foreach index, cmd in LabelCommands do		if IsFrame(cmd) and cmd.value=target.(soundPath) then			break sound:=index) then labelCommands[index].item;	else		"None";end
     ,
     viewSetupFormScript:
       func() begin	local SReg := GetGlobals().SoundRegistry;	local sounds:=foreach sound, value in SReg._proto collect			{item:value.UserName,value:sound,};	if Length(SReg) > 0 then begin		local added:=foreach sound, value in SReg collect				if sound <> '_proto then					{item:if hasSlot(value,'username) then value.UserName else "Untitled Sound", 					 value:sound};		RemoveSlot(added,LSearch(added,nil,0,'|=|,nil));		end else added := [];	sounds:=ArrayMunger(sounds,Length(sounds),nil,added,0,nil); 	Sort(sounds,'|str<|,'item);	ArrayMunger(sounds,Length(sounds),nil,['pickSeparator,{item:"None",value:nil,}],0,nil);	self.labelcommands:=sounds;	inherited:?viewSetupFormScript();		// this method is defined internallyend
       ,
     checkCurrentItem: true,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(thingsToDoBase, Sound);
StepDeclare(thingsToDoBase, Sound, 'Sound);



VisualEffect :=
    {
     labelCommands:
       [	{item: "Barn Door Close", value: fxBarnDoorCloseEffect},	{item: "Barn Door Open", value: fxBarnDoorOpenEffect},	{item: "Checkerboard", value: fxCheckerboardEffect},	{item: "Drawer", value: fxDrawerEffect},	{item: "Iris Close", value: fxIrisCloseEffect},	{item: "Iris Open", value: fxIrisOpenEffect},	{item: "Pop Down", value: fxPopDownEffect},	{item: "Venetian Blinds", value: fxVenetianBlindsEffect},	{item: "Zoom Close", value: fxZoomCloseEffect},	{item: "Zoom Open", value: fxZoomOpenEffect},	{item: "Zoom Vertical", value: fxZoomVerticalEffect},	'pickSeparator,	{item: "None", value: 0},]
     ,
     text: "Visual Effect",
     viewBounds: {left: 8, top: 20, right: 208, bottom: 37},
     alwaysCallPickActionScript: true,
     viewFont: ROM_fontSystem9,
     indent: 70,
     textSetup:
       func() begin	local efx := foreach cmd in LabelCommands do		if IsFrame(cmd) and target.(effectPath)=cmd.value then			break cmd.item;	if not efx then efx := "None";	efx;end
     ,
     labelActionScript:
       func(cmd) begin	target.(effectPath) := labelCommands[cmd].value;	effectView:ShowViewEffect(target.(effectPath), target.(soundPath));end
     ,
     checkCurrentItem: true,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(thingsToDoBase, VisualEffect);
StepDeclare(thingsToDoBase, VisualEffect, 'VisualEffect);



Script :=
    {indent: 55,
     text: "Run a Script",
     viewBounds: {left: 8, top: 38, right: 108, bottom: 51},
     viewFont: ROM_fontSystem9,
     viewClickScript:
       func(unit) begin	inherited:?viewClickScript(unit);	funcs:editorCall(scriptName, 'editorReturn);	TRUE;	end
     ,
     viewValue: nil,
     _proto: @164 /* protoCheckBox */
    };
AddStepForm(thingsToDoBase, Script);
StepDeclare(thingsToDoBase, Script, 'Script);




constant |layout_thingsToDo| := thingsToDoBase;
// End of file thingsToDo
// Beginning of file ActionSlip
actionSlipBase :=
    {viewBounds: {left: 0, top: 20, right: 180, bottom: 302},
     Display:
       func(widget, widgetIndex) begin	if debug then begin		print("ActionSlipBase: display" && widgetIndex);		print(widget);		end;	self.target := widget;	self.widgetIndex := widgetIndex;	:Open();end
     ,
     mode: nil,
     callBackFunc: nil,
     _defaultButton: ,
     setupThingsToDo:
       func() begin	self.effectView := self;	local widgetName:=visualDesigner.widgetArray[visualDesigner.selectedWidget].widgetName;		thingsToDo.scriptName:=executor:makeScriptName('widget, backgroundMode, widgetName);		if hasSlot(baseview.(backgroundMode).subs, thingsToDo.scriptName) 		then thingsToDo.script:toggleCheck();			end
     ,
     viewSetupFormScript: func()begin	SetKeyView(self, nil);end,
     viewQuitScript:
       func() begin	RemoveSlot(self, 'target);	RemoveSlot(self, 'widgetIndex);	inherited:?viewQuitScript();end
     ,
     ShowViewEffect:
       func(viewEffect, showSound)begin	:hide();	self.viewEffect := viewEffect + fxSteps(4);	self.showSound := if showSound then GetGlobals().SoundRegistry.(showSound);	AddDelayedCall(			func(view) begin				view:show();				RemoveSlot(view, 'viewEffect);				RemoveSlot(view, 'showSound);				end,			[self], 10);end
     ,
     viewSetupDoneScript: func()	:setupThingsToDo();,
     _proto: @179 /* protoFloater */
    };

actionSlipBase_v229_0 :=
    {title: "Actions",
     viewBounds: {left: 0, top: -8, right: 224, bottom: 8},
     _proto: @229 /* protoTitle */
    };
AddStepForm(actionSlipBase, actionSlipBase_v229_0);



Places :=
    {text: "Places to Go",
     viewBounds: {left: 4, top: 16, right: 124, bottom: 28},
     _proto: @218 /* protoStaticText */
    };
AddStepForm(actionSlipBase, Places);



placesToGo :=
    {viewBounds: {left: 12, top: 26, right: 188, bottom: 186},
     clusterValue: nil,
     clusterChanged:
       func()begin	if ClusterValue='none then		RemoveSlot(target, 'placesToGo);	else begin		target.PlacesToGo := Clone({action: nil, var: nil,});		target.PlacesToGo.action := clusterValue;	end;end
     ,
     viewSetupFormScript:
       func()begin	if not hasSlot(target, 'placesToGo) or target.placesToGo.action = nil then		self.ClusterValue := 'none	else		self.ClusterValue := target.placesToGo.action;end
     ,
     _proto: @203 /* protoRadioCluster */
    };
AddStepForm(actionSlipBase, placesToGo);
StepDeclare(actionSlipBase, placesToGo, 'placesToGo);

Back :=
    {buttonValue: 'back,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Back",
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, Back);
StepDeclare(actionSlipBase, Back, 'Back);



titleCard :=
    {buttonValue: 'title,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Title Card",
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, titleCard);
StepDeclare(actionSlipBase, titleCard, 'titleCard);



firstCard :=
    {buttonValue: 'first,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "First Card",
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, firstCard);



Previous Card :=
    {buttonValue: 'prev,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Previous Card"
     ,
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, Previous Card);
StepDeclare(actionSlipBase, Previous Card, 'Previous Card);



Next Card :=
    {buttonValue: 'next,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Next Card",
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, Next Card);
StepDeclare(actionSlipBase, Next Card, 'Next Card);



lastCard :=
    {buttonValue: 'last,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Last Card",
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, lastCard);



anotherCard :=
    {buttonValue: 'card,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Another Card",
     viewClickScript:
       func(unit) begin	inputOneLineLink:display("Jump to Card","Card Name","",'cardToGo);	inherited:?viewClickScript(unit);		// this method is defined internally	// Return true if click has been completely handled, nil otherwise	end
       ,
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, anotherCard);
StepDeclare(actionSlipBase, anotherCard, 'anotherCard);



AnotherStack :=
    {buttonValue: 'stack,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Another Stack"
     ,
     viewClickScript:
       func(unit) begin	inputOneLineLink:display("Jump to Stack", "Stack Name", "", 'stackToGo);	inherited:?viewClickScript(unit);		// this method is defined internally	// Return true if click has been completely handled, nil otherwise	end
       ,
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, AnotherStack);
StepDeclare(actionSlipBase, AnotherStack, 'AnotherStack);



AnotherApp :=
    {buttonValue: 'app,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "Another App",
     viewClickScript:
       func(unit) begin	inputOneLineLink:display("Jump to App","App Name","",'appToGo);	inherited:?viewClickScript(unit);		// this method is defined internally	// Return true if click has been completely handled, nil otherwise	end
       ,
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, AnotherApp);
StepDeclare(actionSlipBase, AnotherApp, 'AnotherApp);



None :=
    {buttonValue: 'none,
     viewBounds: {left: 0, top: 0, right: 96, bottom: 16},
     text: "None of the Above",
     viewJustify: 8196,
     _proto: @202 /* protoRadioButton */
    };
AddStepForm(placesToGo, None);





toDo :=
    {text: "Things to Do",
     viewBounds: {left: 4, top: 192, right: 123, bottom: 204},
     _proto: @218 /* protoStaticText */
    };
AddStepForm(actionSlipBase, toDo);
StepDeclare(actionSlipBase, toDo, 'toDo);



thingsToDo :=
    {effectPath: 'leaveEffect, soundPath: 'leaveSound, _proto: thingsToDoBase}
    ;
AddStepForm(actionSlipBase, thingsToDo);
StepDeclare(actionSlipBase, thingsToDo, 'thingsToDo);



OK :=
    {buttonClickScript: func() begin	actionSlipLink:close();	end,
     text: "OK",
     viewBounds: {left: -43, top: -18, right: -25, bottom: -5},
     viewJustify: 8388774,
     viewSetupDoneScript: func() begin	_defaultButton:=self;	end,
     viewFlags: 514,
     _proto: @226 /* protoTextButton */
    };
AddStepForm(actionSlipBase, OK);
StepDeclare(actionSlipBase, OK, 'OK);



actionSlipBase_v163_0 := {_proto: @163 /* protoLargeClosebox */};
AddStepForm(actionSlipBase, actionSlipBase_v163_0);




constant |layout_ActionSlip| := actionSlipBase;
// End of file ActionSlip
// Beginning of file Buttons.t
Buttons :=
    {viewBounds: {left: 40, top: 48, right: 248, bottom: 272},
     viewFlags: 1,
     viewFormat: 0,
     viewClass: 74 /* clView */
    };

bInfo :=
    {
     DoInfoHelp:
       func() begin	PT_aboutNC:close();	infoButtonLink:Display('help);end,
     DoInfoAbout: func() PT_aboutNC:open();,
     DoInfoPrefs:
       func() begin	PT_aboutNC:close();	infoButtonLink:Display('prefs);end,
     buttonClickScript: func() aboutNC:open();,
     declareSelf: 'bInfo,
     viewBounds: {left: 6, top: -16, right: 19, bottom: -3},
     _proto: @478 /* protoInfoButton */
    };
AddStepForm(Buttons, bInfo);



bNew :=
    {text: "  New",
     viewBounds: {left: 25, top: -14, right: 53, bottom: -1},
     pickActionScript:
       func(cmd) begin	local type:=Intern(popup[cmd]);	if type='stack then		inputOneLineLink:display("New Stack","Stack Name","Untitled",'newStack);	else begin		local specFrame:={name: nil,};		if type='background then begin			local i:=0;			while stack.backgrounds.(intern("bg_" & i)) do i:=i+1;			specFrame.name :="BG_" & i;			end;		funcs:NewItem(type, specFrame);		infoSlipLink:Display(type);		end;	inherited:pickActionScript(cmd)	end
     ,
     popup: [	"Stack",	"Background",	"Card",],
     declareSelf: 'bNew,
     keyButton: '_newKeyButton,
     viewQuitScript:
       func()begin	RemoveSlot(baseView, keybutton);	inherited:?viewQuitScript();end
     ,
     viewSetupDoneScript: func()	baseView.(keyButton) := self,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bNew);



bEdit :=
    {text: "  Edit",
     viewBounds: {top: -16, left: 121, right: 186, bottom: -3},
     pickActionScript:
       func(i) begin	if popup[i].value = 'deleteCard then		_RF:deleteCard()	else if popup[i].value = 'cutCard then begin		_rf:copyCard();		_RF:deleteCard()		end	else if popup[i].value = 'copyCard then		_RF:copyCard()	else if popup[i].value = 'pasteCard then		_RF:pasteCard();			inherited:pickActionScript(i)	end
     ,
     popup:
       [ {		keyMessage:		'_keyButtonUndoScript,	// default system button		drawMessage:	'EditUndo,	},	'pickSeparator,		{		keyMessage:		'_keyButtonCutScript,	// default system button		drawMessage:	'EditCut,	},	{		keyMessage:		'_keyButtonCopyScript,	// default system button		drawMessage:	'EditCopy,	},	{		keyMessage:		'_keyButtonPasteScript,		drawMessage:	'EditPaste,	},	{			item:				"Clear",		drawMessage:	'EditDelete,	},		'pickSeparator,	{item: "Delete Card", value: 'deleteCard,},	{item: "Cut Card", value: 'cutCard,},	{item: "Copy Card", value: 'copyCard,},	{item: "Paste Card", value: 'pasteCard,},  	'pickSeparator,	{keyMessage: '_background,},]
       ,
     buttonClickScript:
       func()begin	if not HasSlot(self, 'popup) then begin		self.popup := Clone(popup);		popup[Length(popup) - 1] := Clone(popup[Length(popup) - 1]);	end;	popup[Length(popup) - 1].mark := if backgroundMode='background then kCheckMarkChar;	inherited:?ButtonClickScript();end
     ,
     declareSelf: 'bEdit,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bEdit);



bGo :=
    {text: "  Go",
     viewBounds: {top: -16, left: 121, right: 186, bottom: -3},
     pickActionScript:
       func(cmd) begin	if popup[cmd].value then begin		if popup[cmd].value='find then GetRoot().findDrawer:PrimeAndOpen();		end;	inherited:pickActionScript(cmd)	end
     ,
     popup:
       [	{keyMessage: '_GoBack,},	{keyMessage: '_GoTitle,},		'pickSeparator,	{keyMessage: '_GoFirst,},	{keyMessage: '_GoPrev,},	{keyMessage: '_GoNext,},	{keyMessage: '_GoLast,},	{keyMessage: '_GoCard,},	{keyMessage: '_GoStack,},		'pickSeparator,	{item: "Find", value: 'find,},	{keyMessage: '_GoMessage,},]
     ,
     declareSelf: 'bGo,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bGo);



bFont :=
    {text: "  Font",
     viewBounds: {left: 9, top: -16, right: 47, bottom: -3},
     pickActionScript:
       func(cmd)begin	inherited:?PickActionScript(cmd);	local picked := popup[cmd];	if HasSlot(picked, 'family) then family := picked.family;	else if HasSlot(picked, 'size) then size := picked.size;	else if HasSlot(picked, 'face) then face := picked.face;	:FontChanged();end
     ,
     popup: nil,
     buttonClickScript:
       func() begin	currentFont := GetUserConfig('userFont);	family := face := size := nil;	popup := MakeFontMenu(currentFont, nil, nil, nil);	inherited:?ButtonClickScript();			// call the inherited version to do popupend
       ,
     currentFont: nil,
     declareSelf: 'bFont,
     family: nil,
     face: nil,
     size: nil,
     fontChanged:
       func() begin	local theFont := {};	local defFont := GetDefaultFont(GetView('viewfrontkey));	if family then		theFont.family := family;	else		family := GetFontFamilySym(defFont);	if size then		theFont.size := size;	else		size := GetFontSize(defFont);	if face then		theFont.face := face;	else		face := GetFontFace(defFont);	GetKeyView():?viewChangeStyleScript(theFont);	currentFont := MakeCompactFont(family, size, face);	if not GetHilitedTextItems() then	begin		GetGlobals().nextStyle := currentFont;		SetUserConfig('userFont, currentFont);	end;end
     ,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bFont);



bShow :=
    {text: "  Show",
     viewBounds: {top: -16, left: 7, right: 72, bottom: -3},
     pickActionScript:
       func(i) begin	if i < 3 then baseView:ShowToolLayer(popup[i].value)	else infoSlipLink:display(popup[i].value);	inherited:pickActionScript(i)	end
     ,
     popup: nil,
     buttonClickScript:
       func() begin	if debug then print("tools.buttonClickScript");	popup := [		{item: "Browser", value: 'none,},		{item: "Drawing", value: 'drawing,},		{item: "Buttons & Fields", value: 'widgets,},		'pickSeparator,		{item: "Stack Info", value: 'stack},			{item: "Background Info", value: 'background},			{item: "Card Info", value: 'card}];	foreach tool in popup do		if tool.value = currentTool then		begin			tool.pickable := nil;			tool.mark := kCheckMarkChar;			break;		end;	inherited:?ButtonClickScript();	end
     ,
     declareSelf: 'bShow,
     keyButton: '_showKeyButton,
     viewQuitScript:
       func()begin	RemoveSlot(baseView, keybutton);	inherited:?viewQuitScript();end
     ,
     viewSetupDoneScript: func()	baseView.(keyButton) := self,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bShow);



bAction := {declareSelf: 'bAction, _proto: @209 /* protoActionButton */};
AddStepForm(Buttons, bAction);



bClose :=
    {viewBounds: {left: -18, top: -16, right: -5, bottom: -3},
     buttonClickScript:
       func() begin	if Visible(editor) then begin		screenView.closeEditor:buttonClickScript();		return;		end;	if currentTool <> 'none then begin		:ShowToolLayer('none);		return;	end;	inherited:?buttonClickScript();		// this method is defined internally	end
       ,
     declareSelf: 'bClose,
     _proto: @163 /* protoLargeClosebox */
    };
AddStepForm(Buttons, bClose);



bDrawEdit :=
    {text: "  Edit",
     popup:
       [	{		keyMessage:		'_keyButtonUndoScript,	// default system button		drawMessage:	'EditUndo,	},	'pickSeparator,		{		keyMessage:		'_keyButtonCutScript,	// default system button		drawMessage:	'EditCut,	},	{		keyMessage:		'_keyButtonCopyScript,	// default system button		drawMessage:	'EditCopy,	},	{		keyMessage:		'_keyButtonPasteScript,		drawMessage:	'EditPaste,	},	{			item:				"Clear",		drawMessage:	'EditDelete,	},		'pickSeparator,		{		item: "Select All",		keyMessage:		'_SelectAll,		drawMessage:	'SelectAll,	},	{		item: "Duplicate",		keyMessage:		'_Duplicate,		drawMessage:	'EditDuplicate,	},]
       ,
     viewBounds: {left: 10, top: -16, right: 48, bottom: -3},
     pickActionScript:
       func(cmd) begin	Perform(drawLink.drawView:GetCanvas(), popup[cmd].drawMessage, nil);	inherited:?PickActionScript(cmd);end
     ,
     declareSelf: 'bDrawEdit,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bDrawEdit);



bDrawFont :=
    {text: "  Font",
     popup:
       // set in buttonClickScriptnil
       ,
     viewBounds: {left: 9, top: -16, right: 47, bottom: -3},
     pickActionScript:
       /*	Grabs the font stached in currentFont (setup by the buttonClickScript),	tweaks the particular font attribute, and calls SetStyleAttribute to change	the current selection.		currentFont should never be NIL. */func(itemSelected)begin	inherited:?PickActionScript(itemSelected);		// call the inherited version to unhilite the button	local canvas := drawLink.drawView:GetCanvas();	local item := popup[itemSelected];	canvas:SetFontStyle(item);end
       ,
     buttonClickScript:
       /*	Mark the proper items to reflect the font of the current selection (or default)*/func()begin	// You may want to use key commands for Plain, Bold, Italic, and Underline.  The following	// are the names of the key messages: '_setPlainStyle, '_setBoldStyle, '_setItalicStyle, '_setUnderlineStyle	local canvas := drawLink.drawView:GetCanvas();	currentFont := canvas:GetCurrentFont();	// stash away for PickActionScript	popup := MakeFontMenu(currentFont, nil, nil, nil);	inherited:?ButtonClickScript();			// call the inherited version to do popupend
       ,
     currentFont:
       // Font displayed in the popup when it is open, never nil.  Setup by buttonClickScriptnil
       ,
     declareSelf: 'bDrawFont,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bDrawFont);



bDrawArrange :=
    {text: "  Arrange",
     popup:
       [	"Move Forward",	"Move to Front",	"Move Backward",	"Move to Back",	'pickSeparator,	"Align Objects",	'pickSeparator,	"Flip Horizontally",	"Flip Vertically",	"Rotate Right",	"Rotate Left",	'pickSeparator,	{		item: "Group",		keyMessage:		'_Group,	},	{		item: "Ungroup",		keyMessage:		'_Ungroup,	},]
     ,
     viewBounds: {left: 10, top: -16, right: 63, bottom: -3},
     pickActionScript:
       func(itemSelected)begin	local canvas := drawLink.drawView:GetCanvas();	if itemSelected = 0 then		canvas:MoveForward(nil);	else if itemSelected = 1 then		canvas:MoveToFront(nil);	else if itemSelected = 2 then		canvas:MoveBackward(nil);	else if itemSelected = 3 then		canvas:MovetoBack(nil);	else if itemSelected = 5 then		canvas:OpenAlignObjectsSlip();	else if itemSelected = 7 then		canvas:FlipHorizontally(nil);	else if itemSelected = 8 then		canvas:FlipVertically(nil);	else if itemSelected = 9 then		canvas:RotateRight(nil);	else if itemSelected = 10 then		canvas:RotateLeft(nil);	else if itemSelected = 12 then		canvas:Group(nil);	else if itemSelected = 13 then		canvas:Ungroup(nil, nil);			inherited:?PickActionScript(itemSelected);end
     ,
     buttonClickScript:
       func()begin	if NOT drawLink.drawView:HasSelection() then		begin			:Notify( kNotifyAlert, kAppName, "Nothing is selected." );			:Hilite( nil );		end;	else		inherited:?ButtonClickScript();	// call the inherited version to do popupend
       ,
     declareSelf: 'bDrawArrange,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bDrawArrange);



// After Script for Buttons
thisView := Buttons;
foreach child in thisView.stepChildren dobegin	RemoveSlot(child, 'viewBounds);	local sym := GetSlot(child, 'declareSelf);	RemoveSlot(child, 'declareSelf);//		child.viewQuitScript := thisView.QuitScript;//		child.viewSetupDoneScript := thisView.DoneScript;	DefConst(sym, child);end		



constant |layout_Buttons.t| := Buttons;
// End of file Buttons.t
// Beginning of file Draw
drawBase :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewJustify: 240,
     viewSetupFormScript:
       func()begin	self._oldKeyView := GetKeyView();	SetKeyView(self, nil);	self._nextKeyView := GetRoot();	self.target := { saveData: {shapes: [], styles: nil, selection: []} };	self.targetView := self;	:alignButtons({left: [bDrawEdit, bDrawFont, bDrawArrange,],});end
     ,
     GetAppPreferences:
       func()begin	local prefs := GetAppPrefs( kAppSymbol, {drawPaper: {}} );		/* Override the defaults if you'd like	   	   However, if you call ShowGrid/ShowRuler/ShowToolBar, these prefs will	   get saved out to the real prefs so please be careful.  If you want to 	   call these functions, please save off a clone of 'prefs and restore it	   when you quit	  	if prefs.drawPaper then		begin			prefs.drawPaper.drawGrid := nil;			prefs.drawPaper.drawRuler := nil;			prefs.drawPaper.drawToolBar := nil;		end;	*/	prefs;end;
     ,
     UpdateAllScrollers:
       func(a, b, c, d, e)	begin	nil;  // do nothing	end;
       ,
     target: nil,
     StartFlush:
       // Do nothing for now, you should hook into this to start an idle script that when it// fires, will save the data outfunc() nil;
       ,
     keyCommands:
       [	{		char: 		$a,							modifiers:	kCommandModifier,				keymessage: '_SelectAll,		name:			"Select All",		category:	"Editing",	},	{		char: 		$d,							modifiers:	kCommandModifier,				keymessage: '_Duplicate,		name:			"Duplicate",		category:	"Editing",	},]/********* Other keys that might be useful ***************	{	char: 		$g,						modifiers:	kCommandModifier,			keymessage: '_Group,	name:		"Group",	category:	 kKeyCategoryEditing,	},	{	char: 		$g,						modifiers:	kCommandModifier + kShiftModifier,			keymessage: '_UnGroup,	name:		 "Ungroup",	category:	 kKeyCategoryEditing,	},	{	char: $t,	modifiers: kCommandModifier,	keyMessage: '_SetPlainStyle,	name:"Plain Text",	category: kKeyCategoryEditing,	},	{	char: $b,	modifiers: kCommandModifier,	keyMessage: '_SetBoldStyle,	name:("Bold",	category: kKeyCategoryEditing,	},	{	char: $i,	modifiers: kCommandModifier,	keyMessage: '_SetItalicStyle,	name:"Italic",	category: kKeyCategoryEditing,	},	{	char: $u,	modifiers: kCommandModifier,	keyMessage: '_SetUnderlineStyle,	name:("Underline",	category: kKeyCategoryEditing,	}*/
     ,
     viewFlags: 0,
     viewFormat: 0,
     declareSelf: 'base,
     callBackFunc: nil,
     viewQuitScript:
       func()begin	if drawView and drawView.canvas then begin		drawView.canvas:ClearSelection();		Perform(funcs, callBackFunc,				[{shapes:drawView.canvas.allShapes,styles:drawView.canvas.allStyles}]);		end;	if Visible(_oldKeyView) then		self._nextKeyView := _oldKeyView;	RemoveSlot(self, '_oldKeyView);	RemoveSlot(self, '_nextKeyView);	inherited:?viewQuitScript();end
     ,
     viewClass: 74 /* clView */
    };

drawView :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: -20},
     viewFlags: 1,
     viewFormat: 0,
     viewJustify: 240,
     viewSetupDoneScript:
       func() begin	inherited:?viewSetupDoneScript();	:GetTotalWidth();	:GetTotalHeight();	setvalue(canvas, 'viewformat, 0);	canvas:dirty();//	canvas.viewQuitScript:=func() begin//		if debug then print("canvas: viewQuitScript");//		if callBackFunc then perform(funcs, callBackFunc,//			//[deepclone(canvas.allShapes), deepclone(canvas.allStyles)]);//			[canvas.allShapes, canvas.allStyles]);//		inherited:?viewQuitScript();		// this method is defined internally//		end;			end
       ,
     viewSetupChildrenScript:
       func()begin	inherited:?viewSetupChildrenScript();	Canvas.viewBounds := SetBounds(0,0,0,0);	ToolBar.viewFlags := BOr(ToolBar.viewFlags, vFloating);end
     ,
     viewSetupFormScript:
       func()begin	inherited:?viewSetupFormScript();	self.viewDefView := self;end
     ,
     viewClass: 74 /* clView */
    };
AddStepForm(drawBase, drawView);
StepDeclare(drawBase, drawView, 'drawView);

// After Script for drawView
thisView := drawView;
// This is really the NewtWorksDraw base view, not a clView.  NTK doesn't know about// protoDrawTools so we have to force it with this little trick...RemoveSlot(thisView, 'viewClass);thisView._proto := UR('|Draw:NEWTON|, 'baseView);




drawBase_v608_0 :=
    {
     ViewScroll2DScript:
       func(direction,extras)begin	drawView:Scroll(scrollInfo.(direction));	Inherited:?ViewScroll2DScript(direction,extras);end
     ,
     viewBounds: {left: 5, top: 0, right: 70, bottom: 18},
     viewJustify: 8389638,
     viewFlags: 0,
     _proto: @608 /* protoHorizontal2DScroller */
    };
AddStepForm(drawBase, drawBase_v608_0);




constant |layout_Draw| := drawBase;
// End of file Draw
// Beginning of file infoButton
helpInfoBase :=
    {viewBounds: {left: 9, top: 9, right: 223, bottom: 319},
     viewFlags: 576,
     viewJustify: 80,
     notRunTime: 'helpInfo,
     viewSetupFormScript:
       func() begin	Print(systemEntry.userLevel);	if not IsNumber(systemEntry.userLevel) or systemEntry.userLevel < 0 then		systemEntry.userLevel:=0;	if mode = 'help or systemEntry.userLevel > 0 then begin		local params := GetAppParams();		self.viewBounds:=RelBounds(0,0,params.appAreaWidth-16,params.appAreaHeight-16);		end;	else		self.viewBounds := RelBounds(0,0,180,60);end;
     ,
     viewQuitScript:
       func()begin	RemoveSlot(self, 'mode);	inherited:?viewQuitScript();end,
     Display:
       func(x)begin	if Visible(self) then :Close();	self.mode := x;	:Open();end
     ,
     mode: nil,
     viewSetupChildrenScript:
       func()begin	if mode='prefs then begin		RemoveSlot(UserLevel, 'viewFlags);		if systemEntry.userLevel>0 then			RemoveSlot(TextArea, 'viewFlags)		else			TextArea.viewFlags := BAnd(TextArea.viewFlags, BNot(vVisible));	end	else		UserLevel.viewFlags := BAnd(UserLevel.viewFlags, BNot(vVisible));end
     ,
     helpText:
       ["Need Help?","","For more help on NewtCard,","consult the NewtCard Handbook.","","The latest information is on the","NS BASIC web site, located at","http://www.nsbasic.com","","For support, send questions to","support@nsbasic.com, or","fax to 416 264-5888.", "","For more information,","contact us at info@nsbasic.com.","","To order NS BASIC, you can","contact us at sales@nsbasic.com,","call us at 416 264-5999,","fax us at 416 264-5888,","order through our web site or","ask at your local Newton dealer."]
       ,
     prefsText:
       ["Current ENVIRON settings:"," To change one, type","ENVIRON <elementName>=<newValue>",""]
     ,
     _proto: @180 /* protoFloatNGo */
    };

helpInfoBase_v229_0 :=
    {viewBounds: {left: 3, top: -6, right: 75, bottom: 10},
     viewSetupFormScript:
       func()begin	self.title := "NewtCard" && if mode='help then "Help" else "Preferences";	inherited:?viewSetupFormScript();end
     ,
     _proto: @229 /* protoTitle */
    };
AddStepForm(helpInfoBase, helpInfoBase_v229_0);



UserLevel :=
    {labelCommands: ["Browse","Script","Expert",],
     text: "User Level",
     viewBounds: {left: 20, top: 2, right: -20, bottom: 17},
     viewJustify: 8396848,
     viewSetupFormScript: func()begin	inherited:?viewSetupFormScript();end,
     labelActionScript:
       func(cmd)begin	local oldLevel := systemEntry.userLevel;	systemEntry.userLevel := cmd;	if (oldLevel=0 and cmd > 0) or (cmd=0 and oldLevel>0) then		AddDeferredSend(:Parent(), 'display, ['prefs,]);	else		TextArea:ShowPrefs()end
     ,
     textSetup:
       func()begin	local ul := systemEntry.userLevel;	if not ul then systemEntry.userLevel := 0 else	if ul and not IsNumber(ul) then systemEntry.userLevel := 1;	if systemEntry.userLevel = 44 then "Marcus M. Darden" else	if systemEntry.userLevel > Length(labelCommands) then		labelCommands[Length(labelCommands)-1]	else		labelCommands[systemEntry.userLevel];end;
     ,
     checkCurrentItem: true,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(helpInfoBase, UserLevel);
StepDeclare(helpInfoBase, UserLevel, 'UserLevel);



TextArea :=
    {viewBounds: {left: 4, top: 16, right: -4, bottom: -18},
     viewFlags: 1,
     viewFormat: 336,
     viewJustify: 240,
     viewSetupFormScript:
       func()begin	if mode='prefs then begin		self.viewBounds := Clone(viewBounds);		viewBounds.top := viewBounds.top + 18;	end;end
     ,
     showHelp:
       func() begin	helpbox.def:=clone(helpbox.def);	helpbox.def.tabValues:=helpText;	helpBox:open();end
     ,
     showPrefs:
       func() begin	helpBox:Close();	local lineLen:=(helpbox.viewBounds.right-helpbox.viewBounds.left) DIV 6;  // in Monaco, chars are 6 pixels wide	local includeList:=['inputprompt,'serialnumber,'store,'lastuser,'userlevel,		'programname,'showkeyboard,'printdepth,'listwidgets];		lineLen:=65; // outrageous plug! Help!	local SE:=baseView.systemEntry;	local oldPrintDepth:=SE.printDepth;	SE.printDepth:=5;	helpbox.viewFont:={family: 'monaco, size: 9, face: 0};	local sysFrameSummary:={};	foreach slotname, value in SE do		if NOT beginsWith(sPrintObject(slotname),"_") 			and lsearch(includelist,slotname,0,'|=|,nil)				then sysFrameSummary.(slotname):=value;	helpbox.def:=clone(helpbox.def);	helpbox.def.tabValues:=clone(prefsText);	foreach line in baseView.executor:printFrame(sysFrameSummary) do begin		addArraySlot(helpbox.def.tabValues, line);		if strLen(line)>lineLen			then for i:=lineLen+1 to strLen(line) by lineLen-2 do				addArraySlot(helpbox.def.tabValues, "  " & substr(line,i,nil))		end;	helpbox:open();	SE.printDepth:=oldPrintDepth;end
       ,
     viewSetupDoneScript:
       func()begin	if mode='help then :ShowHelp() else :ShowPrefs();end,
     viewClass: 74 /* clView */
    };
AddStepForm(helpInfoBase, TextArea);
StepDeclare(helpInfoBase, TextArea, 'TextArea);

helpBox :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewFont: simpleFont10+tsbold,
     viewLineSpacing: 20,
     viewJustify: 0,
     viewFlags: 34,
     viewSetupFormScript:
       func() begin	self.viewBounds := :Parent():LocalBox();	def.tabDown:=length(def.tabvalues);	def.tabWidths:=(viewBounds.right-viewbounds.left)-2;	def.tabHeights:=fontHeight(viewFont);		// setup the scroller	scroller.scrollview:=self;	local srect:=setBounds(0,0,0,def.tabDown);	scroller.ScrollRect:=srect;	scroller.DataRect:=srect;	scroller.ViewRect:=setBounds(0,0,0,		((viewbounds.bottom-viewbounds.top) DIV def.tabHeights));	scroller.scrollAmount:=[1, scroller.viewRect.bottom-1, 10];		if call kViewIsOpenFunc with (scroller) then		scroller:AdjustArrows();end
       ,
     ViewScroll2DScript:
       func(dir, extras) begin	if dir='down 		then :viewScrollDownScript()		else if dir='up then :viewScrollUpScript();	// Update the scroller	if call kViewIsOpenFunc with (scroller) then		scroller:AdjustArrows();	// RefreshViews to update the scroller	RefreshViews();end
       ,
     def: protoTableDef,
     scrollAmount: 1,
     viewFormat: 0,
     _proto: @223 /* protoTable */
    };
AddStepForm(TextArea, helpBox);
StepDeclare(TextArea, helpBox, 'helpBox);



scroller := {viewFlags: 65, _proto: @656 /* protoUpDownScroller */};
AddStepForm(TextArea, scroller);
StepDeclare(TextArea, scroller, 'scroller);






constant |layout_infoButton| := helpInfoBase;
// End of file infoButton
// Beginning of file infoSlip
infoBase :=
    {viewBounds: {left: 0, top: 32, right: 216, bottom: 288},
     Display:
       func(type) begin	if visible(infoSlipLink) then :close();	self.type:=type;	self.effectView := self;	self.target := baseView.(type);	:open();end
     ,
     type:
       'Stack  // or 'background or 'card
       ,
     mode:
       nil  //'new or 'info
       ,
     viewSetupFormScript: func() SetKeyView(self, nil);,
     setupThingsToDo:
       func() begin	if mode='new and type='card then card.ID:=stack.lastID+1;	arrive.scriptname:=executor:makeScriptName(type, 'arrive, nil);	leave.scriptname:=executor:makeScriptName(type, 'leave, nil);	if mode='new and type='card then card.ID:=stack.lastID-1;	if hasSlot(target.subs, arrive.scriptName) then arrive.script:toggleCheck();	if hasSlot(target.subs, leave.scriptName) then leave.script:toggleCheck();	end
     ,
     target: nil,
     viewQuitScript:
       func()begin	funcs:editItem(target);	RemoveSlot(self, 'target);	RemoveSlot(self, 'viewEffect);	inherited:?viewQuitScript();end
     ,
     ShowViewEffect:
       func(viewEffect, showSound)begin	:hide();	self.viewEffect := viewEffect + fxSteps(4);	self.showSound := if showSound then GetGlobals().SoundRegistry.(showSound);	AddDelayedCall(			func(view) begin				view:show();				RemoveSlot(view, 'viewEffect);				RemoveSlot(view, 'showSound);				end,			[self], 10);end
     ,
     viewSetupDoneScript:
       func() begin	SetValue(self, '_defaultButton, :ChildViewFrames()[0]);	:setupThingsToDo();	end
     ,
     _proto: @180 /* protoFloatNGo */
    };

Title :=
    {title: "Background Info",
     viewBounds: {left: 0, top: -8, right: 224, bottom: 8},
     viewSetupFormScript:
       func() begin	local text:=CapitalizeWords(Downcase(type && "Info"));	setValue(self, 'title, text);	inherited:?viewSetupFormScript();		// this method is defined internallyend
       ,
     _proto: @229 /* protoTitle */
    };
AddStepForm(infoBase, Title);
StepDeclare(infoBase, Title, 'Title);



Name :=
    {viewBounds: {left: -8, top: 24, right: 224, bottom: 48},
     text: "",
     alwaysCallPickActionScript: nil,
     label: "",
     viewSetupFormScript:
       func() begin	self.label := Capitalize(Downcase(SPrintObject(type))) && "Name";	self.text := target.name;	inherited:?viewSetupFormScript();		// this method is defined internallyend
       ,
     viewSetupDoneScript:
       func() begin	//:doAda(func() setKeyView(name.entryline, strLen(name.text)), '[], 3);	AddDelayedSend(entryLine, 'SetHilite, [0,9999,nil,], 0);	inherited:?viewSetupDoneScript();		// this method is defined internallyend
       ,
     textChanged: func()	target.name := self.text;,
     _proto: @189 /* protoLabelInputLine */
    };
AddStepForm(infoBase, Name);
StepDeclare(infoBase, Name, 'Name);



WhenArriving :=
    {text: "When Arriving",
     viewBounds: {left: 4, top: 54, right: 124, bottom: 70},
     _proto: @218 /* protoStaticText */
    };
AddStepForm(infoBase, WhenArriving);
StepDeclare(infoBase, WhenArriving, 'WhenArriving);



Arrive :=
    {soundPath: 'arriveSound, effectPath: 'arriveEffect, _proto: thingsToDoBase}
    ;
AddStepForm(infoBase, Arrive);
StepDeclare(infoBase, Arrive, 'Arrive);



WhenLeaving :=
    {text: "When Leaving",
     viewBounds: {left: 4, top: 129, right: 123, bottom: 145},
     _proto: @218 /* protoStaticText */
    };
AddStepForm(infoBase, WhenLeaving);
StepDeclare(infoBase, WhenLeaving, 'WhenLeaving);



Leave :=
    {effectPath: 'leaveEffect, soundPath: 'leaveSound, _proto: thingsToDoBase}
    ;
AddStepForm(infoBase, Leave);
StepDeclare(infoBase, Leave, 'Leave);



moreInfo :=
    {text: nil,
     viewBounds: {left: 4, top: 204, right: 216, bottom: 220},
     viewSetupFormScript:
       func() begin	local values;	if type='stack 		then values:=[if not stack.backgrounds 			then "0" 			else Length(stack.backgrounds) & "", stack.cardCount & "",]	else if type='background 		then values:=[background.cardCount & "", if not background.widgets then "0" else Length(background.widgets) & "",]	else 		values:=[if not card.widgets 			then "0" 			else Length(card.widgets) & "", card.ID];	self.text := ParamStr(moreInfoText.(type), values);	end
     ,
     moreInfoText:
       {	stack:      "Backgrounds   ^0   Cards   ^1",	background: "Cards   ^0   Buttons & Fields   ^1",	card:       "Button/Field# ^0     Card ID ^1",}
     ,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(infoBase, moreInfo);



someMoreInfo :=
    {text: nil,
     viewBounds: {left: 4, top: 222, right: 216, bottom: 238},
     viewSetupFormScript:
       func() begin	if type <> 'stack then local size := EntrySize(baseView.(type)) else		size := EntrySoup(stack):GetSize();	self.text := "Size   " & size && "bytes";	if type='card then text:=text & "  Background " & quote & background.name & quote;end
     ,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(infoBase, someMoreInfo);



MarkCard :=
    {text: "Mark this Card",
     viewBounds: {left: 12, top: 220, right: 162, bottom: 235},
     viewFlags: 512,
     indent: 8,
     viewSetupFormScript:
       func()begin	self.indent := self.indent + StrFontWidth(self.text,self.viewFont);	inherited:?viewSetupFormScript();end
     ,
     _proto: @164 /* protoCheckBox */
    };
AddStepForm(infoBase, MarkCard);
StepDeclare(infoBase, MarkCard, 'MarkCard);




constant |layout_infoSlip| := infoBase;
// End of file infoSlip
// Beginning of file inputOneLine
getOneLineBase :=
    {viewBounds: {left: 0, top: 48, right: 200, bottom: 122},
     Display:
       func(title, label, text, callBackFunc) begin	if visible(inputonelinelink) then inputonelinelink:close();	self.titleVal:=title;	self.labelVal:=label;	self.textVal:=text;	self.callBackFunc:=callBackFunc;	inputonelinelink:open();	end
     ,
     callBackFunc: nil,
     labelVal: nil,
     textVal: nil,
     titleVal: nil,
     viewFlags: 608,
     inLines: 1,
     meResize:
       func()begin	self.viewBounds := Clone(viewBounds);	if callBackFunc = 'message then		viewBounds.bottom := viewBounds.top + 54 + inLines * input.viewLineSpacing;	else		RemoveSlot(self, 'viewBounds);	:SyncView();end
     ,
     viewSetupDoneScript:
       func()begin	self.oneLineBase := self;	input:meAutoSize();	:meResize();end
     ,
     viewSetupChildrenScript:
       func()begin	if callBackFunc <> 'message then begin		bMore.viewFlags := 0;		bLess.viewFlags := 0;		return;	end;	RemoveSlot(bMore, 'viewFlags);	RemoveSlot(bLess, 'viewFlags);	if inLines = 1 then begin		bLess.viewFlags := 0;	end;	else if inLines = 10 then begin		bMore.viewFlags := 0;		bLess.viewBounds := Clone(bMore.viewBounds);		bLess.viewJustify := Clone(bMore.viewJustify);	end;	else begin		RemoveSlot(bLess, 'viewBounds);		RemoveSlot(bLess, 'viewJustify);	end;end
     ,
     _proto: @179 /* protoFloater */
    };

theTitle :=
    {viewBounds: {left: 0, top: -8, right: 224, bottom: 8},
     viewSetupFormScript:
       func() begin	setvalue(thetitle, 'title, titleVal);	inherited:?viewSetupFormScript();		// this method is defined internally	end
       ,
     _proto: @229 /* protoTitle */
    };
AddStepForm(getOneLineBase, theTitle);
StepDeclare(getOneLineBase, theTitle, 'theTitle);



input :=
    {viewBounds: {left: -8, top: 24, right: 196, bottom: 56},
     alwaysCallPickActionScript: true,
     label: nil,
     text: nil,
     viewSetupFormScript:
       func() begin	self.label:=labelVal;	if entryLine and StrFilled(entryLine.text) then self.text := entryLine.text		else self.text:=textVal;	if callBackFunc = 'openStack then	begin		self.viewBounds := Clone(viewBounds);		viewBounds.left := 0;		local cmds := interpreter:getDirList('popUpStack);		ArrayMunger(cmds, 0, 2, nil, 0, nil);		foreach cmd in cmds do			cmd := StrMunger(cmd, StrLen(cmd)-1, nil, nil, 0, nil);		self.labelCommands := cmds;	end;	else if callBackFunc = 'message then	begin		self.viewBounds := Clone(self.viewBounds);		viewBounds.bottom := viewBounds.top + inLines * viewLineSpacing + 4;	end;	inherited:?viewSetupFormScript();		// this method is defined internally	end
       ,
     viewSetupDoneScript:
       func() begin//	:doAda(func() setKeyView(input.entryline, strLen(input.text)), '[], 2);	AddDelayedSend(entryLine, 'SetHilite, [0, 9999, nil,], 0);	inherited:?viewSetupDoneScript();		// this method is defined internally	end
       ,
     viewLineSpacing: 20,
     meAutoSize:
       func()begin	local size := StrFontWidth(entryLine.text, entryLine.viewFont);	local space := entryLine.viewBounds.right - entryLine.viewBounds.left;	if size > space then begin		inLines := Min(10, (size div space) + 1);		oneLineBase:RedoChildren();	end;end
     ,
     _proto: @189 /* protoLabelInputLine */
    };
AddStepForm(getOneLineBase, input);
StepDeclare(getOneLineBase, input, 'input);



getOneLineBase_v163_0 :=
    {viewBounds: {left: -18, top: -18, right: -5, bottom: -5},
     _proto: @163 /* protoLargeClosebox */
    };
AddStepForm(getOneLineBase, getOneLineBase_v163_0);



_defaultButton :=
    {
     buttonClickScript:
       func() begin	if callbackfunc then perform(funcs, callBackFunc, clone([input.entryline.text]));	oneLineBase:close();	end
     ,
     text: "OK",
     viewBounds: {left: -29, top: -18, right: -7, bottom: -5},
     viewJustify: 8390822,
     viewFlags: 515,
     _proto: @226 /* protoTextButton */
    };
AddStepForm(getOneLineBase, _defaultButton);
StepDeclare(getOneLineBase, _defaultButton, '_defaultButton);



bMore :=
    {
     buttonClickScript:
       func()begin	:Hilite(nil);	inLines := Min(inLines + 1, 10);	oneLineBase:RedoChildren();	oneLineBase:meResize();end
     ,
     text: "More",
     viewBounds: {left: 5, top: 0, right: 38, bottom: 0},
     viewJustify: 8400902,
     _proto: @226 /* protoTextButton */
    };
AddStepForm(getOneLineBase, bMore);
StepDeclare(getOneLineBase, bMore, 'bMore);



bLess :=
    {
     buttonClickScript:
       func()begin	:Hilite(nil);	inLines := Max(inLines - 1, 1);	oneLineBase:RedoChildren();	oneLineBase:meResize();end
     ,
     text: "Less",
     viewBounds: {left: 7, top: 0, right: 35, bottom: 0},
     viewJustify: 8401926,
     _proto: @226 /* protoTextButton */
    };
AddStepForm(getOneLineBase, bLess);
StepDeclare(getOneLineBase, bLess, 'bLess);




constant |layout_inputOneLine| := getOneLineBase;
// End of file inputOneLine
// Beginning of file SerialNumber
SerialNumber :=
    {viewBounds: {left: 4, top: 72, right: 184, bottom: 158},
     viewQuitScript:
       // must return the value of inherited:?ViewQuitScript()func() begin	systemEntry.SerialNumber:=number.value;	if not interpreter:commsCheck() then begin		:notify(kNotifyAlert,kAppName,"Incorrect Serial Number.");		:doAda(func() getroot().(kAppSymbol):close(), '[], 214);		end;	inherited:?ViewQuitScript();	end
       ,
     _proto: @180 /* protoFloatNGo */
    };

SerialNumber_v229_0 :=
    {title: "Enter Serial Number",
     viewBounds: {left: 0, top: 0, right: 168, bottom: 24},
     _proto: @229 /* protoTitle */
    };
AddStepForm(SerialNumber, SerialNumber_v229_0);



number :=
    {value: 0,
     maxValue: 99999999,
     minValue: 0,
     viewJustify: 0,
     viewBounds: {left: 0, top: 31, right: 178, bottom: 54},
     showLeadingZeros: TRUE,
     viewSetupFormScript:
       // be sure to call inherited:?ViewSetupFormScript()func()begin	if classOf(systemEntry.serialNumber)='int then value:=systemEntry.serialNumber;	inherited:?ViewSetupFormScript();end
       ,
     _proto: @72 /* protoNumberPicker */
    };
AddStepForm(SerialNumber, number);
StepDeclare(SerialNumber, number, 'number);




constant |layout_SerialNumber| := SerialNumber;
// End of file SerialNumber
// Beginning of file appProto
App :=
    {title: "Application",
     viewBounds: {left: 0, top: 0, right: 200, bottom: 200},
     viewSetupFormScript:
       func() begin	getroot().(kShellSymbol).printFormat:='app;	if title then begin		local progName:=getroot().(kShellSymbol).systemEntry.programName;		if strEqual(title, "Application") and progName and strPos(progName, kExt, 0)			then title:=substr(progName, 0, strPos(progName, kExt, 0));		appTitle.title:=title;		end	else appTitle.viewFlags:=0;	if GOTOinfo or GOSUBinfo then begin		appInfo.GOTO:=GOTOinfo;		appInfo.GOSUB:=GOSUBinfo;		end	else appInfo.viewFlags:=0;			if viewbounds.right=0 then begin		local	x:=getAppParams();		self.viewBounds:={left: x.AppAreaLeft+1, top: x.appAreaTop,					right: x.AppAreaWidth-1, bottom: x.appAreaHeight-3};		end;		if not draggable then		viewFormat:=vfframeBlack+vfFillWhite+vfpen(1);	keepView:=NIL;end
     ,
     keepView: nil,
     viewFlags: 512,
     GetTargetInfo:
       func(targetType) begin	if debug then print("get Target Info");	local theFrame := {		target: {class: kMyMainDataDefSym,  // set unique class (and register viewDefs on this symbol!)						 data: ""},		targetView: self,		appSymbol: kAppSymbol,	};	if debug then print(theFrame);	theFrame;end
       ,
     dontRoute: nil,
     declareSelf: 'base,
     draggable: nil,
     GOSUBinfo: nil,
     GOTOinfo: nil,
     viewQuitScript:
       // must return the value of inherited:?viewQuitScript();func()begin	if debug then print("app.viewQuitScript");	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     _proto: @132 /* protoDragger */
    };

appTitle :=
    {title: "Title",
     viewBounds: {left: -1, top: -1, right: 191, bottom: 15},
     _proto: @229 /* protoTitle */
    };
AddStepForm(App, appTitle);
StepDeclare(App, appTitle, 'appTitle);



appStatus := {_proto: @73 /* newtStatusBarNoClose */};
AddStepForm(App, appStatus);
StepDeclare(App, appStatus, 'appStatus);

appInfo :=
    {viewBounds: {left: 6, top: 2, right: 19, bottom: 15},
     viewJustify: 6,
     viewSetupDoneScript: func() begin	icon:=protoInfoButton.icon;end,
     icon:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 142}),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 142}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 8}]);,
     Goto: nil,
     gosub: nil,
     buttonClickScript:
       func() begin	if debug then print("AppInfo:" && sprintobject(GOTO) && sprintobject(GOSUB));	self.windowspec:={goto: goto, gosub: gosub};	getroot().(kAppSymbol)._rf:userClickAction(nil,self);	end
     ,
     _proto: @198 /* protoPictureButton */
    };
AddStepForm(appStatus, appInfo);
StepDeclare(App, appInfo, 'appInfo);



appClose :=
    {
     buttonClickScript:
       func() begin	if debug then print("protoApp close");	local baseView:=executor;		if getVariable(base, 'goto)=nil and getVariable(base, 'gosub)=nil then return;	if baseView._rf._hideUserViewsRunning then return;	keepView:=TRUE;	baseView._RF:hideUserViews();	keepView:=NIL;	baseView._RF:userClickAction(NIL,base);	if debug then print("protoApp close complete");	inherited:?buttonClickScript();		// this method is defined internally	end
       ,
     _proto: @163 /* protoLargeClosebox */
    };
AddStepForm(appStatus, appClose);



action :=
    {viewBounds: {left: -42, top: 0, right: -25, bottom: 13},
     _proto: @209 /* protoActionButton */
    };
AddStepForm(appStatus, action);






constant |layout_appProto| := App;
// End of file appProto
// Beginning of file scrollerProto
scrollerProto :=
    {viewFlags: 33553920,
     boxTitle: "BoxTitle",
     declareSelf: 'scrollerProto,
     text: "Text",
     viewSetupChildrenScript:
       func() begin   // Everything really happens to NotesView: scrollerProto is just a wrapper   // to preserve values while we morph NotesView   setValue(NotesView,'viewBounds,self:localBox());	if editOK=NIL then editSwitch.viewFlags:=0;	end
       ,
     editflag: nil,
     editOK: TRUE,
     Copyright (c) NSBASICCorp1995: nil,
     smallMountains:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 134}),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 134}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 8}]);,
     bigMountains:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 128}),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 128}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 8}]);,
     viewBounds: {left: 10, top: 10, right: 100, bottom: 100},
     viewClass: 74 /* clView */
    };

NotesView :=
    {viewFlags: 1,
     viewFormat: 337,
     viewSetupChildrenScript:
       func() begin   // The bounds of the children change with  size of NotesView	local x:=self:localbox();	title.viewBounds:=relbounds(0,0,x.right-3*14,14);	if editOK=NIL then title.viewBounds.right:=title.viewBounds.right+13;	setValue(title, 'text, boxtitle);	setValue(NotesBox, 'viewbounds, relbounds(0,x.top+13, x.right, x.bottom-13));	setValue(Notes, 'viewBounds, relbounds(0,0,x.right,1000));	// Adjust display settings for display or edit view	if editFlag=nil then begin // display view		Notes.viewFont:=simpleFont9;		Notes.viewFormat:=bor(Notes.ViewFormat,vfLinesGray)-vfLinesGray;		Notes.viewLineSpacing:=12;		Notes.viewFlags:=vVisible+vReadOnly+vFloating;		EditSwitch.icon:=bigMountains		end	else begin                // edit view		Notes.viewFont:=simpleFont12;		Notes.viewFormat:=bor(Notes.ViewFormat,vfLinesGray);		Notes.viewLineSpacing:=20;		Notes.viewFlags:=vVisible+vAnythingAllowed;		EditSwitch.icon:=smallMountains	endend
       ,
     viewClass: 74 /* clView */
    };
AddStepForm(scrollerProto, NotesView);
StepDeclare(scrollerProto, NotesView, 'NotesView);

editSwitch :=
    {viewBounds: {top: -1, left: -42, right: -28, bottom: 13},
     buttonClickScript:
       func() begin   // toggle between edit view and display view.   // Original bounds are kept in editFlag	if editOK=NIL then return;	notesView:hide();	local x:=getAppParams();	if editFlag=nil then begin // switch to edit view: save bounds		editFlag:=scrollerProto.viewBounds;		setValue(scrollerProto,'viewBounds,			relbounds(x.AppAreaTop+1,x.appAreaLeft+1,x.appAreaWidth-2,			if newtCard then x.appAreaHeight-22									else x.appAreaHeight-2)); 		end	else begin                 // switch back to display view: restore bounds		setValue(scrollerProto,'viewBounds,editFlag);		editFlag:=nil;		end;			setValue(notesView,'viewbounds,scrollerProto:localbox());	notesView:close(); notesView:open();	end
       ,
     viewFormat: 1,
     icon:
       MakePixFamily(
           GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020", resource: 
                 }),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 8}]);,
     viewJustify: 38,
     _proto: @198 /* protoPictureButton */
    };
AddStepForm(NotesView, editSwitch);
StepDeclare(scrollerProto, editSwitch, 'editSwitch);



viewScrollUpScript :=
    {viewBounds: {top: 0, left: -14, right: 0, bottom: 13},
     icon:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 136}),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 136}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 8}]);,
     viewClickScript:
       func(unit)begin   inkOff(unit);   PlaySound(ROM_click);   repeat      NotesBox:scrollMe(-16)   until StrokeDone(unit)end
     ,
     viewFormat: 337,
     viewJustify: 38,
     _proto: @198 /* protoPictureButton */
    };
AddStepForm(NotesView, viewScrollUpScript);
StepDeclare(scrollerProto, viewScrollUpScript, 'viewScrollUpScript);



viewScrollDownScript :=
    {viewBounds: {top: 0, left: -28, right: -14, bottom: 13},
     icon:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 129}),
           nil,
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 129}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u4\u2020",
                   resource: }),bitDepth: 8}]);,
     viewClickScript:
       func(unit)begin   inkOff(unit);   PlaySound(ROM_click);   repeat      NotesBox:scrollMe(16)   until StrokeDone(unit)end
     ,
     viewFormat: 337,
     viewJustify: 38,
     _proto: @198 /* protoPictureButton */
    };
AddStepForm(NotesView, viewScrollDownScript);
StepDeclare(scrollerProto, viewScrollDownScript, 'viewScrollDownScript);



Title :=
    {text: "Static Text",
     viewBounds: {top: 0, left: -2, right: 158, bottom: 13},
     viewFormat: 337,
     viewFont: ROM_fontsystem9bold,
     viewJustify: 8388614,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(NotesView, Title);
StepDeclare(scrollerProto, Title, 'Title);



NotesBox :=
    {viewFlags: 33,
     viewFormat: 337,
     viewBounds: {left: 9, top: 25, right: 185, bottom: 177},
     ScrollMe:
       func(deltaY)begin   local y:=viewOriginY+deltaY;   if y>yMax then y:=yMax;   if y<0 then y:=0;   :setOrigin(viewOriginX,y);   :dirty();   refreshViews()end
     ,
     viewOriginX: 0,
     viewOriginY: 0,
     viewSetupDoneScript: func()begin   yMax:=20000;end,
     yMax: 0,
     viewClass: 77 /* clEditView */
    };
AddStepForm(NotesView, NotesBox);
StepDeclare(scrollerProto, NotesBox, 'NotesBox);

Notes :=
    {viewFlags: 33553925,
     viewFormat: 1,
     viewLineSpacing: 12,
     viewFont: simpleFont9,
     viewBounds: {left: 9, top: 9, right: 169, bottom: 145},
     viewClass: 81 /* clParagraphView */
    };
AddStepForm(NotesBox, Notes);
StepDeclare(scrollerProto, Notes, 'Notes);








constant |layout_scrollerProto| := scrollerProto;
// End of file scrollerProto
// Beginning of file userView
view :=
    {viewBounds: {left: 48, top: 168, right: 176, bottom: 216},
     viewFormat: 337,
     viewFont: simpleFont9+tsBold,
     viewFlags: 544,
     viewJustify: 0,
     text: "",
     viewClickScript:
       func(unit) begin	if debug then print ("userView Click: GOTO" && sPrintObject(goto));	inkOff(unit);	if goto=nil and gosub=nil then return;		playSoundSync(ROM_click);	getroot().(appSymbol)._rf:userClickAction(unit,self);	end
     ,
     styleFrame: nil,
     viewDrawScript:
       func() if drawing and length(drawing)>0 then :drawDrawing(),
     windowSpec: nil,
     drawDrawing:
       func() begin	if debug then print("doDrawing");	:lockScreen(TRUE);	:drawShape(drawing, styleFrame);	:lockScreen(NIL);	refreshviews();	end
     ,
     _proto: @218 /* protoStaticText */
    };


constant |layout_userView| := view;
// End of file userView
// Beginning of file progressFloater
progressFloater :=
    {viewBounds: {left: 0, top: 22, right: 204, bottom: 114},
     updateValue:
       func(title1, title2, value) 	if value then begin		if debug then print("Setting progress to " & value);		setValue(name, 'text, title1);		setValue(status, 'text, title2);		setValue(gauge, 'viewValue, value);		self:dirty();		refreshviews();		end	else self:close();
     ,
     viewFlags: 64,
     _proto: @179 /* protoFloater */
    };

Name :=
    {text: "",
     viewBounds: {left: 22, top: 10, right: 182, bottom: 26},
     viewFont: simpleFont10 + tsbold,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(progressFloater, Name);
StepDeclare(progressFloater, Name, 'Name);



gauge :=
    {viewBounds: {left: 22, top: 38, right: 182, bottom: 50},
     viewSetupFormScript: func() begin	viewValue:=0;end,
     viewValue: 50,
     _proto: @182 /* protoGauge */
    };
AddStepForm(progressFloater, gauge);
StepDeclare(progressFloater, gauge, 'gauge);



Status :=
    {text: "",
     viewBounds: {left: 22, top: 62, right: 182, bottom: 78},
     viewFont: simplefont9,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(progressFloater, Status);
StepDeclare(progressFloater, Status, 'Status);




constant |layout_progressFloater| := progressFloater;
// End of file progressFloater
// Beginning of text file Comms Data
// Constants used by BITconstant kRev:="1.01";// Event codes used by systemconstant kEventToolSpecific	:= 1;constant kEventDisconnect	:= 2;constant kEventRelease		:= 3;// Application stateconstant kStateIdle			:= 0;constant kStateConnected	:= 1;// I/O typesconstant kIOTypeTCPIndex		:= 0;					// i.e. streamed dataconstant kIOTypeUDPIndex		:= 1;					// i.e. framed dataDefConst('kDefaultIOTypeChoices, ["TCP","UDP"]);// Defaults for inet endpointconstant kDefaultIOTypeIndex	:= kIOTypeTCPIndex
£Gø£GÀ;constant kDefaultLinkId := 1;SetLocalizationFrame({	english: '{},});partData:={};constant kMaxReceiveBufferSize := 8000;  // set arbitrary max buf size...// constants used by IOconstant kCommstrace:=TRUE;// communcations constantsconstant kState_Disconnected := 0;	// ready-to-go (default state)constant kState_Connecting := 1;	// in-process of (asynchronous) connectconstant kState_Connected := 2;		// connected (requires disconnect)constant kState_Disconnecting := 3;	// in-process of
£Gø£GÀ (asynchronous) disconnectdefconst('kcomms,	{bps: {name: [300,600,1200,2400,4800,7200,9600,12000,14400,19200,38400,57600,115200,230400],			 value: [k300bps,k600bps,k1200bps,k2400bps,k4800bps,k7200bps,k9600bps,k12000bps,			 			k14400bps,k19200bps,k38400bps,k57600bps,k115200bps,k230400bps]},	 dataBits: {name: [5,6,7,8],	 				value: [k5DataBits,k6DataBits,k7DataBits,k8DataBits]},	 stopbits: {name: [0,1,2],	 				value: [k1stopBits,k1pt5stopBits,k2stopBits]},	 parity:	  {name: ["no","odd","even"
£Gø£GÀ],	 				value: [kNoParity,kOddParity,kEvenParity]}	});defconst('kSerialOptions, [			{	label: kCMSAsyncSerial,				type: 'service,				opCode: opSetRequired,				result: nil	},						{	label: kCMOSerialHWChipLoc,				type: 'option,				opCode: opSetRequired,				result: nil,				form: 'template,				data:	{   // services can be kHWLocExternalSerial, kHWLocBuiltInIR, kHWLocPCMCIASlot1					argList: ["extr", 0],					typeList: ['struct, ['array, 'char, 4], 'ulong	],	},	},								{ label: kCMOSer
£Gø£GÀialBuffers,				type: 'option,				opcode: opSetRequired,				data: {arglist: [256, 2048, 8], // out, in, error chars				       typeList: ['struct, 'ulong, 'ulong, 'ulong]}},						{	label:		kCMOSerialIOParms,				type:		'option,				opCode:		opSetRequired,				result:		nil,				form:		'template,				data:	{					arglist:	[k1StopBits,kNoParity,k8DataBits,k9600bps],								typelist:	['struct,'long,'long,'long,'long]	}	},		// bps						{	label:		kCMOInputFlowControlParms,				type:		'option,				op
£Gø£GÀCode:		opSetRequired,				result:		nil,				data:	{					arglist:	[						unicodeDC1, 			// xonChar							unicodeDC3, 			// xoffChar							true, 					// useSoftFlowControl							nil, 					// useHardFlowControl							0, 						// not needed; returned							0,	], 					// not needed; returned						typelist:	['struct,						'byte,					// XON character						'byte,					// XOFF character						'boolean,				// software flow control						'boolean,				// hardware flow control						'boolean,				// hardw
£Gø£GÀare flow blocked						'boolean,	],	},	},	// software flow blocked			{	label:		kCMOOutputFlowControlParms,				type:		'option,				opCode:		opSetRequired,				result:		nil,				form:		'template,				data:	{					arglist:	[						unicodeDC1, 			// xonChar							unicodeDC3, 			// xoffChar							true, 					// useSoftFlowControl							nil, 					// useHardFlowControl							0, 						// not needed; returned							0,	], 					// not needed; returned						typelist:	['struct,						'byte,					// XON cha
£Gø£GÀracter						'byte,					// XOFF character						'boolean,				// software flow control						'boolean,				// hardware flow control						'boolean,				// hardware flow blocked						'boolean,	],	},	},	// software flow blocked		]);		defconst('kModemOptions,		[			{	label:		kCMSModemID,			// "mods"				type:		'service,				result:		nil,				opCode:		opSetRequired	},		// 512						{	label:		kCMOModemECType,		// "mecp"				type:		'option,				opCode:		opSetNegotiate,			// 256				result:		nil,				form
£Gø£GÀ: 		'template,				data:	{					arglist:[						0,	],					typelist:['struct,						'ulong,	],	},	},						{	label:		kCMOMNPCompression,		// "mnpc"				type:		'option,				opCode:		opSetNegotiate,			// 256				result:		nil,				form: 		'template,				data:	{					arglist:[						kMNPCompressionV42bis + kMNPCompressionMNP5 + kMNPCompressionNone,	],	// 0000 0000 0000 1011					typelist:['struct,						'ulong,	],	},	},		]);
e:		'option,				opCode:		opSetNegotiate,			// 256				result:		nil,				form
// End of text file Comms Data
// Beginning of file commsUnit
commsMain :=
    {ConnectedTo: nil,
     viewSetupDoneScript: func() begin	epArray:=[];	end,
     connectedToEP: nil,
     MMessage:
       func(message) if kCommsTrace then	begin	print("M:" && message);	if vMessage then SetValue(vMessage, 'text, Clone(message & unicodeCR & vMessage.text));	RefreshViews();	end
     ,
     viewFormat: 83951872,
     ioInput:
       func(s) begin	if kcommsTrace then :MMessage("input:" && s);	//if program not running, convert to 'string if needed	if getroot().(AppSymbol)._mainRF._runState=NIL		 and classOf(s)<>'string then begin		 	local str:="";		 	for i:=0 to length(s)-1 do str:=str & extractChar(s,i);		 	s:=str		 	end;	//trim backspaces in string input	if classOf(s)='string then begin		local p;		while (p:=strPos(s,BS,0)) do // trim out Backspaces			if p<=1 then s:=substr(s,p+1,nil);							else s:=substr(s,0,p-1) & substr(s,p+1,nil);		end;	else setClass(s,'binary);	if getroot().(AppSymbol)._mainRF._runState=NIL		then getroot().(AppSymbol).editor:handleInputLine(clone(s));		else getroot().(AppSymbol).editor:handleInput(clone(s));end
       ,
     viewQuitScript:
       func()begin	foreach ep in epArray do :ioDisconnect(ep);end,
     ioConnectDone:
       func(ep,options, result) begin	// SELF is the endpoint frame	if kCommsTrace then :MMessage("ioConnectDone");	if result then begin		:ioNotifyError(result);		ep:ioDisconnect(ep);		return;		end;			if kCommsTrace then :MMessage("Connection Complete");	:ioSetState(ep,kState_Connected);	:ioResetConnection(ep,nil);	local service:=intern(getroot().(AppSymbol).systemEntry.io);	local connectMsg:=getroot().(AppSymbol).systemEntry.(service).connect;	if strLen(connectMsg)>0 then :ioPrint(ep, connectMsg);	end
       ,
     viewFlags: 1,
     ioPrint:
       func(ep, data) begin	if kCommsTrace then :MMessage("Print:" && data);	if ep.fEndPointState<>kState_Connected then return :ioNotifyError(35);				try ep:Output(data, nil,ep.fOutputSpec)	onexception |evt.ex.comm| do		ep:ExceptionHandler(CurrentException());end
     ,
     ReorientToScreen: ROM_defRotateFunc,
     viewBounds: {left: 42, top: -10, right: 178, bottom: 254},
     viewJustify: 80,
     ioConnect:
       func(service, Options) begin	if kCommsTrace then vMessage:open();	:MMessage("Connecting to" && service);	// set up endpoint frame	local ep:=:ioBuildEndPoint(service, options);	if NOT ep then return;		// instantiate and bind		if kCommsTrace then :MMessage("instantiate:" && service);		:ioSetState(ep,kState_Connecting);	try ep:Instantiate(ep, ep.fEndPointOptions)	onexception |evt.ex.comm| do begin			:ioNotifyError(CurrentException().error);			:ioSetState(ep,kState_Disconnected);			:ioSetEpToScre();			return;			end;		if kCommsTrace then :MMessage("Bind");	try ep:Bind(nil, nil)	onexception |evt.ex.comm| do begin			:ioNotifyError(CurrentException().error);			:ioSetState(ep, kState_Disconnected);			ep:Dispose();			:ioSetEpToScre();			return;			end;		RegPowerOff(AppSymbol,		func(what, why)	begin	// we create the closure here so as to set up SELF as the endpoint frame in the closure			if kCommsTrace then :MMessage(sprintObject(what) && sprintobject(why));			if why='idle then return NIL;			if what = 'okToPowerOff then begin				if fEndPointState = kState_Disconnected then	// unless the user or an application explicitly						return true;								// wants it to sleep				end;							else if what = 'powerOff then begin				if fEndPointState <> kState_Disconnected then begin // connected then begin the disconnect process						fPowerOffState := 'holdYourHorses;		// set a flag to indicate we're powering down						:ioDisconnect(ep);						return 'holdYourHorses;						end;			end;								nil;	// ALWAYS return nil here!			end);		if KcommsTrace then :MMessage("connect");	try begin		:ioSetState(ep,kState_Connecting);		ep:Connect([ep.fConnectAddress],							{	async:true,								reqTimeout:	45000,	// 45 seconds								completionScript:	func(ep, options, result)										ep:ioConnectDone(ep,options,result)});		end	onexception |evt.ex.comm| do begin			:ioNotifyError(CurrentException().error);			:ioDisconnect(ep);		end;	if kCommsTrace then :MMessage("ioConnectAction Complete");	addArraySlot(epArray, ep);	return ep;end
       ,
     ioSetEpToScre:
       func() begin	:MMessage("Set back to screen");	local bv:=getroot().(AppSymbol);	bv.systemEntry.io:="scre";	bv.connectedTo:="scre";	bv.connectedToEp:=nil;	bv.editor.state:=1;	bv.connect.entryLine.Text:="screen";	self:close()end
     ,
     ioDisconnectDone:
       func(ep, options, result)	begin	if kcommsTrace then :MMessage("unbind");	try ep:UnBind(nil)	onexception |evt.ex.comm| do nil;		if kcommsTrace then :MMessage("dispose");	try ep:Dispose()	onexception |evt.ex.comm| do nil;			:?ioSetState(ep,kState_Disconnected);		if fPowerOffState then begin			fPowerOffState := nil;			PowerOffResume(AppSymbol);		end;	UnRegPowerOff(AppSymbol);end
     ,
     ioExceptionHandler:
       func(exceptionFrame) begin // SELF is the endpoint frame	if kcommsTrace then :MMessage("exception:");	if kcommsTrace then print(exceptionFrame);	if exceptionFrame	and exceptionFrame.data	and exceptionFrame.data <> -16005 then				// ignore -16005 (just the result of calling Cancel)		if exceptionFrame.data = -18003 then begin		// I/O buffer overrun				AddDeferredCall(func(ep) ep:ioResetConnection(ep,true), [self]);				:ioNotifyError(exceptionFrame.data);				end;		else begin // handle all other (unexpected) exceptions by disconnecting the endpoint				AddDelayedCall(func(ep) :ioDisconnect(ep), [self], 1000);				:ioNotifyError(exceptionFrame.data);				end;		true;end
       ,
     ioSetState:
       func(ep, newState) begin	ep.fEndPointState := newState;	if kCommsTrace then :MMessage("new state:" && newState);	end
     ,
     ioBuildEndPoint:
       func(service, options) begin	local pos;	// set up endpoint frame	local ep:={_proto: protoBasicEndpoint,						 _parent: self,						 exceptionHandler: ioExceptionHandler,						 fConnectAction: nil,						 fConnectAddress: nil,						 fPowerOffState: nil,						 fEndPointState: kState_Disconnected,						 fOutputSpec: {form: 'string},						 };	ep.fInputSpec:={form:'string,		termination:	{	endSequence:	[unicodeCR],	},		discardAfter:	2048,		inputScript:	func(ep, data, terminator, options) begin					ep:MMessage("inputScript Called");					ep:ioInput(data) end,		completionScript: func(ep, options, result) begin					if kCommsTrace then ep:MMessage("CompletionScript Called with result" & sPrintObject(result));					if ep.fEndPointState<>kState_Connected then return;					if result=-16005						then ep:ioInput("TIMEOUT -16005")						else ep:ioInput(sprintobject(result)) end };							// set up options	if strEqual(service,"mmnp")		then ep.fEndPointOptions:=deepclone(kModemOptions)		else ep.fEndPointOptions:=deepclone(kSerialOptions);		local EO:=ep.fEndPointOptions;		// Set up serial service		pos := ArrayPos(EO, kCMOSerialHWChipLoc, 0, func(a,b) StrEqual(a,b.label));	if pos then EO[pos].data.arglist[0]:=service;	// now, customize serial line settings	pos := ArrayPos(EO, kCMOSerialIOParms, 0, func(a,b) StrEqual(a,b.label));	if pos and options and options.data and length(options.data)=4 then begin		local data:=options.data;		local argList:=EO[pos].data.arglist;		for i:=0 to length(kcomms.bps.name)-1 do			if kcomms.bps.name[i]=data[0] then arglist[3]:=kcomms.bps.value[i];       				for i:=0 to length(kcomms.dataBits.name)-1 do			if kcomms.dataBits.name[i]=data[1] then arglist[2]:=kcomms.dataBits.value[i];       				for i:=0 to length(kcomms.stopBits.name)-1 do			if kcomms.stopBits.name[i]=data[2] then arglist[0]:=kcomms.stopBits.value[i];       				for i:=0 to length(kcomms.parity.name)-1 do			if strEqual(kcomms.parity.name[i],data[3]) then arglist[1]:=kcomms.parity.value[i];		end;			// now, customize inputSpec	if kCommstrace then begin		print("customizing inputSpec");print(options); end;	if options and options.input then		foreach slot, value in options.input			do ep.fInputSpec.(slot):=value;		// Customize modem options			if strEqual(service,"mmnp")	then begin		// set the negotiated error correction protocol (hardware and/or software and/or none)		pos:=ArrayPos(EO, kCMOModemECType, 0, func(a,b) StrEqual(a,b.label));		if pos then begin			if options.SWflow or options.HWflow then begin				EO[pos].data.arglist[0] := 0;				if options.HWflow 						then EO[pos].data.arglist[0]:=Bor(EO[pos].data.arglist[0], kModemECProtocolExternal);				if options.SWflow 						then EO[pos].data.arglist[0]:=Bor(EO[pos].data.arglist[0], kModemECProtocolMNP);				end			else EO[pos].data.arglist[0] := kModemECProtocolNone;			end;		try ep.fConnectAddress:=makePhoneOption(options.phone)		onException |evt.ex| do begin			:ioNotifyError(34);			return NIL;			end;	end;	epend
       ,
     ioNotifyError:
       func(error) begin	if kCommsTrace then :MMessage("NotifyError:" && error);	if not error then return;	local errMsg;				 if error = -10017 then errMsg:=kErrorM25;	else if error = -10008 then errMsg:=kErrorM26	else if error = -10078 then errMsg:=kErrorM23		else if error = -16009 then errMsg:=kErrorM30	else if error = -16013 then errMsg:=kErrorM22		else if error = -16022 then errMsg:=kErrorM24		else if error = -18003 then errMsg:=kErrorM21	else if error = -20003 then errMsg:=kErrorM33	else if error = -20006 then errMsg:=kErrorM31	else if error = -24000 then errMsg:=kErrorM27	else if error = -24001 then errMsg:=kErrorM28	else if error = -24002 then errMsg:=kErrorM29	else if error = -24003 then errMsg:=kErrorM30	else if error = -24004 then errMsg:=kErrorM29	else if error = -24005 then errMsg:=kErrorM27	else if error = -24006 then errMsg:=kErrorM32	else if error = -24007 then errMsg:=kErrorM27			else if error = -38001 then errMsg:=kErrorM20		else if error = 34     then errMsg:=kErrorM34		else if error = 35     then errMsg:=kErrorM35		else GetRoot():Notify(kNotifyAlert, kAppName, 		"An unexpected communications error has occured.  Error code = " & NumberStr(error));	AddDelayedCall(func(ep) :iosetEpToScre(), [self], 1000);	local bv:=getroot().(AppSymbol);	if NOT bv.screenview then return;	:doAda(func() bv.screenview:error(errMsg), '[], 1010);	if NOT bv._mainRF._runState 		then :doAda(func() bv.editor:addLines([bv.editor:prompt()]), '[], 1013);end
     ,
     epArray: [],
     viewClass: 74 /* clView */,
     ioResetConnection:
       func(ep, cancel)	begin	if ep.fEndPointState <> kState_Connected then return;		if cancel then		try ep:Cancel(nil)		onexception |evt.ex.comm| do nil;	if kCommsTrace then :MMessage("Setting Input Spec");		ep:SetInputSpec(ep.fInputSpec);end
     ,
     ioDisconnect:
       func(ep) begin	if kcommsTrace then :MMessage("ioDisconnect");	if not ep then return;	if ep.fEndPointState <> kState_Connected		and ep.fEndPointState <> kState_Connecting then return;			local fromState := ep.fEndPointState;	:ioSetState(ep,kState_Disconnecting);	if kcommsTrace then :MMessage("Cancel");	try ep:Cancel(nil)	onexception |evt.ex.comm| do nil;		if kcommsTrace then :MMessage("Disconnect");	if fromState = kState_Connected then		try ep:Disconnect(true, {	async:				true,								// reqTimeout:		3600,								completionScript:	func(ep, options, result)													ep:ioDisconnectDone(ep, options, result),	})		onexception |evt.ex.comm| do			:ioDisconnectDone(ep, nil, CurrentException().error);	else :ioDisconnectDone(ep, nil, nil);end
       
    };

vMessage :=
    {viewBounds: {left: 1, top: 5, right: 139, bottom: 263},
     viewJustify: 0,
     viewFormat: 256,
     viewFont: simpleFont9,
     text: "",
     viewFlags: 66,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(commsMain, vMessage);
StepDeclare(commsMain, vMessage, 'vMessage);




constant |layout_commsUnit| := commsMain;
// End of file commsUnit
// Beginning of text file Inet Constants
// Constants for using the Newton Internet Enabler// Copyright (c) 1994-1995 Apple Computer, Inc.  All rights reserved.// Transport service type constantsconstant kTCP := 1;constant kUDP := 2;// Utility functions for Internet applicationsDefConst('kNumtoHostAddr,func(addr)begin	// This is the inverse of HostAddrToNum	// It converts a 4 byte array to a "w.x.y.z" string.	local index, str := "";	// A sanity check	if Length(addr) <> 4 then begin		return nil;	end;	for index := 0 to Length(a
£Gø£GÀddr) - 1 do begin		str := str & NumberStr(addr[index]);		if index < Length(addr) - 1 then			str := str & ".";	end;	return str;end);DefConst('kHostAddrToNum,func(str)begin	// This is the inverse of NumToHostAddr	// It converts a "w.x.y.z" string to a 4 byte array.	// Actually the separators between the numbers can be any non-digits, except space	local index := 0, partCnt := 0;	local subNum := 0, digits := "0123456789 ";	local num := [0,0,0,0], processNum;	for index := 0 to StrLen(str
£Gø£GÀ) - 1 do begin		ch := StrPos(digits, SubStr(str, index, 1), 0);		if not ch then begin			// If first character is not a digit then skip junk at beginning			if index = 0 then processNum := nil;			// Not a digit.  Process number, unless skipping junk			if processNum then begin				// Truncate numbers greater than 255				if subNum > 255 then subNum := 255;				if partCnt < 4 then					num[partCnt] := subNum;				partCnt := partCnt + 1;				subNum := 0;				processNum := nil;			end;		end else be
£Gø£GÀgin			// Add the next digit to subNum (unless it was a space)			if ch < 10 then				subNum := subNum * 10 + ch;			processNum := true;		end;	end;	// Truncate numbers greater than 255	if subNum > 255 then subNum := 255;	// Do the last part (which usually won't have a trailing .)	if subNum <> 0 and partCnt < 4 then		num[partCnt] := subNum;	return num;end);DefConst('kIsIPAddr,func(str)begin	// This returns true if the string is an IP address (as opposed to a domain name)	// cheap tes
£Gø£GÀt now just tests if the string ends with a numeric character	local digits := "0123456789";	local len := strLen(str);	if len > 0 and  StrPos(digits, SubStr(str, len - 1, 1), 0) then		true	else 		nil;end);DefConst('kPortAddrStruct, [		'struct,		['array,'byte,4],		'short	]);	DefConst('kPortAddrData,{	arglist:		[		[0,0,0,0],		0,	// destination port number						],	typelist: kPortAddrStruct,});// Use this to get Instantiate options// protocol must be kSLIP or kPPPDefConst('kGe
£Gø£GÀtEndpointConfigOptions, func(linkID,protocol) 	return [		{				label:	"inet",			type:		'service,			opCode:	opSetRequired,			result:	nil,			},		{				label:	"ilid",			// set the link id			type:		'option,			opCode:	opSetRequired,			result:	nil,			form:		'template,			data:				{				arglist:					[					linkID				],				typelist:				[					'struct,					'ulong				],				},		},		{				label:	"itsv",			// set the transport protocol (TCP or UCP)			type:		'option,			opCode:	opSetRequired,
£Gø£GÀ			result:	nil,			form:		'template,			data:				{				arglist:					[					protocol					],				typelist:				[					'struct,					'ulong				],				},		},	]);DefConst('kUDPReceiveOptions,	[				{				label:	"iuds",			// get the UDP destination socket			type:		'option,			opCode:	opGetCurrent,			result:	nil,			form:		'template,			data: 	kPortAddrData,			},		{				label:	"iuss",			// get the UDP source socket			type:		'option,			opCode:	opGetCurrent,			result:	nil,			form:		'templat
£Gø£GÀe,			data:		kPortAddrData,		},	]);		DefConst('kINetBindOptions,func(localPort,useDefaultPort) begin		return [			{					label: "ilpt",				// set the local port				type: 'option,				opCode: opSetRequired,				result: nil,				form: 'template,				data:					{					arglist:						[						localPort,			// local port number						useDefaultPort	// use default port														],					typelist:					[						'struct,						'short,						'boolean					],					},			},		];end);DefConst('kTCPC
£Gø£GÀonnectOptions, func(remoteAddr,remotePort) begin			return [				{						label:	"itrs",			// set the TCP remote socket					type:		'option,					opCode:	opSetRequired,					result:	nil,					form:		'template,					data:						{						arglist:							[							remoteAddr,							remotePort,		// remote port number																],						typelist: kPortAddrStruct,					},				},			];	end);			DefConst('kTCPListenOptions,			[				{						label:	"itrs",			// get the TCP remote socket					type:		'op
£Gø£GÀtion,					opCode:	opGetCurrent,					result:	nil,					form:		'template,					data:	kPortAddrData,				},			];	);			DefConst('kGetIPAddressesOptions,	[{         type    : 'option,         label   : "iprf",         opCode: opGetCurrent,         data    : {                  arglist: [                  		[0,0,0,0],                  		[0,0,0,0],                   ],                   typelist: [                   		'struct,                   		['array,'byte,4],                   		['arr
£Gø£GÀay,'byte,4],                   ]           }     }]);		DefConst('kUDPPutBytesOptions,func(addr,port) begin		return	[{					label:	"iuds",			// set the UDP destination socket				type:		'option,				opCode:	opSetRequired,				result:	nil,				form:		'template,				data:					{					arglist:						[						addr,						port,		// remote port number														],					typelist: kPortAddrStruct,				},			}];	end);		
 		'struct,                   		['array,'byte,4],                   		['arr
// End of text file Inet Constants
// Beginning of file BITUnit
NetTest :=
    {
     MCallbackSend:
       func(options,error)begin	if error and error <> -16005	then begin		// skip error dialog for cancelled requests		:MNotifyError("Send completionScript called",error);		:MDisconnect();	end;	:MputdataInStatusArea("Data Sent");end
       ,
     fLinkStatus: 'idle,
     MPutDataInReceivedArea:
       func(str) begin	if fReceiveBuffer = nil then :MResetReceiveBuffer();	if strLen(fReceiveBuffer) < kMaxReceiveBufferSize then begin		fReceiveBuffer := fReceiveBuffer & str;		fReceiveBufferLen := strlen(fReceiveBuffer);	end else begin		if not fBufFullNotified then begin			:MNotify("Receive buffer full");			fBufFullNotified := true;		end;	end;end
     ,
     fStatusView: nil,
     fConfigListen: nil,
     viewFormat: 0,
     fProtocol: 'echo,
     viewQuitScript: func() :cleanup(),
     MCallBackCancelDNS:
       func()begin		fDNSPending := nil;		fStatusView := InetDisplayStatus(fConfigLinkID,fStatusView,nil);  // close the status view.		:MDisconnect();  // release the link, since we did not contact anyone...end
       ,
     Send:
       func(sendTxt) begin	if fEndpointState <> kStateConnected then return (:MNotify("Not connected!"));	:MResetReceiveBuffer();	fEndpoint:MOutputHandler(sendTxt);	end
     ,
     MConnect:
       func()begin	fError:=0;	if fEndpointState = kStateConnected then		return :MNotify("Already connected!");	if fAppBase=NIL then :setup();	:MResetReceiveBuffer();	InetOpenConnectionSlip(nil,self,'MCallBackSlip);	end
     ,
     target: { class: 'text, text: "" },
     fAppBase: nil,
     MResetReceiveBuffer:
       func()begin	fReceivedCount := 0;	fBufFullNotified := nil;  // notify when buffer is full	fReceiveBufferLen := 0;	fReceiveBuffer := "";  // end
       ,
     viewFlags: 1,
     receive:
       func() begin	local rData:=clone(fReceiveBuffer);	:MResetReceiveBuffer();	return rData;end
     ,
     fDNSPending: nil,
     fConfigLPortDefault: nil,
     fEndpointProto:
       {	_proto:				protoBasicEndpoint,		fIOTypeIndex:		0,	fRemoteIPAddr:    nil,  // holds the resolved ip addr as a numeric array		exceptionHandler:	func(exception)		begin	      local error := -1; // unknown error  			if HasSlot(exception, 'error) then   			error := exception.error;      		else if HasSlot(exception.data, 'errorCode) then   			error := exception.data.errorCode;   						if error <> -16005	then	begin	// skip error dialog for cancelled requests				:MNotifyError("Endpoint exception occurred.", error);				:MDisconnect();			end;						return true;		end,		eventHandler:		func(event)		begin			if kDebugOn then				begin					Print("Inet event! service: " & event.serviceID && "eventCode: " & event.eventCode && "data: " & event.data);				end;										//if StrFilled(event.serviceID) AND StrEqual(event.serviceID,kInetCCEServiceOptLabel) then				begin					if event.eventCode = kEventDisconnect					or event.eventCode = kEventRelease then						begin							if kDebugOn then Print("Disconnected!");							// fEndpointState := kStateIdle;							:MPutDataInStatusArea("Disconnected...");							:MDisconnect();						end;					else if event.eventCode = kEventToolSpecific then						begin							if event.data < 0 then begin								:MNotifyError("Endpoint error event occurred.", event.data);								:MDisconnect();							end else begin								:MPutDataInStatusArea("Received Expedited data > " & event.data);							end;						end;										// else ignore the event			  					end;		end,		fStreamOutputSpec:	{	form:			'string,							async:  		true,							completionScript: func(ep, options, result)								begin									ep:MCallbackSend(options,result);									if kdebugOn then begin										print("StreamOutput completion");										end								end,						},	fStreamInputSpec:	{	form:			'string,							termination:	{	endSequence:	UnicodeLF},  // LFs already filtered out....							discardAfter:	256,							//filter: {							//	byteProxy: {							//		byte: unicodeLF,  // strip LineFeeds because newt does not use them							//		proxy: nil,							//	}								//},														inputScript:	func(ep, data, terminator, options)								begin									if kdebugOn then begin 										print("inputScript called");										print(data);										end;									//SetVariable(ep,'fReceivedCount,GetVariable(ep,'fReceivedCount)+StrLen(data));									//ep:MPutDataInStatusArea(ParamStr("Received ^0 bytes",[fReceivedCount]));									ep:MPutDataInStatusArea("Received data");									ep:MPutDataInReceivedArea(data);									// echo back input data if listening on port 7.									if getVariable(ep,'fConfigListen) and getVariable(ep,'fConfigLPort) = 7 then begin											if kdebugon then print ("Echoing input packet");											ep:Output(data,nil, ep.fStreamOutputSpec);									end;								end,																completionScript: func(ep, options, result)								begin									if kdebugOn then										begin										print("completionScript called!");										print(options);										print(result);										end;																		if result <> -16005	then	begin	// skip error dialog for cancelled requests										ep:MNotifyError("Stream completionScript called" ,result);										ep:MDisconnect();									end;								end,						},		fPacketOutputSpec:	{	form:			'string,							sendFlags:		kPacket + kEOP,							async:  		true,							completionScript: func(ep, options, result)								begin									ep:MCallbackSend(options,result);								end,															},								fPacketInputSpec:	{	form:			'string,							discardAfter:	256,							rcvFlags:		kPacket,							rcvOptions: 	kUDPReceiveOptions,							termination:	{	useEOP:	true	},							//filter: {							//	byteProxy: {							//		byte: unicodeLF,  // strip LineFeeds because newt does not use them							//		proxy: nil,							//	}								//},							inputScript:	func(ep, data, terminator, options)								begin									if options then begin										local rmAddr := options[0].data.argList[0]; 										local rmPort := options[0].data.argList[1]; // 4										local rmAddrStr := call kNumToHostAddr with (rmAddr);										local str := "Packet received from" && rmAddrStr && "port" && rmPort;									end else										local str := "Packet received";													ep:MPutDataInStatusArea(str);									ep:MPutDataInReceivedArea(data);									// must repost input spec to keep processing the options									ep:SetInputSpec(ep.fPacketInputSpec);																		// echo back input data if listening on port 7.									if getVariable(ep,'fConfigListen) and getVariable(ep,'fConfigLPort) = 7 then begin											if kdebugon then print ("Echoing input packet");											local putBytesOptions := call kUDPPutBytesOptions with (rmAddr,rmPort);											ep:Output(data, putBytesOptions, ep.fPacketOutputSpec);									end;								end,															completionScript: func(ep, options, result)								begin									if kdebugOn then										begin										print("completionScript called!");										print(result);										end;									if result <> -16005	then begin		// skip error dialog for cancelled requests										ep:MNotifyError("Packet completionScript called",result);										ep:MDisconnect();									end;								end,						},			MOutputHandler:	func(sendTxt)		begin			local theOutPut := sendTxt & unicodeCR & unicodeLF;			if kdebugOn then begin				print("Output Handler called");				print(theOutPut);				end;			try				if fIOTypeIndex = kIOTypeTCPIndex then					:Output(theOutput, nil, fStreamOutputSpec);									else if fIOTypeIndex = kIOTypeUDPIndex then begin					local putBytesOptions := call kUDPPutBytesOptions with (fRemoteIPAddr,fConfigRPort);					:Output(theOutput, putBytesOptions, fPacketOutputSpec);					if debugOn then print("Output Completed");				end else				  :MNotify("Illegal value for fIOTypeIndex: " & NumberStr(fIOTypeIndex));				  			onexception |evt.ex.comm| do				:MNotifyError("Endpoint output failed.", CurrentException().error);		end,			MSetInputSpec: func()		begin			if kdebugOn then print("Setting Input Spec:");			local spec := nil;			try				if fIOTypeIndex = kIOTypeTCPIndex then					spec := fStreamInputSpec;				else if fIOTypeIndex = kIOTypeUDPIndex then					spec := fPacketInputSpec;				else				  :MNotify("Illegal value for fIOTypeIndex: " & NumberStr(fIOTypeIndex));				:SetInputSpec(spec);			onexception |evt.ex.comm| do				begin					:MNotifyError("Endpoint SetInputSpec failed.", CurrentException().error);					ReThrow();				end;		end,		}
       ,
     MCallbackGrab:
       func(LinkID, newStatus, err)begin	if err AND kDebugOn then Print("callbackGrab err: " & err);	fConfigLinkID := LinkID; //just to make sure it's set		fLinkStatus := newStatus.linkStatus;	if err then begin		if newStatus.scriptLog then			:MPutDataInReceivedArea(newStatus.scriptLog);		return :MNotifyError("GrabLink Failed.",err);	end;	if newStatus.linkStatus <> 'Connected then begin		InetDisplayStatus(fConfigLinkID,fStatusView,newStatus);		return;  // have not found completed link yet, just update status 	end;   if kdebugOn then print("Link grabbed (" & fConfigLinkID & ")");   fLinkGrabbed := true;   // flag that we have grabbed a link...	local statusFrame := {		statusText: "Looking up host", 		titleText: fConfigRAddr,	};	InetDisplayStatus(fConfigLinkID,fStatusView,statusFrame);		fDNSPending := true; // remember that we have a dns request out there...	DNSGetAddressFromName(fConfigRAddr,self,'MCallBackDNS);end
       ,
     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     MCallBackDNS:
       func(answers,error)begin	fDNSPending := nil;  	if not error and length(answers) > 0 then begin		fEndpoint :=	{				_proto:			fEndpointProto,			_parent:			fAppBase,			fIOTypeIndex:	fConfigIOType,		};			fEndPoint.fRemoteIPAddr := answers[0].resultIPAddress;		if kdebugOn then print("remote IP address is: " & fEndPoint.fRemoteIPAddr);		local	values := {				statusText: "ConnectingÉ", 				titleText: "IP Address:" && call kNumtoHostAddr with (fEndPoint.fRemoteIPAddr),		};		InetDisplayStatus(fConfigLinkID,fStatusView,values);		fEndpointConfigOptions := call kGetEndpointConfigOptions with (fConfigLinkID,fConfigIOType+1);				fEndpoint:MConnectAction();	end else begin		:MPutDataInStatusArea("Error getting DNS address:" && error);		fStatusView := InetDisplayStatus(fConfigLinkID,fStatusView,nil);  // close the status view.		:MDisconnect();  // release the link, since we did not contact anyone...	end;end
       ,
     cleanUp:
       func()begin	:mCancel();	fConfigRAddr:=nil;	target:=nil;	fEndPointConfigOptions:=nil;		:MDisconnect();	:MResetReceiveBuffer();  // release buffer memory	if fStatusView then		fStatusView := InetDisplayStatus(fConfigLinkID,fStatusView,nil);  // always close status when error occurs	fLinkStatus:='idle;end
       ,
     MCancel:
       func()begin	:MputDataInStatusArea("Cancelling...");	if fLinkStatus <> 'Connected then		InetCancelCurrentRequest(nil);		//InetCancelLink(fConfigLinkID,self,'MCallbackCancel); 	else if fDNSPending then		DNSCancelRequests(self,'MCallBackCancelDNS); 	else if fEndPoint then		fEndPoint:Cancel(NIL);	else if kdebugOn then		print("Nothing to Cancel");end
       ,
     MNotifyError:
       func(message, errorNum)begin	//local errStr := call kGetInetErrorStr with (errorNum);	local errStr := "Error" & errorNum;	fError:=errorNum;	:MPutDataInStatusArea(message);	:MNotify(message & unicodeCR & errStr);	if fStatusView then		fStatusView := InetDisplayStatus(fConfigLinkID,fStatusView,nil);  // always close status when error occursend
       ,
     MSetInputSpec:
       func()begin		if kdebugOn then print("Setting Input Spec:");		local spec := nil;		try			if fIOTypeIndex = kIOTypeTCPIndex then				spec := fEndpoint.fStreamInputSpec;			else if fIOTypeIndex = kIOTypeUDPIndex then				spec := fEndPoint.fPacketInputSpec;			else			  :MNotify("Illegal value for fIOTypeIndex: " & NumberStr(fIOTypeIndex));			:SetInputSpec(spec);		onexception |evt.ex.comm| do			begin				:MNotifyError("Endpoint SetInputSpec failed.", CurrentException().error);				ReThrow();			end;	end
     ,
     fReceivedCount: 0,
     rev: func() return kRev,
     fConfigRPort: nil,
     fReceiveBufferLen: 0,
     fConfigRAddr: nil,
     viewJustify: 240,
     icon: ROM_PhoneBitmap,
     CancelRequest: func(reason)begin	:mCancel();	return nil;end,
     fEndpointState: kStateIdle,
     MDisconnect:
       func()begin	:MPutDataInStatusArea("Disconnecting");	if fEndpointState = kStateConnected then		try			fEndpoint:Disconnect(true, nil);			fEndpoint:Unbind(nil);		onexception || do			nil;		try		if fEndpoint then fEndpoint:Dispose();	onexception || do		nil;		fEndpoint := nil;	fEndpointState := kStateIdle;		if fLinkGrabbed then begin		fLinkGrabbed := nil;		InetReleaseLink(fConfigLinkID,self,'MCallbackRelease);	end;		:MPutDataInStatusArea("Disconnected");end
     ,
     McallBackCancel:
       func(LinkID,statusFrame, err)begin	if kDebugOn then Print("callBack cancel");//   Do NOT display status on cancel callback!!//	if statusFrame.linkStatus = 'idle or err then //		fStatusView := InetDisplayStatus(fConfigLinkID,fStatusView,nil); // close status view//	else begin//		InetDisplayStatus(fConfigLinkID,fStatusView,statusFrame);//	end;		if err then	begin		:MNotifyError("Error canceling Link: ", err);	end;end
       ,
     fEndpoint: nil,
     MCallBackSlip:
       func(doWhat)begin	fConfigLinkID := InetGetDefaultLinkID();  // get link ID in case it changed.	if doWhat <> 'close then begin		fStatusView := InetDisplayStatus(fConfigLinkID,nil,nil);		fStatusView.appSymbol := kAppSymbol; // call our app for CancelScript		anErr := InetGrabLink(nil,self,'MCallbackGrab);	end;end
       ,
     fBufFullNotified: nil,
     fReceiveBuffer: nil,
     viewSetupFormScript:
       func() begin	//:setup();	//AddDeferredSend(self,'close,'[]);	end;
       ,
     fConfigLinkID: kDefaultLinkId,
     fError: 0,
     fConfigLPort: nil,
     viewClass: 74 /* clView */,
     Setup:
       func() begin	fAppBase := self;		target := clone(target);								if not GlobalFnExists('InetGrabLink) then begin		:Notify(kNotifyAlert,kAppName,"The Newton Internet Enabler is not installed.");		AddDeferredSend(self,'close,'[]);	end;		// return value becomes the initial value of the input field	fConfigLinkID := InetGetDefaultLinkID();	if NOT fConfiglinkID then		:Notify(kNotifyAlert,kAppName,"There are no Link entries to test with...You probably want to create one with Internet Setup.");	if kDebugOn then Print("linkID: " & fConfigLinkID);end
       ,
     MConnectAction:
       func()		// SELF = the endpoint framebegin	try				// ===========================				begin			try				local statusFrame := {					statusText: "Instantiating Endpoint", 					titleText: "Address:" && fConfigRAddr,				};				InetDisplayStatus(fConfigLinkID,fStatusView,statusFrame);				if kdebugOn then begin print("Instantiating Endpoint"); print(fEndpointConfigOptions); end;				:Instantiate(self, fEndpointConfigOptions);			onexception |evt.ex.comm| do				begin					:MNotifyError("Endpoint instantiate failed.", CurrentException().error);					return;		// don't rethrow here -- don't want to try a dispose of the endpoint 'cause it's not yet instantiated				end;						// ---------------------------						try 				// if not listening then use default port....				local bindOptions := call kInetBindOptions with (fConfigLPort, not fConfigListen);								if kDebugOn then begin print("Binding..."); print(bindOptions); end; 						local statusFrame := {					statusText: "Binding", 					titleText: "Address:" && fConfigRAddr,				};				InetDisplayStatus(fConfigLinkID,fStatusView,statusFrame);								bindOptions := :Bind(bindOptions, nil);				fConfigLPort := bindOptions[0].data.argList[0];				if kDebugOn then print("Local Port is:" &&fConfigLPort);			onexception |evt.ex.comm| do				begin					:MNotifyError("Endpoint bind failed.", CurrentException().error);					ReThrow();				end;						// ---------------------------						if fConfigListen then begin				try					local statusFrame := {						statusText: "Listening for connection on port" && fConfigLPort, 					};					InetDisplayStatus(fConfigLinkID,fStatusView,statusFrame);					local listenOptions := nil;					if fIOTypeIndex = kIOTypeTCPIndex then						listenOptions := kTCPListenOptions;											local listenCallback := 					{						async: TRUE,											completionScript: func(ep, options, err)						begin							ep._Parent:MCallbackListen(options,err);						end,												reqTimeout: 2*60000, // timeout after 2 minutes					};					:Listen(listenOptions, listenCallback);				onexception |evt.ex.comm| do					begin						:MNotifyError("Endpoint listen failed.", CurrentException().error);						ReThrow();					end;				return;			end else				try					local statusFrame := {						statusText: "Opening a connection...", 						titleText: "Local Port: " && fConfigLPort,					};					InetDisplayStatus(fConfigLinkID,fStatusView,statusFrame);										local connectOptions;	// NS defaults to nil					if fConfigIOType = kIOTypeTCPIndex then						connectoptions := call kTCPConnectOptions with (fRemoteIPAddr,fConfigRPort);												if kDebugOn then begin print("Connecting..."); print(connectOptions); end;					:Connect(connectOptions, nil);				onexception |evt.ex.comm| do					begin						:MNotifyError("Endpoint connect failed.", CurrentException().error);						ReThrow();					end;							local ipAddressesOptions := kGetIPAddressesOptions;								try begin					local statusFrame := {						statusText: "getting Host/local addresses...", 					};					InetDisplayStatus(fConfigLinkID,fStatusView,statusFrame);										local ipAddressesOptions := :Option(IPAddressesOptions, nil);				end onexception |evt.ex.comm| do					begin						:MNotifyError("Error getting IP addresses.", CurrentException().error);						ReThrow();					end;			local localAddr := ipAddressesOptions[0].data.argList[0]; 			local gateWayAddr := ipAddressesOptions[0].data.argList[1];			// ---------------------------						:MSetInputSpec();			// ---------------------------						fEndpointState := kStateConnected;									local msg := paramStr("Connected from ^0, Gateway ^1",[				call kNumtoHostAddr with (localAddr),				call kNumtoHostAddr with (gatewayAddr)			]);			:MPutDataInStatusArea(msg);			fStatusView := InetDisplayStatus(fConfigLinkID,fStatusView,nil); // close status view		end				// ===========================			onexception |evt.ex.comm| do		:MDisconnect();end
       ,
     MPutDataInStatusArea:
       func(s) begin	if kdebugon then print("Status:" && s);	fStatus:=s;end,
     MCallbackRelease:
       func(LinkID, newStatus, err)begin	if err AND kDebugOn then Print("callbackRelease err: " & err);end
     ,
     fLinkGrabbed: nil,
     fConfigIOType: kDefaultIOTypeIndex,
     MNotify:
       func(message)begin	GetRoot():Notify(kNotifyAlert, kAppName, message);end
     ,
     fEndpointConfigOptions: nil,
     MCallbackListen:
       func(opts,err)begin	local msg;		if err then		:MNotifyError("Listen Failed",err);	else begin		msg := "Listen completed, accepting connection";		fEndPoint:Accept(nil,nil);  		fEndPoint:MSetInputSpec();		if opts then begin  // no opts on UDP connection			local rmAddr := options[0].data.argList[0]; 			local rmPort := opts[0].data.argList[1];			//local rmAddr := Setlength(clone(opts[0].data.argList),4);			local rmAddrStr := call kNumToHostAddr with (rmAddr);			msg := "Connected to" && rmAddrStr && "port" && rmPort;		end else			msg := "UDP connection established";		:MPutDataInStatusArea(msg);		fEndpointState := kStateConnected;	end;end
       
    };

// After Script for NetTest
thisView := NetTest;
//partData.mainView:=thisView



constant |layout_BITUnit| := NetTest;
// End of file BITUnit
// Beginning of text file commsUnit.f
/*DefineUnit(ensureInternal('|commsUnit:NSB|), {	commsUnit:	getlayout("commsUnit"),	BITUnit:	  getlayout("BITUnit")});InstallScript := func(partFrame, removeFrame)	begin		// need this (for now) or we throw	end;RemoveScript := func(removeFrame)	begin		// need this (for now) or we throw	end;*/		definition := EnsureInternal(Clone(kCommsUnitFrame));definition.commsUnit := getlayout("commsUnit");definition.BITUnit := getlayout("BITUnit");DefineUnit(EnsureInternal('|commsUnit:NSB|), definiti
£Gø£GÀon);InstallScript := func(partFrame, removeFrame) nil;RemoveScript := func(removeFrame) nil;
yout("BITUnit")});InstallScript := func(partFrame, removeFrame)	begin		// need this (for now) or we throw	end;RemoveScript := func(removeFrame)	begin		// need this (for now) or we throw	end;*/		definition := EnsureInternal(Clone(kCommsUnitFrame));definition.commsUnit := getlayout("commsUnit");definition.BITUnit := getlayout("BITUnit");DefineUnit(EnsureInternal('|commsUnit:NSB|), definiti
// End of text file commsUnit.f
// Beginning of file editorUnit
screenView :=
    {viewFlags: 1,
     viewFormat: 0,
     viewBounds: {left: 1, top: 1, right: 231, bottom: 287},
     printFormat:
       'list// this slot is used by the Action Button to determine the output format// to be used by the PrintFormat routines.
       ,
     viewSetupFormScript:
       func() begin	editor.basicAlpha:=getroot().alphakeyboard;	:setViewBounds();	if not keyboardConnected() then editor.basicAlpha:open();	:alignButtons({left: []});	end		
     ,
     setViewBounds:
       func() begin	local BAbounds;	// set sizes of views	local x:=getAppParams();	if editor.basicAlpha.saveBounds exists		then BAbounds:=editor.basicAlpha.saveBounds		else BAbounds:=editor.basicAlpha.viewBounds;	local BAheight:=BAbounds.bottom-BAbounds.top;	if keyboardConnected() then BAheight:=11;	if debug then print("screenView.setViewBounds:" && BAheight);										 	// set bounds of ScreenView & editor	local y:={left: x.appAreaLeft,   top: x.appAreaTop+1,	         right: x.appAreaWidth, bottom: x.appAreaHeight-BAheight-10};	editor.kScreenSize:=floor((y.bottom-y.top)/11)-2;	editor.kScreenWidth:=floor((y.right-y.left-2)/6);	self.viewBounds:=x.appAreaBounds;		setValue(editor, 'viewBounds, {left: 1, top: 1, 			right: y.left+editor.kScreenWidth*6+2, bottom: y.top+editor.kScreenSize*11});end
       ,
     script:
       func(scriptName, cbf) begin	if debug then print("editor.script:" & scriptName && cbf);	screenview:open();	callBackFunc:=cbf;	baseview.editor:=screenview.editor;	baseview.editor:open();		editor.text:="";	editor.textlines:=[];		if systemEntry.textlines 		then editor:addLines(systemEntry.textLines)		else editor:addLines([kVersion & CR,editor:prompt()]);	editor.ignoreChanges:=nil;	setKeyView(editor, length(editor.text));	:doAda(func() postKeyString(editor,"module " & scriptName & CR), '[], 4);	end
     ,
     callBackFunc: nil,
     viewQuitScript:
       func() begin	if debug then print("ScreenView.viewQuitScript" & callBackFunc);	if visible(editor.basicAlpha) then editor.basicAlpha:close();	perform(baseView.funcs, callbackFunc, nil);	inherited:?viewQuitScript();		// this method is defined internally	end
       ,
     viewSetupDoneScript:
       func() begin	if not newtCard		then closeEditor:hide()		else begin			//command:close();			module:close();			end;	end
       ,
     viewClass: 77 /* clEditView */
    };

editor :=
    {
     upInSmoke:
       func(smokeBounds)	begin  local top  := smokeBounds.top;  local left := smokeBounds.left;  local bm1 := Clone(ROM_cloud1);  local bm2 := Clone(ROM_cloud2);  local bm3 := Clone(ROM_cloud3);    //CopyBits draw bitmaps scaled to their bounds  bm1.bounds := bm2.bounds := bm3.bounds := smokeBounds;   //explained below  local danQuayle := BuildContext({viewClass:clView,  																 viewFlags:vFloating,  																 viewBounds:smokeBounds});  PlaySound(ROM_poof);  GetRoot():CopyBits(bm1,left,top,modeMask);  Sleep(2);  GetRoot():CopyBits(bm1,left,top,modeBic);  GetRoot():CopyBits(bm2,left,top,modeMask);  Sleep(2);  GetRoot():CopyBits(bm2,left,top,modeBic);  GetRoot():CopyBits(bm3,left,top,modeMask);  Sleep(1);  GetRoot():CopyBits(bm3,left,top,modeBic);  //force an update (ala InvalRect in the Mac ToolBox)  danQuayle:Open();  danQuayle:Close();  screenView:parent():close();    //If you knew what view(s) to dirty you could just use :Dirty()  // to force the update. This code is general purpose, so it  // doesn't know (and GetRoot():Dirty is way slow)	end
       ,
     openStmtEditor:
       func(text) begin // open stmtEditor or chain to VisualDesigner	local p, p1, text, widgetText;	if debug then print("openStmtEditor:" & text);		if beginsWith(text, "EDIT") then return;	if NOT strPos(text, " WIDGETDEF ",0) then begin			stmtEditor:Open();			setValue(stmtEditor.stmtLine, 'text, text);			:doada(func() setKeyView(stmtEditor.stmtLine, strLen(stmtEditor.stmtLine.text)), '[], 499)			end	else begin // start Visual Designer		p:=strPos(text,":=",0);		if NOT p then begin			p:=strPos(text," ",0);			p1:=strPos(text," ",p+1);			widgetText:="{layoutName: '" & substr(text,p1+1,nil) & "}"			end		else begin			if endsWith(text,"]") // old style frame: array of widgets				then widgetText:="['" & substr(text, 10, p-10) & "," & substr(text, p+3, nil);			if endsWith(text,"}") then begin // new style frame: frame of widgets				p1:=p;				while text[p1]<>$  do p1:=p1-1;				widgetText:="{layoutName:'" & substr(text, p1+1, p-p1-1) & "," & substr(text,p+3,nil);				end			end;					while (p:=strPos(widgetText,"Â",0)) do			widgetText:=substr(widgetText,0,p) & substr(widgetText,p+1,nil);				if visible(basicAlpha) then basicAlpha:close();		call kShowBusyBoxFunc with (true);		if debug then print("Calling VDesign:" & widgetText);		visualDesigner:chain(widgetText,baseView.interpreter.VisualDesignerReturn);		noQuitAllowed:=TRUE;		end;	:doada(func() setKeyView(editor, strLen(editor.text)), '[], 56);end
       ,
     basicAlpha: nil,
     textLines: nil,
     viewFormat: 337,
     viewgesturescript:
       func(unit, gestureKind) begin	local startP;	if systemEntry.prettyPrint then startP:=6 else startP:=0;		// Return true if gesture has been completely handled, nil otherwise	if debug then print("ViewGestureScript:" & sprintobject(gestureKind));	if gestureKind=49 then begin  // tap: bring up edit window		inkOff(unit);		if visible(stmtEditor) then begin // already editing: do nothing				:doada(func() setKeyView(stmtEditor.stmtLine, strLen(stmtEditor.stmtLine.text)), '[], 9);				return TRUE;				end;				local LTL:=textLines;		local line:=floor(getPoint(firstY,unit)/11);		if debug then print (LTL);		if debug then print ("click at line " & line);		if line>length(LTL)-1 then return TRUE;		local stmt:=clone(LTL[line]);		if beginsWith(LTL[line],"* ") then stmt:=substr(stmt,2,nil);		//if :startsWithLineNo(stmt)=NIL and :startsWithCmdOrStmt(stmt)=NIL then return TRUE;			for i:=line+1 to length(LTL)-1 do begin			if NOT (endsWith(stmt,"Â" & CR) or endsWith(stmt,"Â")) then begin				if beginsWith(LTL[i],"* ") then break;				if beginsWith(LTL[i],"Error ") then break;				if beginsWith(LTL[i],"--More--") then break;				if strEqual(subStr(LTL[i],4,8)," :Error ") then break;				if :startsWithLineNo(LTL[i])=TRUE then break;				if strLen(LTL[i-1])<kScreenWidth-5 then break;				startP:=0;				end;			stmt:=substr(stmt,0,strLen(stmt)-1) & substr(textLines[i],startP,nil);			//if strLen(LTL[i])<>kScreenWidth+1 then break;			end;		if endsWith(stmt,CR) then stmt:=substr(stmt,0,strLen(stmt)-1);		:openStmtEditor(stmt);						return TRUE		end;end
       ,
     viewQuitScript:
       func() begin	if not newtCard		then systemEntry.textLines:=clone(editor.textLines);		else systemEntry.textLines:=nil;	ignoreChanges:=nil;	inherited:?viewQuitScript();		// this method is defined internally	end
       ,
     viewFlags: 2561,
     viewBounds: {left: 2, top: 16, right: 241, bottom: 238},
     viewChangedScript:
       func(slot, view) begin	if ignoreChanges then return;	if _mainRF._inputFlag=nil and _mainRF._runFlag then return;	if endsWith(text,CR & "*") then begin      setvalue(self,'text,self.text & " ");      :doada(func() setKeyView(self, strLen(self.text)), '[], 9);      return  	  end;	if endsWith(text, CR)=nil then return;	// continuation of display after -- MORE --	if length(textLinesHold)>0 then begin		if endsWith(text, "--MORE--" & CR) then begin			:addLines([]);			:doada(func() setKeyView(editor, strLen(editor.text)), '[], 8); 			return;			end;		else begin			textLinesHold:=[];			:addLines([:prompt()]);			return			end;		end;	   local p1:=min(endText-1,strLen(self.text)-1);   local input:=trimString(subStr(self.text,p1+1,nil));   if length(textLines)>0 then setlength(textLines,length(textLines)-1);   :addlines([:prompt() & input & CR]);   if debug then print("Input is:" & input);   if :handleInput(input) then return NIL;   if _RF._runFlag then return; // ignore changes to screen while running   :handleInputLine(input & CR);  end
       ,
     visualDesignerReturn: func(text) interpreter:visualDesignerReturn(text)
     ,
     textLinesHold: [],
     ignoreChanges:
       true// defines operation of viewChangedScript. // If set to true, viewChangedScript does nothing// if it is NIL, then it is active.
       ,
     addLines:
       func (lines) begin	// this routine adds lines to the end of the display	// the display is kept as an array of lines in 'textLines	// which is converted to a text string for display	if debug then print(lines);	local line,i,temp,p1,p2,loopOK;	if NOT strEqual(systemEntry.io, "scre") then begin		foreach line in lines do			io:ioPrint(io.connectedToEP, deepclone(line));		return nil;		end;				// split lines that wrap around and have embedded CR characters	local j:=0; 	if length(lines)=0 then loopOK:=nil else loopOK:=TRUE;	while loopOK do begin		p1:=strPos(lines[j],CR,0);   	if p1 then if p1>0 and p1<strLen(lines[j])-1 then begin   		p1:=0; temp:=[];   		while p1<strLen(lines[j]) do begin   			p2:=strPos(lines[j],CR,p1);   			addArraySlot(temp,substr(lines[j],p1,p2-p1+1));   			p1:=p2+1;   			end;   		lines:=arrayMunger(lines,j,1,temp,0,nil);   		end;   				if strLen(lines[j])>kScreenWidth+1 then begin			temp:=[];			for i:=0 to strLen(lines[j]) by kScreenWidth do				addArraySlot(temp,substr(lines[j],i,kScreenWidth) & CR);			temp[length(temp)-1]:=subStr(temp[length(temp)-1],0,strLen(temp[length(temp)-1])-1);			lines:=arrayMunger(lines,j,1,temp,0,nil);			j:=j+length(temp)-1;			end;		j:=j+1;		if j>length(lines)-1 then loopOK:=nil;   end;   if length(textlines)>0 and strEqual(textlines[length(textLines)-1],"--More--") 			then ArrayRemoveCount(textLines,length(textLines)-1,1);            if length(textLines)>0 and strEqual(textlines[length(textLines)-1],"* ")   		then textlines[length(textLines)-1]:="* " & CR;   if length(textLinesHold)>0 then lines:=textLinesHold;   if length(textLines)+length(lines)>kScreenSize-1 then         arrayRemoveCount(textLines,0,            min(length(textLines),length(textLines)-(kScreenSize-1-length(lines))));	 textLinesHold:=[];   // display what will fit for now, and put the rest in textLinesHold   foreach line in lines do      if length(textlines)<kScreenSize-1           then addArraySlot(textLines,line)         else addArraySlot(textLinesHold,line);   if length(textLinesHold)>0       then begin           addArraySlot(textLines,"--More--");           if strEqual(textLinesHold[length(textLinesHold)-1],:prompt() )=nil              then addArraySlot(textLinesHold,:prompt());           end;   ignoreChanges:=TRUE;  // turn off viewChangedScript   setvalue(editor,'text,stringer(textlines));   refreshViews();   endText:=strLen(editor.text);   ignoreChanges:=NIL;	end
       ,
     startsWithLineNo:
       func(stmt) begin	local p:=strPos(stmt," ",0);	if p=nil then return NIL;	local x:=stringToNumber(substr(stmt,0,p));	if x=nil or x<0 or x>9999 then return NIL;	TRUE;	end
     ,
     kScreenWidth: nil,
     viewTransferMode: 2,
     handleInputLine:
       func(input) begin    // process input from command line: called from viewChangedScript	// if multi line input: split and re-call this function with each line	local p, p1:=0;	if strPos(input,CR,0) then begin		loop begin			p:=strPos(input,CR,p1);			if not p then break;			:handleInputLine(substr(input,p1,p-p1));			p1:=p+1;			end;		return NIL		end;		// Is the line complete?		if endsWith(input, "Â") then begin			_RF._inputLineHold:=_RF._inputLineHold & input;			:addLines([""]);			return			end;				// single line input: OK to process			input:=_RF._inputLineHold & input;			_RF._inputLineHold:="";      p1:=strPos(input & " "," ",0);      local command:=trimstring(subStr(input,0,p1));      interpreter.newStmt:=trimString(subStr(input,p1+1,nil));      if interpreter.newStmt=nil then interpreter.newStmt:="";      if strEqual(command,"") then begin         if NOT executor.enterInProgress then :addlines([:prompt()]);         return NIL;end;      if stringToNumber(command) and stringToNumber(command)<10000 then begin         interpreter:saveStmt(command,interpreter.newStmt);         if NOT executor.enterInProgress then :addLines([:prompt()]);         return NIL;end;      if strEqual(command,"SAVE") or         strEqual(command,"REPLACE") then begin        interpreter:doSave(command && interpreter.newStmt);        if NOT executor.enterInProgress then :addLines([:prompt()]);        return NIL;end;              executor.basicAlphaInUse:=visible(basicAlpha);      if strEqual(command,"RUN") then begin interpreter:doRunInit();return NIL;end;      if strEqual(command,"CON") then begin interpreter:doCon();return NIL;end;      if findStringInArray(kCommand,upcase(clone(command))) then begin      	 interpreter:saveHeader();         if interpreter:commsCheck() then perform(interpreter,intern("do" & command),[]);         if length(textLinesHold)=0 then begin            _RF:printLineFlush();            if NOT executor.enterInProgress then :addLines([:prompt()]);            end;         return NIL;        		      end;         // so it must be a statement starting without a line number      _RF:doImmediate(trimstring(command && interpreter.newStmt));      _RF:printLineFlush();      if NOT _RF._inputFlag and NOT executor.enterInProgress then :addLines([:prompt()]);end
       ,
     textBuff: "Text",
     declareSelf: 'base,
     handleInput:
       func(input) begin	// this routine handles input from an INPUT statement	// if program is running, it either sends it to the input routine or stacks it.	//    else, it returns NIL	// it is called from the importScript() of the serial and IR routines,	// and from editor:viewChangedScript().		if _mainRF._runState=nil then return NIL;	if debug then print("waiting for input");		addArraySlot(_mainRF._inputStack,input);	if _mainRF._inputFlag then _mainRF:exInputArg(); // if waiting on input, go right away							 else return TRUE;           // otherwise, just save it in stack	if _mainRF._inputFlag then :addlines([:prompt()]); // we got input: do we need still more?					     else if _mainRF._runState then _RF:resumeExecution();	return TRUE;	end
       ,
     endText: nil,
     text2: "Text",
     startsWithCmdorStmt:
       func(stmt) begin	local p:=strPos(stmt," ",0);	if p=NIL then p:=strPos(stmt,CR,0);	local s:=upcase(substr(stmt,0,p));	findStringInArray(kStatements, s) OR findStringInArray(kCommand, s)	end
     ,
     viewClass: 81 /* clParagraphView */,
     importFlag: nil,
     text: "",
     viewFont: {family: 'monaco, size: 9, face: 0},
     prompt:
       func() begin	:doada(func() if visible(editor) then setKeyView(editor, strLen(editor.text)), '[], 11);	if _RF._inputFlag then return systemEntry.inputPrompt;	if _mainRF._runState then return "";	return "* "	end
     ,
     kScreenSize: nil,
     line: nil
    };
AddStepForm(screenView, editor);
StepDeclare(screenView, editor, 'editor);

stmtEditor :=
    {viewBounds: {left: 0, top: 111, right: 220, bottom: 207},
     viewFlags: 580,
     declareSelf: 'base,
     viewQuitScript:
       func() if stmtEditor AND stmtEditor.viewCObject then begin	:doada(func()		if editor AND editor.viewCObject 			then setKeyView(editor, strLen(editor.text)), '[], 12);	:doAda(func() if stmtEditor then stmtEditor:close(), '[], 0);	end
     ,
     notRunTime: 'stmtEditor,
     viewSetupDoneScript:
       func() begin	// set size of stmtEditor	if not systemEntry then return;	local BATop:=editor.viewBounds.bottom-7;				setvalue(self, 'viewbounds, {top: BATop-91, bottom: BATop,		left: editor.viewbounds.left+10, right: editor.viewbounds.right-10});	setValue(stmtLine,'viewbounds, {top: 4, bottom: viewbounds.bottom-viewBounds.top-20,		left: 4, right: viewbounds.right-viewBounds.left-4});		_defaultButton:=Enter;	end
       ,
     viewJustify: 0,
     _defaultButton: nil,
     _proto: @180 /* protoFloatNGo */
    };
AddStepForm(editor, stmtEditor);
StepDeclare(editor, stmtEditor, 'stmtEditor);

stmtLine :=
    {viewFlags: 33553921,
     viewFormat: 12545,
     viewLineSpacing: 13,
     viewFont: {family: 'Monaco , face: 0, size: 9 },
     viewBounds: {left: 4, top: 4, right: 228, bottom: 80},
     ViewKeyDownScript:
       func(c, flags) 	if c=kReturnKey then enter:buttonClickScript(),
     text: "",
     viewClass: 81 /* clParagraphView */
    };
AddStepForm(stmtEditor, stmtLine);
StepDeclare(stmtEditor, stmtLine, 'stmtLine);



enter :=
    {text: "Enter",
     buttonClickScript:
       func() begin	if done then return nil;	local p1:=strPos(stmtLine.text & " "," ",0);	local command:=trimstring(subStr(stmtLine.text,0,p1));	local newStmt:=trimString(subStr(stmtLine.text,p1+1,nil));	local stmt;	done:=TRUE;	editor.textLinesHold:=[];	while (p1:=strPos(newStmt,CR,0)) do begin		if p1>0 then stmt:=subStr(newStmt,0,p1)   			  	else stmt:="";   	if p1<strLen(newStmt) then stmt:=stmt & substr(newStmt,p1+1,nil);   	newstmt:=stmt;   	end;	if debug then print("CR strip: " & newstmt);	if endsWith(newStmt,CR) then newStmt:=substr(newStmt,0,strLen(newStmt)-1);	if newStmt=nil then newStmt:="";	:doAda(func() stmtEditor:close(), '[], 2);	editor.textLines[length(editor.textLines)-1]:="* " & CR;	editor:addLines([command & " " & newStmt & CR]);	editor:handleInputLine(command && newStmt);  	NIL	end
     ,
     viewBounds: {left: -60, top: -13, right: -20, bottom: -4},
     viewSetupDoneScript: func() done:=nil;,
     done: nil,
     viewJustify: 8388774,
     _proto: @226 /* protoTextButton */
    };
AddStepForm(stmtEditor, enter);
StepDeclare(stmtEditor, enter, 'enter);





closeEditor :=
    {
     buttonClickScript:
       func() begin	if debug then print("closeEditor");	interpreter:saveHeader();	:doAda(func() if screenView then screenView:close(), '[], 10);	baseView.editor:=nil;	inherited:?buttonClickScript();		// this method is defined internally	end
       ,
     _proto: @166 /* protoCloseBox */
    };
AddStepForm(editor, closeEditor);
StepDeclare(screenView, closeEditor, 'closeEditor);





statement :=
    {text: "  Statement",
     viewBounds: {top: -16, left: 26, right: 91, bottom: -3},
     viewJustify: 8388614,
     viewFormat: 67109457,
     pickActionScript:
       func(i) if not kRunTime then begin	local stmtNo;	if i>=2		then postKeyString('viewFrontKey,				substr(kStatementPickList[i],0,strPos(kStatementPickList[i]," ",0)) & " ")		else begin // Next Line			if classof(_RF._lastStmtNo)='int				then stmtNo:=interpreter:formatLineNo(_RF._lastStmtNo+10)				else stmtNo:="";			if i=0 				then postKeyString('viewFrontKey,lineNo & " ")				else // bring up edit window					if visible(editor.stmtEditor) // already editing: do nothing						then :doada(func() setKeyView(editor.stmtEditor.stmtLine, strLen(editor.stmtEditor.stmtLine.text)), '[], 9);						else editor:openStmtEditor(stmtNo);			end;	inherited:pickActionScript(i)	end
       ,
     popup: kStatementPickList,
     viewSetupFormScript:
       func() begin	local k:=clone(self.viewBounds);	local keyHeight:=k.bottom-k.top;	k.bottom:=getAppParams().appAreaHeight-3;	k.top:=k.bottom-keyHeight;	setvalue(self, 'viewBounds, k);	end
     ,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(screenView, statement);
StepDeclare(screenView, statement, 'statement);



Command :=
    {text: "  Command",
     viewBounds: {left: 98, top: -16, right: 156, bottom: -3},
     viewJustify: 8388614,
     viewFormat: 67109457,
     pickActionScript:
       func(i) begin	postKeyString(editor,				substr(kCommandPickList[i],0,strPos(kCommandPickList[i]," ",0)) & " ");	if length(splitString(kCommandPickList[i]))=1 then postKeyString(editor, CR);	inherited:pickActionScript(i)	end
     ,
     alwaysCallPickActionScript: true,
     popup: kCommandPickList,
     viewSetupFormScript:
       func() begin	local k:=clone(self.viewBounds);	local keyHeight:=k.bottom-k.top;	k.bottom:=getAppParams().appAreaHeight-3;	k.top:=k.bottom-keyHeight;	setvalue(self, 'viewBounds, k);	end
     ,
     buttonClickScript:
       func() begin	if newtCard 		then popup := kCommandPickListNewtCard;		else popup := kCommandPickList;			inherited:?ButtonClickScript();	// call the inherited version to do popupend
       ,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(screenView, Command);
StepDeclare(screenView, Command, 'Command);



module :=
    {text: "  Module",
     viewBounds: {left: 163, top: -16, right: 211, bottom: -3},
     viewJustify: 8388742,
     viewFormat: 67109457,
     pickActionScript:
       func(i) begin	if debug then print("module.pickActionScript" && i);		if strEqual(popup[i].item,"New")		then inputOneLineLink:display("Create New Module","Name","",'pickNewReturn)	else postKeyString(editor, "module" && popup[i].item & CR);	inherited:?PickActionScript(i);		// call the inherited version to unhilite the button	end
       ,
     popup:
       // set in buttonClickScript[]
       ,
     buttonClickScript:
       func() begin	popup:=[{item: "Main"},'pickSeparator];	foreach sub, lineNo in _subs do		if NOT lineNo or lineNo>0 then addArraySlot(popup, {item: sPrintObject(sub)});	if length(popup)>2 then addArraySlot(popup, 'pickSeparator);	addArraySlot(popup, {item: "New"});		for i:=0 to length(popup)-1 do		if isFrame(popup[i]) and hasSlot(popup[i], 'item) and 			strEqual(popup[i].item, sPrintObject(_sub))				then popup[i]:={item: popup[i].item, 												pickable: nil, 				   							mark: kCheckMarkChar};	inherited:?ButtonClickScript();			// call the inherited version to do popup	end
       ,
     currentFont:
       // Font displayed in the popup when it is open, never nil.  Setup by buttonClickScriptnil
       ,
     viewFlags: 515,
     viewSetupFormScript:
       // be sure to call inherited:?ViewSetupFormScript()func()begin	// setup the next key view so that key commands are found correctly	self._nextKeyView := baseView;		inherited:?ViewSetupFormScript();end
       ,
     _nextKeyView: nil,
     declareSelf: 'bModule,
     pickNew:
       func(name) begin	local cmd:="module" && name;	:doAda(func() postKeyString(editor, cmd & CR), '[], 5);	end
     ,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(screenView, module);
StepDeclare(screenView, module, 'module);




constant |layout_editorUnit| := screenView;
// End of file editorUnit
// Beginning of text file editorUnit.f
definition := EnsureInternal(Clone(kEditorUnitFrame));definition.editorUnit := getlayout("editorUnit");DefineUnit(EnsureInternal('|editorUnit:NSB|), definition);InstallScript := func(partFrame, removeFrame) nil;RemoveScript := func(removeFrame) nil;
V£F¤£F¤
// End of text file editorUnit.f
// Beginning of text file InterpreterLayouts
defconst('kEmptyCodeRec, {sub: 'main, type: 'code, ID: 0,							codeLen: -1,							keywords: [], 							code: []});defconst('kEmptyMainHeader, {sub: 'main, type: 'head, ID: kMainSub, 							subs:   	 {main: 0},							version:   "",							icon:			 nil,							labels:    {},							dataLabels:{},							listRecs:  [],							dataRecs:  [],							codeRecs:  [],							cumLines:  [],							stmtNos:   [],							lastID: 0,							widgetCounter: 0 });	  		 defconst('kEmptySubHeader, {ID: NIL, sub: NIL, 
£Gø£GÀtype: 'sub,							labels:    {},							dataLabels:{},							listRecs:  [],							dataRecs:  [],							codeRecs:  [],							cumLines:  [],							stmtNos:   [],							subs:      {},							});defconst('kEmptyNewtCardHeader, {ID: NIL, sub: NIL, type: 'head,							version:   "",							subs:        {},              name:        "",              lastID:	 0,              widgetCounter: 0,              backgrounds: {},              cardCount:   1,              firstCard:   nil,             
£Gø£GÀ lastCard:    nil,              markedCards: [],              arriveSound: nil,              leaveSound:  nil,              arriveEffect:nil,              leaveEffect: nil,              });		 defconst('kEmptyNewtCardBG, {ID: NIL, sub: NIL, type: 'bg,							subs:       {},              name:       "",              cardCount:   1,              firstCard:   nil,              lastCard:    nil,              drawings:    nil,              widgets:     nil,              arriveSound: nil,    
£Gø£GÀ          leaveSound:  nil,              arriveEffect:nil,              leaveEffect: nil,              });		 defconst('kEmptyCardRec,{ID: NIL, type: 'card,							name: "",							background:     nil,							arriveSound:    nil,							leaveSound:     nil,							arriveEffect:   nil,							leaveEffect:    nil,							nextCardStack:  nil,							prevCardStack:  nil,							nextCardBg:     nil,							prevCardBg:     nil,							drawings:       nil,							widgets:        nil,							subs:        
£Gø£GÀ  {}							});
ound:  nil,              arriveEffect:nil,              leaveEffect: nil,              });		 defconst('kEmptyCardRec,{ID: NIL, type: 'card,							name: "",							background:     nil,							arriveSound:    nil,							leaveSound:     nil,							arriveEffect:   nil,							leaveEffect:    nil,							nextCardStack:  nil,							prevCardStack:  nil,							nextCardBg:     nil,							prevCardBg:     nil,							drawings:       nil,							widgets:        nil,							subs:        
// End of text file InterpreterLayouts
// Beginning of file InterpreterUnit
interpreter :=
    {y: nil,
     init_RF:
       func() begin	if _RF._context='main or newtcard then return;	if debug then print("Init_RF: " & _RF._context);	local oldRF:=_RF;	_RF:=_RF._parent;	oldRF:=nil;	:init_RF();		end
     ,
     commsCheck:
       func native () begin	local header:=_header;	local work:=_work;	if commsFlag then return TRUE;	if NOT strEqual(kTimeOut,"None") or strEqual(kTimeOut,"DEMO")	then begin		commsFlag:=TRUE;		return TRUE;		end;			// if this is an update, SCRATCH should already have integer key		local scratchOK:=TRUE;	if kUpdate then begin		if work then _header:=work:gotokey(kMainSub) else scratchOK:=NIL;		if NOT header or stringToNumber(header.version)<=3 then scratchOK:=NIL;			end;	if classof(systemEntry.SerialNumber)='int and 		(systemEntry.serialNumber-10000017) mod 127=0 and		scratchOK then begin			commsFlag:=TRUE;			return TRUE;			end;	if kUpdate then begin		local s;		if newtCard then s:="NewtCard" else s:="NS BASIC";		:notify(kNotifyAlert,s && substr(kVersion, 8, nil),				"Please install your original copy of " & s & ", " & 				"enter the serial number, then reinstall this update.");		screenview:close();		end;	return NIL;end
       ,
     printProgramLayout:
       func() begin	local header:=_header;	local output:="Header:" & CR & executor:getformatArbObject(header) & CR;	output:=output & :printProgramRecords('listRecs);		output:=output & :printProgramRecords('dataRecs);		output:=output & :printProgramRecords('codeRecs);	end
     ,
     coTrace:
       func() begin	local x:=trimString(stmtFrame.internal);	if strEqual(x,"ON")=nil and strEqual(x,"OFF")=nil then return (:error(kError2));	if strEqual(x,"ON") then x:="TRUE" else x:="NIL";	stmtFrame.compiled:=:co("_trace:=" & x);	end
     ,
     coEnviron:
       func() begin	local s:=trimString(stmtframe.internal);	if strReplace(s,"=",":=",1)=0 then return (:error(kError2));	local p:=strPos(s,":=",0);	if p=strLen(s)-2 then s:=s & "NIL";	stmtFrame.compiled:=:co("begin local io:=clone(systemEntry.io); local store:=clone(systemEntry.store); :exEnviron({oldio: io,						 oldstore: store,						 code: systemEntry." & substr(s,0,p+2) &       							 "deepClone(" & subStr(s,p+2,nil) & ")}) end" )end
     ,
     stmtFrame: nil,
     coMakePackage:
       func() begin	if newtcard then return :error(kError2);	local arg:=:getargs(stmtFrame.internal);	if length(arg)<>0 then return (:error(kError63));	arg:=["NIL"];	stmtFrame.compiled:=:co(":exMakePackage(" & arg[0] & ")");	end
     ,
     viewSetupDoneScript:
       func() begin	if debug then print("interpreter.viewSetupDoneScript");	coTable:=array(160,NIL);	for i:=0 to length(kStatementCodes)-1 do		coTable[kStatementCodes[i]]:=interpreter.(intern("co" & kStatements[i]));	end
     ,
     getNewCardRec:
       func() begin // create a new Card record	if kChunkTrace then print("getNewCardRec");	card:=deepclone(kEmptyCardRec);	card.ID:=:getID();	_workSoup:addXmit(card,nil);  card;	end
       ,
     coDelete:
       func()stmtFrame.compiled:=:co(":exDelete(" &  trimString(stmtframe.internal) & ")");
     ,
     coDO: func() stmtFrame.compiled:=:co(":exDo(" & :coDoExp() & ")");,
     coSet:
       func() begin	local s:=stmtFrame.internal;	local p:=strPos(s," TO ",0);	if p then s:=substr(s,0,p) & "=" & substr(s,p+4,nil);	stmtFrame.internal:=s;	stmtFrame.keyword:=kLet;	:coLet()	end
     ,
     isRunTIme:
       func(soup) begin	if nil then begin // HELP		local work, workq, ch;		local header:=_header;		if NOT strPos(soup,kExt,0) then return NIL;		if strEqual(kSoupName, soup) then return NIL;		work:=:getNonUnionSoup(soup);		if work=NIL then return NIL;   	try workq:=work:query({indexpath: 'ID})   	onexception |evt.ex.fr.store| do return NIL;   	if workq=NIL then return NIL;   	_RF._ch:=workq:gotoKey(header.codeRecs[_RF._codeRecPos:=0]);		if NOT ch then return NIL;		if NOT hasSlot(_RF._ch, 'version) then return NIL;   	if NOT strPos(_RF._ch.version,"RT",0) then return NIL;		end;	return TRUE;	end
       ,
     getHeader:
       func(subname) begin	local temp:=_header;	if beginsWith(subName, "stack")		then temp:=executor:getEntry(kMainSub);	else if beginsWith(subName, "BG_") then begin		local p:=strPos(subName,"_",3);		local BG:=intern(substr(subName,0,p));				temp:=executor:getentry(stack.backgrounds.(BG));		end				else if beginsWith(subName, "CD_") then begin		local p:=strPos(subName,"_",3);		local ID:=floor(stringToNumber(substr(subname,3,p-3)));		if temp.ID<>ID then temp:=executor:getEntry(ID);		end;	tempend
     ,
     coEnd:
       func() begin	// If END IF or END SUB, treat as if it is ENDIF/ENDSUB	if stmtFrame.internal then		if strEqual(trimString(stmtFrame.internal),"IF")				then return (:coEndIF())		else if strEqual(trimString(stmtFrame.internal),"SUB")				then return (:coEndSub())				else return (:error(kError2));	stmtFrame.compiled:=:co(":exEnd()");end;
       ,
     coRandomize:
       func() begin   if stmtFrame.internal=nil then stmtFrame.internal:="";   if strEqual(trimString(stmtFrame.internal),"")       then stmtFrame.internal:="ticks()";   stmtFrame.compiled:=:co("setRandomSeed(" & stmtFrame.internal & ")")	end
     ,
     doSave:
       func(newStmt) begin	if newtcard then return :error(kError2);	if debug then print(newStmt);   _RF:chDispose();   local x:=splitString(newStmt);   if length(x)=1 then addArraySlot(x,systemEntry.ProgramName);   if debug then print(x);   if strEqual(x[1],kSoupName) then return (:error(kErrorM1));   if length(x)<>2 then return (:error(kError2));	 if strEqual(kTimeOut,"DEMO") then x[1]:="DEMO";   local filename:=:stripQuotes(x[1]);   if strPos(kalpha, substr(filename,0,1),0)=nil then return (:error(kErrorM1));   fileName:=:makeProgramName(filename);   if debug then print("saving" && filename);      if systemEntry.useScratch=nil and systemEntry.programName<>NIL    	then if strEqual(filename, systemEntry.ProgramName) then return;         // if SAVE, the file can't exist   local soup:=:getNonUnionSoup(filename);   if strEqual(x[0],"SAVE") then      if soup<>nil then begin         :error(kErrorM5);         soup:=nil;         return; end;      systemEntry.programName:=filename;   :copySoupEntries(:makeProgramName(kSoupName),systemEntry.programName);   :addLines([ substr(filename,0,strPos(filename,kExt,0)) && "saved." & CR]);   entryFlushXmit(systemEntry,nil);end;
       ,
     viewFormat: 337,
     coPut:
       func() begin	local args:=:getargs(stmtFrame.internal);	if length(args)<>2 then return (:error(kError63));	if NOT :isaVariable(args[0],true) or NOT :isaVariable(args[1],true) then return;	   	stmtFrame.compiled:=:co(":exPut({			chan: " 		& :getPathExpr(args[0]) & ",			frame: "	& args[1] & "})");					end
     ,
     getNewHeadRec:
       func(subName) begin	if debug then print("Creating new head rec: " & subName);	if _header.ID then entryFlushXmit(_header,nil);	local newHeader, temp;			if not newtCard then begin		if strEqual(subName, "Main") 			then newHeader:=deepClone(kEmptyMainHeader)			else newHeader:=deepClone(kEmptySubHeader)		end	else begin // newtCard		if strEqual(subName, "Main")			then newHeader:=deepClone(kEmptyNewtCardHeader)		else if beginsWith(subName, "bg_") and strLen(subName)<6			then newHeader:=deepClone(kEmptyNewtCardBG)			else newHeader:=deepClone(kEmptySubHeader)		end;		if strEqual(subName, "Main") then newHeader.version:=subStr(kVersion, 8, nil);	newHeader.ID:=:getID();	_sub:=newHeader.sub:=intern(subName);	newHeader:=_workSoup:addXmit(newHeader,nil);		//update header	if newHeader.type<>'bg then begin		local temp:=:getHeader(subName);		temp.subs.(intern(subName)):=newHeader.ID;		entryFlushXmit(temp, nil);		_subs:=temp.subs;		end;			if hasSlot(newHeader, 'coderecs) then begin		_header:=newHeader;		:getNewCodeRec(0);		end;	newHeader;	end
       ,
     intcode: nil,
     coRem: func() stmtFrame.compiled:=:co("NIL");,
     doList:
       func() begin	local line,temp,p,p1,connect,indent1,actionButton;	local indent:=" ";	local list:=[];	local io:=systemEntry.IO;	local outputToScreen:=TRUE;	local pIndent:="";	local work:=_work;	work:reset();	stmtFrame:={err: nil};	local listparms:=:getargs(newStmt);	if length(listParms)=0 then listParms:=["","",nil];	if length(listParms)=1 then   	if endsWith(newStmt,",")   		then listParms:=[listparms[0],"",nil]   		else listParms:=[listparms[0],listparms[0],nil];   		if length(listParms)=2 then listParms:=[listparms[0],listparms[1],nil];	if length(listParms)>=4 then listParms[3]:=floor(stringToNumber(listParms[3])); // lpp	if length(listParms)>=5 then listParms[4]:=floor(stringToNumber(listParms[4])); // cpl	if strEqual(listParms[0],"") then listParms[0]:="0";	if strEqual(listParms[1],"") then listParms[1]:="9999";		for i:=0 to 1 do begin		p:=:labelResolve(listParms[i], nil);		if p			then listParms[i]:=p;			else listParms[i]:=:findStmtApprox(listParms[i], (i=1));		if NOT listParms[i] then return;		end;	if debug then print(listParms);	  	if listParms[2] then begin		listParms[2]:=:stripQuotes(listParms[2]);		// change to io port if specified		local ioOK:=nil;		if getroot().(kShellSymbol).connect then			foreach service in getroot().(kShellSymbol).connect.labelCommands do				if strEqual(listParms[2], substr(service,0,4)) then ioOK:=TRUE;		if ioOK then begin 			connect:updateText(listParms[2]) 			end   	else begin // output to a filename or to routing   		if strEqual(listParms[2],"_action") then begin   			actionButton:=TRUE   			end   		else begin // does file already exist?				if endsWith(listParms[2],".TXT")=nil then listParms[2]:=listParms[2] & ".TXT";   			local listSoup:=:getNonUnionSoup(listParms[2]);   			if listSoup then return (:error(kErrorM5));				listSoup:=defStore:createSoupXmit(listparms[2],[{structure: 'slot, path: 'ID, type: 'int}],nil);				outputToScreen:=NIL;				end   	end	end;		if NOT strEqual(systemEntry.io,"scre") then outputToScreen:=NIL;	if debug then print("List range IDs:" && listParms[0] && listParms[1]);	for i:=listParms[0] to listParms[1] do begin		stmtFrame:=work:gotoKey(_header.listRecs[i]);		      	line:=:doListWidget(stmtFrame.text);		if (beginsWith(line,"NEXT") or     			beginsWith(line,"ELSE") or     			beginsWith(line,"END IF") or     			beginsWith(line,"ENDIF") or    			beginsWith(line,"LOOP") or			beginsWith(line,"END SUB") or			beginsWith(line,"ENDSUB")) and strlen(indent)>1 then indent:=substr(indent,2,nil);				if :scanLabel(line)>0 then indent1:="" else indent1:=" ";		line:=:formatLineNo(stmtFrame.stmtNo) & indent & indent1 & line;		_RF._lastStmtNo:=stmtFrame.stmtNo;    		line:=:doListGOTOComment(listParms,line);    if (p:=strPos(line,"Â",0)) then begin // split line on Â characters     	addArraySlot(list, substr(line,0,p+1) & CR);     	if systemEntry.prettyPrint then pIndent:="     " & indent1;     	while p do begin     		if (p1:=strPos(line,"Â",p+1))     			then addArraySlot(list, pIndent & substr(line,p+1,p1-p) & CR);     			else addArraySlot(list, pIndent & substr(line,p+1,nil) & CR);     		p:=p1;     		end    	end    else addArraySlot(list,line & CR); 		   		if NOT actionButton then begin			if NOT outputToScreen and length(list)>20 then begin				:doListOutput(listparms,list,listSoup);				list:=[];				end			end		else begin // called from action button: just return the results			listParms[3]:=listParms[3]-floor(strlen(line)/listParms[4]); // adjust for long lines			if length(list)>listParms[3] then return [list, _RF._lastStmtNo];			end;					if beginsWith(stmtFrame.text,"FOR") or		  (beginsWith(stmtFrame.text,"IF") and endsWith(stmtFrame.text, "THEN")) or		  beginsWith(stmtFrame.text,"ELSE") or			beginsWith(stmtFrame.text,"DO") or			beginsWith(stmtFrame.text,"SUB") then indent:=indent & "  ";      		end;		if NOT actionButton 			then :doListOutput(listparms,list,listSoup)			else return [list, nil];	// set io back to previous setting 	if NOT strEqual(io, systemEntry.io) then connect:updateText(io); end
       ,
     doVars:
       func() begin	local userVariables:={};	foreach slot, value in _RF do		if NOT beginsWith(sPrintObject(slot), "_") then userVariables.(slot):=value;	:addLines(executor:printFrame(userVariables));	end
     ,
     getNewSoup:
       func(shortName) begin	local name:=:makeProgramName(shortName);	if debug then print("getNewSoup:" && name);	_workSoup:=:getNonUnionSoup(name);	if _workSoup then begin		:notify(kNotifyAlert, name && "Already exists.");		return		end;		_workSoup:=defStore:createSoupXmit(name,kSoupIndexes,nil);					_work:=_workSoup:query({indexpath: 'ID});		if newtCard		then _header:=deepclone(kEmptyNewtCardHeader)		else _header:=deepclone(kEmptySubHeader);	_header.name:=shortName;	_header.version:=subStr(kVersion, 8, nil);	_header.lastID:=0;	_sub:=_header.sub:='main;	_header.ID:=kMainSub;	_header.subs.main:=kMainSub;	_workSoup:addXmit(_header,nil);	if hasSlot(_header, 'codeRecs) then :getNewCodeRec(_RF._codeRecPos:=0);	_subs:=_header.subs;		_workSoup	end
     ,
     findLabel:
       func(label) // given a label, sets code chunk and returns offset	_RF:chGetXLine(_header.labels.(label))
       ,
     isSpecialVariable:
       func(v) begin	// return symbol if the variable is one that exists outside of _RF	if beginsWith(v, "stack.") then return 'stack;	if beginsWith(v, "background.") then return 'background;	if beginsWith(v, "card.") then return 'card;	return NIL;	end
       ,
     viewQuitScript: func() :saveHeader();,
     coDef:
       func() begin	local p,p0,p1,stmt;	stmtFrame.keyword:=kFUNCTION;	stmt:=stmtFrame.display;	p0:=strPos(stmt,"(",0);		p1:=strPos(stmtFrame.internal,"(",0);	p2:=strPos(stmtFrame.internal,"=",0);	p3:=strPos(stmtFrame.display,"=",0);	if p1=NIL or p2=NIL then return (:error(kerror2));			while (p:=strPos(stmt,"Â",0)) do stmt:=substr(stmt,0,p) & substr(stmt,p+1,nil);	stmtFrame.compiled:=:co("_RF." & substr(stmtFrame.internal,1,p1-1) & ":=" &									"func" & subStr(stmt,p0,p3-p0) &&									subStr(stmt,p3+1,nil))	end
     ,
     saveCode:
       func(lineNo, keyword, compiled) begin	// add a new code to the proper codeRec	if kChunkTrace then print("C: saveCode " & lineNo);	local codePos;	local header:=_header;	local work:=_work;		// get the correct codeRec and position to insert	codePos:=_RF:chGetXLine(lineNo);	if codePos=-1 then begin		if _RF._codeRecPos<>length(header.codeRecs)-1			then _RF._ch:=work:gotoKey(header.codeRecs[_RF._codeRecPos:=length(header.codeRecs)-1]);		codePos:=_RF._ch.codeLen+1		end;	if kChunkTrace then print("C: saveCode " && _RF._codeRecPos && codePos);		arrayInsert(_RF._ch.code,compiled,codePos);	arrayInsert(_RF._ch.keywords,keyword,codePos);	_RF._ch.codeLen:=length(_RF._ch.code)-1;	entryFlushXmit(_RF._ch,nil);			// adjust the counts in cumLines	:updateLineNo(lineNo,1);		if length(_RF._ch.code)>kMaxChunkSize/120 then begin		:saveHeader();		:CheckChunkOverflow();		end;	if kChunkTrace then print("C: saveCode complete"); 	if kChunkTrace then print(_RF._ch); 	end
       ,
     printProgramRecords:
       func(recList) begin	local output:=CR & sPrintObject(recList) & CR;	local work:=_work;	local rec;	foreach ID in header.(recList) do begin		rec:=work:gotoKey(ID);		output:=output & executor:getformatArbObject(rec) & CR;		end;	return output;end
     ,
     coDimParse:
       func(arg) begin	local rhs;	arg:="self." & trimString(arg);	local s:=strPos(arg,"[",0);	if endsWith(arg,"_") or strPos(arg,"_[",0) then rhs:=quote & quote else rhs:="0";	if s=nil		then arg:=arg & ":=" & rhs;		else arg:=substr(arg,0,s) & ":=array(" & substr(arg,s+1,strLen(arg)-s-2) & "," & rhs & ")";	return argend
     ,
     coWait:
       func() begin	if stmtFrame.internal=nil or strEqual(stmtFrame.internal,"") then stmtFrame.internal:="5000";	stmtFrame.compiled:=:co(":exWait(" & trimString(stmtFrame.internal) & ")");	end
     ,
     doLoadx:
       func(filename) begin	local filename:=trimString(:stripQuotes(filename));	if strEqual(kTimeOut,"DEMO") then filename:="DEMO";	local err:=nil;	if endsWith(fileName,kExt)=nil then filename:=filename & kExt;	if debug then print("loading" && filename);      	// file must exist on one of the stores	soup:=:getNonUnionSoup(filename);	if soup=nil then return (:error(kErrorM10));	:saveHeader();	_RF:hideUserViews();		// Check the version	local workq:=soup:query({indexpath: 'ID});	_header:=workq:gotoKey(kMainSub);	if not hasSlot(soup._proto.indexes[1], 'rev)		or soup._proto.indexes[1].rev<>4 then begin   	:error(kError48);		:addLines([substr(kVersion,8,3) && substr(_header.version,0,3) & CR]);		:doNew();		return NIL   	end;   // clear out work file first   systemEntry.programName:=:makeProgramName(filename);   entryFlushXmit(systemEntry,nil);	work:=nil;	_RF:initSymbolTable();   	if systemEntry.useScratch then begin   	// Copy the entries to the work soup   	:copySoupEntries(systemEntry.programName,:makeProgramName(kSoupName));		_workSoup:=:getNonUnionSoup(:makeProgramName(kSoupName));   	   	end   	  else _worksoup:=soup;   	_work:=_workSoup:query({indexpath: 'ID});	_sub:='main;	_header:=_work:gotokey(kMainSub);	_header.version:=subStr(kVersion,8,nil);	_subs:=_header.subs;	if hasSlot(_header, 'coderecs) 	then _RF._ch:=_work:gotoKey(_header.codeRecs[_RF._codeRecPos:=0]);	return trueend
       ,
     co:
       func(codetext) begin	local code;	if kShowCompile then print("compiling:" & codetext);	intcode:=codetext;	try code:=compile(codetext);	onexception |evt.ex| do :error(kError2);	code	end
     ,
     interpret:
       func() begin	if debug then print("Interpret:" & stmtFrame.display);	if kShowCompile then print(stmtFrame.display);	call kshowBusyBoxFunc with (TRUE);	:scanner();	y:=coTable[stmtFrame.keyword];	try :y()	onexception |evt.ex| do :error(kError2);end
     ,
     viewFlags: 1,
     coOn:
       func() begin	local stmt:=stmtFrame.internal;	local gosub:=nil;	local go:=strPos(stmt," GOTO ",0);	local targets:="";	local type:="'goto";	local test:="NIL";	local lineNo;	if go=NIL then begin		go:=strPos(stmt," GOSUB ",0);		type:="'gosub";		end;	if go=nil then return (:error(kError2));	local displayGo:=strPos(stmtFrame.display," GO",0);	if NOT beginsWith(stmt,"ERROR ")		then test:="floor(" & subStr(stmt,0,go) & ")"		else type:="'onError";  	   	stmtFrame.display:=trimString(subStr(stmtFrame.display,0,displayGo)) && 		trimString(subStr(stmt,go+1,5)) & " ";	if strEqual(type, "'gosub") then go:=go+6 else go:=go+5;   		foreach arg in :getargs(substr(stmtFrame.internal,go,nil)) do begin		targets:=targets & "'" & :labelMake(arg) & ",";		if NOT isReal(stringToNumber(arg))			then stmtFrame.display:=stmtFrame.display & arg & ",";			else stmtFrame.display:=stmtFrame.display & :formatLineNo1(arg) & ",";		end; 	targets:=substr(targets,0,strLen(targets)-1);	if debug then print("targets:" && targets);	stmtFrame.display:=substr(stmtFrame.display,0,strLen(stmtFrame.display)-1);   	// ON ERR GOTO can only have 1 line number	if strEqual(type, "'onError") and charPos(targets,$, ,0) then return (:error(kError2)); 	stmtFrame.compiled:=:co(":exON({									type:" & type & ",									test: " & test & ",									targets: [" & targets & "]})")	end
       ,
     doRun:
       func() begin	if debug then print("doRun:" & newStmt);	if kProfileOn then print("Profiling Enabled");	if kProfileOn then enableProfiling(TRUE);	local args,fileName,startLineNo;	:saveHeader();	args:=:getArgs(newStmt);	if debug then print(args);		if length(args)=0 then args:=[nil,nil];	if length(args)=1		then if beginsWith(args[0],quote)			then args:=[args[0],nil]			else args:=[nil,args[0]];	fileName:=:stripQuotes(args[0]);	if fileName then begin		 if NOT beginsWith(filename,"PKG:") then begin		 		if args[1] then executor.dontInitSymbolTable:=TRUE;				if :doLoadX(fileName)=nil // load a soup program								then begin :addLines(["* "]); return NIL; end; // file not found				end			else begin // lo fat package				filename:=substr(filename,4,nil);				_RF._ch:=program:=getroot().(intern(filename & ":" & kSignature)).program; // run a packaged program				_header:=getroot().(intern(filename & ":" & kSignature)).programHeader;				systemEntry.programName:=clone(filename);				if NOT program then return :error(kErrorM10);				end;		end;						if IamFat then begin // running as a fat package		_RF._ch:=program;		_header:=programHeader;		end;		if _sub<>'main and not (newtcard and editor) then begin		:saveHeader();		_sub:='main;		_header:=executor:getEntry(kMainSub);		end;			if args[1] and NOT strEqual(args[1],"NIL") then begin		startLineNo:=:labelResolve(args[1], true);		if stmtFrame and stmtFrame.err then return NIL;		end	else startLineNo:=NIL;	if debug then print(filename && startLineNo);	if startLineNo then begin		if _RF:chGetXLine(startLineNo)=-1 then begin :error(kError13); :addlines(["* "]); return end;		end	else begin		:init_RF();		_RF:initSymbolTable();		_RF:loadSubs(nil);		if NOT program then _RF._ch:=_work:gotoKey(_header.codeRecs[_RF._codeRecPos:=0]);		if _RF._ch=NIL 			then :getNewCodeRec(0)								else _RF._codePos:=0;		end;	if _RF._codePos=-1 or length(_header.cumLines)=0 then begin		_RF:setRunStateOff();		editor:addLines(["* "]);		return NIL;		end;	if debug then print("codePos=" & _RF._codePos);	_RF._runFlag:=0;      // =0 means next statement, >0 statement to branch to, nil=stop execution	_mainRF._runState:=TRUE;	_RF._lastLineNo:=0;	executor:initdataPtr();	if NOT systemEntry.enableBreak // actually execute the program		then _RF:doRun1() // actually execute the program		else :doAda(func() _RF:doRun1withBreak(), '[], 1); 	if _RF._codePos=-1 then _RF:setRunStateOff();	if kProfileOn then enableProfiling(NIL);	end
       ,
     findStmtApprox:
       func(stmtNo, up) begin	// this function returns the lineNo of the next one (UP) from stmtNo	// stmtNo is a string	// up is TRUE if next one up, NIL is one back	local Ltext,LStmtNo, low, high, lowLineNo, highLineNo;	stmtNo:=stringToNumber(stmtNo);	if not stmtNo then return NIL;	stmtNo:=floor(stmtNo);	low:=0;	high:=9999;		foreach label, lineNo in _header.labels do begin		Ltext:=sPrintObject(label);		if strLen(LText)>1 then LStmtNo:=stringToNumber(substr(LText,1,nil)) else LStmtNo:=NIL;		if beginsWith(LText, "L") and LStmtNo then begin			LStmtNo:=floor(LStmtNo);			if LStmtNo>low and LStmtNo<=stmtNo then begin				low:=LStmtNo;				lowLineNo:=lineNo;				end;			if LStmtNo<high and LStmtNo>=stmtNo then begin				high:=LStmtNo;				highLineNo:=lineNo;				end			end // beginsWith		end; // foreach	if debug then print("FindStmtApprox:" & stmtNo && low && high);			if up then return lowLineNo else return highLineNo;	end
       ,
     copySoupEntries:
       func(fromSoupName,toSoupName) begin	if debug then print("CopyFile" && fromSoupName && toSoupName);	local fromSoup:=:getNonUnionSoup(fromSoupName); 	local toSoup:=:getNonUnionSoup(toSoupName);   	if toSoup then toSoup:RemoveFromStore();	tosoup:=defStore:createSoupXmit(toSoupName,kSoupIndexes,nil);	   	fromSoup:copyEntriesXmit(toSoup,nil);	end
     ,
     isaVariable:
       func(s, showError) begin  // is s a valid variable name?  // must start with a letter and be followed by any number of valid chars  local OK:=TRUE;  if NOT isString(s) or 		strLen(s)=0 or		NOT strPos("abcdefghijklmnopqrstuvwxyz_",substr(s,0,1),0) then OK:=NIL;  	if strLen(s)=1 then return OK;  		  for i:=1 to strLen(s)-1 do begin  	if s[i]=$[ or s[i]=$. then break;    if NOT strPos(kAlphaNumeric,substr(s,i,1),0) then OK:=NIL;    end;    	if showError and not OK then :error(kError10);	return OK;	end
       ,
     doBye: func() if not Newtcard then _RF:exBye(nil);,
     doCon:
       func() begin	if debug then print("doCon");	if _RF._codePos=-1 then begin		:addLines([:prompt()]);		return NIL		end;	if executor.basicAlphaInUse and visible(editor.basicAlpha) then begin		if debug then print("Hiding Keyboard");		editor.BasicAlpha:hide();		end;	_mainRF._runstate:=true;	if _RF:chGetXLine(_RF._lastLineNo) then _RF:resumeExecution();end
     ,
     coExit:
       func() begin	local stmt:=stmtFrame.internal;	local keyword:=NIL;	if beginsWith(stmt,"DO") then keyword:=kDo;	if beginsWith(stmt,"FOR") then keyword:=kFor;	if keyword=NIL then return (:error(kError2));		stmtFrame.compiled:=:co(":exExit(" & keyword & ")");	end
     ,
     coLOOP: func() stmtFrame.compiled:=:co(":exLoop(" & :coDoExp() & ")");,
     doRevUp:
       func() begin	if newtcard then return :error(kError2);	if not modalConfirm("Warning! REVUP recompiles all of your programs and cannot be interrupted. It will take a few minutes to run.", 'okCancel) then return;	foreach filename in :getDirList('doRevUp) do begin		filename:=substr(filename,0,strLen(filename)-1);		:addLines(["Rev Up" && filename & CR]);		refreshviews();		if debug then print("revup" && filename);		:doNew();		executor:exEnter(filename & kExt);		:addlines(["Saving" && filename & "..." & CR]);		executor:exDelete(filename & kExt);		workSoup:setName(filename & kExt);		workSoup:=defStore:createSoupXmit(:makeProgramName(kSoupName),kSoupIndexes,nil);		work:=workSoup:query({type: 'index, indexPath: 'lineNo});	endend
     ,
     doStrip:
       func() begin	if newtcard then return :error(kError2);	if not modalConfirm("Warning! STRIP removes all LIST statements from your current program.", 'okCancel) then return;	// remove all printable statements from program file	local filename, soup, work, stmtFrame, subHeader;	local header:=_header;	if NOT endsWith(newStmt, kExt)    	then filename:=trimString(newStmt) & kExt   	else filename:=newStmt;	if newStmt=NIL then filename:=systemEntry.ProgramName;	if debug then print("Stripping:" && filename);	if strEqual(filename,:makeProgramName(kSoupName)) then return;	foreach headID in header.headrecs do		subHeader:=work:gotoKey(headID);		foreach ID in subHeader.listrecs do			entryRemoveFromSoup(work:gotoKey(ID));		subHeader.stmtNos:=[];		entryFlushXmit(subHeader,nil);	end
       ,
     labelMake:
       func(stmtNo) begin	// turn statement number or label 	// into a label symbol for _header.labels table	if isReal(stringToNumber(stmtNo)) then stmtNo:="L" & floor(stringToNumber(stmtNo));	return intern(stmtNo);	end
       ,
     doListOutput:
       func(listparms, list, listSoup) begin	// output contents of list	if list=NIL then return NIL;   if listparms[2]=nil or (strEqual(listParms[2],"EXTR") or strEqual(listParms[2],"INFR"))   	then :addLines(list)   	else // output to list file    		foreach line in list do    			listSoup:addXmit({sub: _sub, ID: floor(StringToNumber(subStr(line,0,4))), 									text: subStr(line,0,strLen(line)-1)}, nil);end
       ,
     coEnter:
       func()		stmtFrame.compiled:=:co(":exEnter(" &  trimString(stmtframe.internal) & ")");
     ,
     scanner_FixwidgetRefs:
       func(stmt) begin	local p, newstmt, atom1, atom2, c, chars, type, isCard, startpos;	if debug then print("scanner_fixWidgetRefs" && stmt);	if not strPos(stmt,"CARD ",0) and 		 not strPos(stmt,"BACKGROUND ",0) then return stmt;	if beginsWith(stmt, "GO ") then startPos:=3 else startPos:=0;	for i:=0 to strLen(stmt)-1 do begin		while strEqual(subStr(stmt,i,2),"  ") do i:=i+1; // trim multi blanks		c:=subStr(stmt,i,1);		if strEqual(c,quote) then begin   // just pass thru quoted strings         			if (endp:=charPos(stmt,$",i+1)) then // handle \" type strings				while stmt[endp-1]=$\\ do begin					endp:=charPos(stmt,$",endp+1);					if NOT endp then break					end;			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end quote - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$";				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & quote;				i:=strLen(stmt)				end      end // if strEqual(c,quote)      			else if strEqual(c,"|") then begin   // just pass thru strings in bars			endp:=charPos(stmt,$|,i+1);			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end | - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$|;				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & "|";				i:=strLen(stmt)				end      end // strEqual(c,"|")    	else begin // it's not a comment or |literal|, so let's rock! 			if ((isCard:=:isWidgetRef(substr(stmt,i,nil),"CARD")) or 				:isWidgetRef(substr(stmt,i,nil),"BACKGROUND") ) 				and i>startPos then begin 								 				// get next atom 				i:=i+(if isCard then 5 else 11); // length of word+1 				while strEqual(subStr(stmt,i,2),"  ") do i:=i+1; // trim multi blanks 				atom1:=""; 				for char:=i+1 to strLen(stmt)-1 do 					if charPos(kAlphaNumeric,stmt[char],0)  						then atom1:=atom1 & stmt[char] 						else break; 				newStmt:=newStmt & c; 														// get following atom 				i:=i+(if strEqual(atom1,"FIELD") then 6 else 7); // length of word+1 				while strEqual(subStr(stmt,i,2),"  ") do i:=i+1; // trim multi blanks 				atom2:=""; 				for char:=i+1 to strLen(stmt)-1 do 					if charPos(kAlphaNumeric,stmt[char],0)  						then atom2:=atom2 & stmt[char] 						else break;								// combine				local bgcd:=(if isCard then "card" else "background"); 				newStmt:=newStmt & "_bgcd." & bgcd & "._widgets." & atom2 & ".("; 				newStmt:=newStmt & bgcd; 				newStmt:=newStmt & ".widgets." & atom2 & ".contents/**/)"; 						//  /**/ is a comment that tells OF this is a widgetPath 				i:=i+strLen(atom2);  			end  		else newStmt:=newStmt & c;   		end; 	end; // for i     	newStmt	end;
       ,
     newStmt: nil,
     isWidgetRef:
       func(s, word) begin	// check to see s begins with a separator character followed by word and a blank	// examples: " CARD ", "(BACKGROUND ", "<CARD ";	if not charPos(kSeparators, s[0], 0) then return NIL;	return beginsWith(substr(s,1,nil), word & " ")	end;
       ,
     coOpen:
       func() begin	local args:=:getargs(stmtFrame.internal);	if length(args)<>2 and length(args)<>3 then return (:error(kError63));	if NOT :isaVariable(args[0],true) or   // first arg must be a variable	   (beginsWith(args[1],quote) or :isaVariable(args[1],true))=nil	// 2nd is " " or variable	   then return;	local querySpec:="{type: 'index}";	if length(args)=3 		then queryspec:="{type: 'index, indexPath: '" & args[2] & "}";	stmtFrame.compiled:=:co(":exOpen({										chan: " 		& :getPathExpr(args[0]) & ",										filename: " & args[1] & ",										querySpec: " & querySpec & "})");end
       ,
     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     coWPrint:
       func() begin	local arg:=:getargs(stmtFrame.internal);	if length(arg)<>2 then return (:error(kError63));	stmtFrame.compiled:=:co(":exWprint({			win: " & arg[0] & ",			value: " & arg[1] & "})");end
     ,
     coClose:
       func() begin	local code:=":exClose([ ";	foreach arg in :getArgs(stmtFrame.internal) do		code:=code & trimString(arg) & ",";	code:=substr(code,0,strLen(code)-1) & "])";	stmtFrame.compiled:=:co(code);		end
     ,
     scanner_THE:
       func(stmt) begin	local p, newstmt, atom1, atom2, c, chars;	if not strPos(stmt," THE ",0) and not strPos(stmt," THIS ",0) then return stmt;	for i:=0 to strLen(stmt)-1 do begin		while strEqual(subStr(stmt,i,2),"  ") do i:=i+1; // trim multi blanks		c:=subStr(stmt,i,1);		if strEqual(c,quote) then begin   // just pass thru quoted strings         			if (endp:=charPos(stmt,$",i+1)) then // handle \" type strings				while stmt[endp-1]=$\\ do begin					endp:=charPos(stmt,$",endp+1);					if NOT endp then break					end;			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end quote - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$";				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & quote;				i:=strLen(stmt)				end      end // if strEqual(c,quote)      			else if strEqual(c,"|") then begin   // just pass thru strings in bars			endp:=charPos(stmt,$|,i+1);			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end | - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$|;				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & "|";				i:=strLen(stmt)				end      end // strEqual(c,"|")    	else begin // it's not a comment or |literal|, so let's rock!   		if beginsWith(substr(stmt,i,nil)," THE ")   			then i:=i+3  		  		else if beginsWith(substr(stmt,i,nil)," THIS ")   			then i:=i+4;  		else newStmt:=newStmt & c;   		end; 	end; // for i     	newStmtend
       ,
     coNext:
       func() begin	local var:=trimString(stmtFrame.internal);	if NOT :isaVariable(var,true) then return;		stmtFrame.compiled:=		:co(":exNext(" & quote & var & quote & ")");	end
     ,
     visualDesignerReturn:
       func(text) begin	// this is called by the VisualDesigner, so it runs from that context	if debug then print("visualDesignerReturn");	if debug then print(text);	call kShowBusyBoxFunc with (true);	local baseView:=getroot().(kShellSymbol);	local newStmt;	local stmtFrame:=baseView.interpreter.stmtFrame;	local p:=strPos(stmtFrame.text, ":=",0);	if NOT p 		then newStmt:=stmtFrame.text & ":=" & text;		else newStmt:=substr(stmtFrame.text,0,p+2) & text;	if debug then print(newStmt);				local p1:=strPos(newStmt & " "," ",0);	local command:=numberStr(stmtFrame.stmtNo);	if debug then print(command & "," & newStmt);	baseView.editor.textLinesHold:=[];		baseView.interpreter.scanQuick:=true;	baseView.editor:handleInputLine(command && newStmt);	if strEqual(baseView.systemEntry.io, "SCRE") and baseView.systemEntry.showKeyboard		then baseView.basicAlpha:open();	getroot().|visualDesigner:NSB|.chainCallBackFunc:=nil;	baseView.noQuitAllowed:=NIL;	end
       ,
     labelDelete:
       func (labelFrame, lineNo) begin // get rid of labels pointing to lineNo	if kChunkTrace then print("labelDelete:" & lineNo);		local deleteList:=[];			foreach label, l in labelFrame do 		if lineNo=l then addArraySlot(deleteList, label);			foreach label in deleteList do 		removeSlot(labelFrame, label);			if kChunkTrace then print(labelFrame);	end
       ,
     doRenum2:
       func(keyword,slist,parms) begin	local line,l,itemChanged, changed,s1,s,p,x;	s:=stmtFrame.text;	p:=0;	s1:="";		while p do begin // do for each occurance of the keyword in s		p1:=strPos(s,keyword,p);		if NOT p1 then break;		p1:=p1+strLen(keyword);		while p1<strLen(s) and s[p1]=$  do p1:=p1+1;    // skim blanks		if strEqual(keyword,".GOTO") or 			strEqual(keyword,".GOSUB") then begin // take care of .GOTO  and .GOSUB = 9999				if s[p1]<>$= then return NIL;				p1:=p1+1;				while s[p1]=$  and p1<strLen(s) do p1:=p1+1; // skim blanks				end;		s1:=s1 & substr(s,p,p1-p);		if debug then print(s && s1);		p:=p1;				loop begin	// handle a list of line numbers as in ON GOTO...					while strPos("0123456789",subStr(s,p1,1),0) and p1<strLen(s) do p1:=p1+1;			if debug then print("p,p1=" && p && p1);			x:=stringToNumber(subStr(s,p,p1-p));			if x=NIL or x<1 or x>9999 then break; 				line:=:formatLineNo1(subStr(s,p,p1-p));			if debug then print(Line);			itemChanged:=nil;			foreach l in slist do				if strEqual(line,:formatLineNo(l.oldline)) then					changed:=itemChanged:=s1:=s1 & :formatLineNo(l.newline);								if itemChanged=NIL then s1:=s1 & line;						if strCompare(line,:formatLineNo(parms[0]))>=0 					and strCompare(line,:formatLineNo(parms[1]))<=0 					and itemChanged=NIL			then begin				changed:=s1:=s1 & "0000";				:addLines([stmtFrame.stmtNo-kListBase & ":Warning: Renumbering error" & CR]);				end; // if 			p:=p1;			if p>=strLen(s)-1 then break;		 	if s[p]<>$, then break;		 	p1:=p:=p+1;		 	s1:=s1 & $,		end; // while going thru list of line numbers, as in ON...	end; // while looking for multiple keywords		if NOT changed then return NIL;	if p<strLen(s) then s1:=s1 & substr(s,p,nil);	if debug then print(s1);		stmtFrame.text:=s1;	TRUE	end
       ,
     formatLineNo:
       func(LineNo) executor:formatLineNo(lineNo)// takes a numeric line number and returns line number as "0000"	
       ,
     coLet_widgetRef:
       func() begin	//reformats _bgcd.card._widgets.myWidget.property=value as	//          setvalue(_bgcd.card._widgets.myWidget,'property, deepclone(value))		local s:=stmtFrame.internal;	local frame, property, value, p, p1, p2, arg;		// Does it qualify to be reformatted?	if not beginsWith(s, "_bgcd.") OR	   not (p2:=strPos(s,"=",0)) then return nil;		p:=strPos(s, "._widgets.", 0); // scan past "_bgcd.(backgroundMode)._widgets."	p:=charPos(s, $., p+10);	frame:=substr(s,0,p);			p1:=strPos(s,"/**/",0);	if p1 then begin // simple "card field x" implies "(contents) of ..."		p1:=p1-p-2;		property:=substr(s,p+2,p1);		end			else begin // more complex "y of card field x"		p1:=strPos(s,"=",0)-p-1; // more complex "y of card field x"		property:="'" & substr(s,p+1,p1);		end;	value:=substr(s,p2+1,nil);		arg:="setvalue(" & frame & "," & property & "," & "deepClone(" & value & "))";	if debug then print(arg);		stmtFrame.compiled:=:co(arg);	TRUE // expression handled	end
       ,
     scanner_OF:
       func(stmt) begin	local p, newstmt, atom1, atom2, c, chars;	if debug then print("scanner_OF" && stmt);	if not strPos(stmt," OF ",0) then return stmt;		for i:=0 to strLen(stmt)-1 do begin		while strEqual(subStr(stmt,i,2),"  ") do i:=i+1; // trim multi blanks		c:=subStr(stmt,i,1);		if strEqual(c,quote) then begin   // just pass thru quoted strings         			if (endp:=charPos(stmt,$",i+1)) then // handle \" type strings				while stmt[endp-1]=$\\ do begin					endp:=charPos(stmt,$",endp+1);					if NOT endp then break					end;			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end quote - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$";				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & quote;				i:=strLen(stmt)				end      end // if strEqual(c,quote)      			else if strEqual(c,"|") then begin   // just pass thru strings in bars			endp:=charPos(stmt,$|,i+1);			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end | - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$|;				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & "|";				i:=strLen(stmt)				end      end // strEqual(c,"|")    	else begin // it's not a comment or |literal|, so let's rock!  		if beginsWith(substr(stmt,i,nil)," OF ") then begin  			// get previous atom				atom1:="";				for char:=strLen(newStmt)-1 to 0 by -1 do					if charPos(kAlphaNumeric,newStmt[char],0)						then atom1:=newStmt[char] & atom1						else break; 								 				// get next atom 				i:=i+3; 				while strEqual(subStr(stmt,i,2),"  ") do i:=i+1; // trim multi blanks 				atom2:=""; 				for char:=i+1 to strLen(stmt)-1 do 					if charPos(kAlphaNumeric & ")",stmt[char],0) 							or strEqual(substr(stmt, char-1,2),".(")							or strEqual(substr(stmt, char,2),").") 						then atom2:=atom2 & stmt[char] 						else break; 				if strEqual(substr(stmt, i+strLen(atom2)+1, 5),"/**/)") then atom2:=atom2 & "/**/)"; 						 				// if it's a widgetPath, truncate the (...contents/**/)				i:=i+strLen(atom2);				if endsWith(atom2, "contents/**/)") then begin					p:=strLen(atom2)-13;					while atom2[p]<>$( do p:=p-1;					atom2:=substr(atom2,0,p-1);					end;									// combine		 				newStmt:=substr(newStmt,0,strLen(newStmt)-strLen(atom1)) & atom2 & "." & atom1;  			end  		else newStmt:=newStmt & c;   		end; 	end; // for i     	newStmtend
       ,
     checkChunkOverFlow:
       func() begin	local ch:=_RF._ch;	if kChunkTrace then print("C: CheckChunkOverFlow:" & entrySize(ch));	// check to see if current chunk is overflowing	if entrySize(ch)<=kMaxChunkSize then return NIL;		// split block	local newCode:=clone(ch.code);	local newKeywords:=clone(ch.keywords);	local splitLine:=floor(length(newCode)/2);	//rewrite low half	setLength(ch.code,splitLine);	setLength(ch.keywords,splitLine);	ch.codeLen:=length(ch.keywords)-1;	if kChunkTrace then write("C: .low half:");	if kChunkTrace then print(ch.keywords);	:saveHeader();	//write out high half	:getNewCodeRec(_RF._codeRecPos);	ch:=_RF._ch;	arrayRemoveCount(newCode,0,splitLine);	arrayRemoveCount(newKeywords,0,splitLine);	ch.code:=newCode;	ch.keywords:=newKeywords;	ch.codeLen:=length(ch.keywords)-1;	if kChunkTrace then write("C: .high half:");	if kChunkTrace then print(ch.keywords);	local header:=_header;	header.cumLines[_RF._codeRecPos-1]:=header.cumLines[_RF._codeRecPos-1]-ch.codeLen-1;	header.cumLines[_RF._codeRecPos]:=  header.cumLines[_RF._codeRecPos-1]+ch.codeLen+1;	:saveHeader();	end
       ,
     doModule:
       func() begin	if debug then print("doModule:" & newstmt);	local header:=_header;	local subName:=trimString(newStmt);	local work:=_work;	local newHeader:=nil;		if strLen(subName)=0 then begin //display list of subs and return		local lines:=[];		foreach name, ID in _subs do			if name=_sub				then addArraySlot(lines, name & "<-- Currently Selected" & CR)				else addArraySlot(lines, name & CR);		:addLines(lines);		return		end;			if not :isaVariable(subName,nil) then return (:error(kError9));			local subNameSymbol:=intern(subName);	if newtcard then executor:openRF({_context: subNameSymbol});			//read in appropriate header	local temp:=:getHeader(subName);	_subs:=temp.subs;	if _subs.(subNameSymbol) 		then newHeader:=executor:getEntry(_subs.(subNameSymbol));		if not newHeader or newHeader.sub<>subNameSymbol then begin // create new sub		if debug then print("Creating new sub:" & subName);		entryFlushXmit(header,nil);		newHeader:=:getNewHeadRec(subName);		if subNameSymbol<>'main 			then if not newtCard				then :doAda(func() postKeyString(editor, "0010 sub " & subName & "()"),'[],3)				else :doAda(func() postKeyString(editor, "0010 sub " & subName & "()" & CR), '[], 3);		end;	_header:=newHeader;	_sub:=subNameSymbol;	_rf._codePos:=-1;			//_RF:initSymbolTable();	:saveHeader();   	end
       ,
     format:
       func(number,len) begin	local x:=numberstr(number);	return substr("          ",0,max(0,len-strLen(x))) & x	end
     ,
     coInput:
       func() begin	local vars:="";	local varTypes:="";	foreach arg in :getargs(stmtFrame.internal) do begin		if NOT :isaVariable(arg,true) then return; 		vars:=vars & :getPathExpr(arg) & ",";		if :isaStringVar(arg)			then varTypes:=varTypes & "'string,"			else varTypes:=varTypes & "NIL" & ","         end; 	stmtFrame.compiled:=:co(":exInput({									vars: [" & substr(vars,0, strLen(vars)-1) & "],									varTypes: [" & substr(varTypes,0, strLen(varTypes)-1) & "]})")   	end
     ,
     doStats:
       func() begin	local stmtCount,textSize,codeSize,dataSize,prog,text, stmt;	stmtCount:=textSize:=codeSize:=dataSize:=headsize:=0;	local work:=_work; 	work:reset();	stmt:=work:entry();				while stmt<>nil do begin		if stmt.type='list then begin			stmtCount:=stmtCount+1;			textSize:=textSize+entrySize(stmt)			end		else if stmt.type='code then codeSize:=codeSize+entrySize(stmt)		else if stmt.type='data then dataSize:=dataSize+entrySize(stmt)		else if stmt.type='head then headSize:=entrySize(stmt);		stmt:=work:next();		end;   	gc();	prog:=systemEntry.programName;	if prog=NIL then prog:="" else prog:=substr(prog,0,strPos(prog,kExt,0));	text:=prog & CR & 		:format(textsize,6) && "bytes used for" && stmtCount && "statements" & CR &		:format(codesize,6) && "bytes used for code space" & CR &		:format(datasize,6) && "bytes used for data space" & CR &		:format(headsize,6) && "bytes used for header" & CR &		:format(stats(),6)  && "bytes free variable space." & CR;   :addLines(executor:printFrame({CurrentProgram: text, Build: kBuildTime & CR, ENV:systemEntry}));               end
     ,
     addLines: func(lines) if editor then editor:addLines(lines),
     getArgs: func(s) executor:getArgs(s),
     doNew:
       func() begin	if newtCard then begin		if not modalconfirm("Clear the script completely?", 'okCanceldefaultCancel)			then return;		local sub:=_header.sub;		:doAda(func() screenView:close(), '[], 32);		executor:deleteASub(sub);		return;		end;			if useScratchBox and useScratchBox.viewValue=NIL then begin		useScratchBox:togglecheck();		systemEntry.useScratch:=TRUE;		end;		_workSoup:=:getNonUnionSoup(:makeProgramName(kSoupName));	if _workSoup then _workSoup:removeAllEntries();	// put in header record	_sub:='main;	_workSoup:addXmit(deepclone(kEmptyMainHeader),nil);	 	_work:=_workSoup:query({indexpath: 'ID});	_header:=_work:gotoKey(kMainSub);	_header.version:=subStr(kVersion, 8, nil);	_subs:=_header.subs;	systemEntry.ProgramName:=:makeProgramName(kSoupName);	_RF:initSymbolTable();	:getNewCodeRec(0);	:saveHeader();	:init_RF();	end
       ,
     coEndIF:
       func() begin	stmtFrame.keyword:=kEndIf;	stmtFrame.compiled:=:co(":exEndIf()");	end;
     ,
     coRm: func() begin	stmtFrame.keyword:=kDELETE;	:coDelete();	end,
     doListWidget:
       func(line) begin	if NOT beginsWith(line, "widget") then return trimstring(line);	if systemEntry.listWidgets then begin		//put a line continuation every n chars, if not there already		if NOT strPos(line, "Â",0) then			for i:=60 to strLen(line) by 60 do				if i<=strLen(line) then line:=subStr(line,0,i) & "Â" & substr(line,i,nil);		return line;		end;		local p:=strPos(line, ":=",0);	if NOT p then return line;	return substr(line,0,p);	end
       ,
     doRenum:
       func() begin	local endline, s, done, txt, worksoup1, work1, l, p;	local slist:=[];	local parms:=:getargs(newStmt);	if length(parms)=0 then parms:=["1","9999","10","10"];	if length(parms)=1 then parms:=[parms[0],"9999","10",parms[0]];	if length(parms)=2 then parms:=[parms[0],parms[1],"10",parms[0]];	if length(parms)=3 then addArraySlot(parms,parms[0]);      	if strEqual(parms[0],"") then parms[0]:="0";	if strEqual(parms[1],"") then parms[1]:="9999";	if strEqual(parms[2],"") then parms[2]:="10";	if strEqual(parms[2],"") then parms[3]:="10";  for i:=0 to 3 do begin		parms[i]:=floor(stringToNumber(parms[i])); 		if classof(parms[i])<>'int then return		end;	:addLines(["From" && parms[0] && "TO" && parms[1] && "BY" && parms[2]    			&& "BASE" && parms[3] & CR]);	refreshviews();	parms[2]:=max(parms[2],1);   	// create the workfile   if worksoup1:=:getNonUnionSoup(kSoupName1) then worksoup1:removeFromStore();   workSoup1:=defStore:createSoupXmit(ksoupName1,kSoupIndexes,nil);   work1:=workSoup1:query({indexpath: 'ID});		// 1. collect all the statements that will be renumbered into slist	if debug then print("RENUM Part 1");	foreach stmtNo in _header.stmtNos do		if stmtNo>=parms[0] and stmtNo<=parms[1] then begin		 			addArraySlot(slist,{oldLine: stmtNo, newLine: parms[3]});			parms[3]:=parms[3]+parms[2];			end;	if debug then print(slist);	//	check to see if any renumbered lines exist already			foreach line in sList do begin		l:=line.newLine;		if bFetch(_header.stmtNos, l, '|<|, nil) and				(l<parms[0] or l>parms[1]) then return (:error(kError8));		end;				 		// 2. fix all references to slist	if debug then print("RENUM Part 2");	foreach recNo in _header.listRecs do begin		stmtFrame:=_work:gotoKey(recNo);		if debug then print(stmtFrame);   	done:=nil;   	foreach word in kRenumWords do    		done:=done OR :doRenum2(word,slist,parms);   	if done then :saveStmt(:formatLineNo(stmtFrame.stmtNo), stmtFrame.text); 		   			end;  //...foreach		// 3. put line numbers which change into an ENTER file	if debug then print("RENUM Part 3");	foreach line in slist do begin		s:={sub: _sub,			  ID: line.newline, 				text: line.newLine && _work:gotokey(					_header.listRecs[bFind(_header.stmtNos, line.oldLine, '|<|, nil)]).text};		if debug then print(s);		workSoup1:addXmit(s,nil);		:saveStmt(line.oldLine & "", ""); // remove old statement		end; //foreach				_RF:exEnter(kSoupName1);	worksoup1:removeFromStore();	_work:=_workSoup:query({indexpath: 'ID});		 end
       ,
     coWidgetDef:
       func() begin	text:=stmtFrame.internal;	if text=nil or strEqual(text,"") then return (:error(kError2));	if beginsWith(text, "WIDGETDEF ") then text:=substr(text,10,nil);	p:=strPos(text,"=",0);	if p and p>0 and text[p-1]<>":"		then text:="_RF." & substr(text,0,p-1) & ":=deepclone(" & substr(text, p+1, nil) & ")";	stmtFrame.compiled:=:co(text);	end
     ,
     coData:
       func() begin	stmtFrame.data:=[];	foreach arg in :getargs(stmtFrame.internal) do     		if stmtFrame.err=nil then addArraySlot(stmtFrame.data,:coDataParse(arg));	stmtFrame.compiled:=:co("NIL;");	end
     ,
     coHide:
       func() begin	local code:=":exHide([ ";	foreach arg in :getArgs(stmtFrame.internal) do begin		trimstring(arg);		// if it's a widget reference - trim it down		if endsWith(arg, "/**/)") then arg:=substr(arg,0,strPos(arg,"(",0)-1);					code:=code & arg & ",";		end;	code:=substr(code,0,strLen(code)-1) & "])";	stmtFrame.compiled:=:co(code);	end
       ,
     doCls:
       func() begin	// this needs to be done outside :addlines so it can be done from serial	local oldignoreChanges:=editor.ignoreChanges;	editor.ignoreChanges:=TRUE;	editor.textLines:=[];	setValue(editor,'text,"");	editor.endText:=0;	refreshViews();	editor.ignoreChanges:=oldignoreChanges;	end
       ,
     saveData:
       func(action, arg) begin	if kChunkTrace then print("saveDataStmt:" & action && arg);	local header:=_header;	local work:=_work;		if action='add then begin		// in this case, arg is lineNo;		local dataRec:=_workSoup:addXmit({sub: _sub, stmtNo: arg, type: 'data,			args: stmtFrame.data,			ID: :getID()},nil);		// insert into dataRecs: count number of data statements up to lineNo to find position		local dataCount:=0;		local lineCount:=0;		foreach codeID in header.codeRecs do			forEach keyword in work:gotoKey(codeID).keywords do begin				if keyword=kData then dataCount:=dataCount+1;				if lineCount=arg then break;				lineCount:=lineCount+1;				end;		arrayInsert(header.dataRecs,dataRec.ID,dataCount-1);		if kChunkTrace then print(dataRec.ID);		if kChunkTrace then print(header.dataRecs);							return dataRec.ID;		end else			if action='del then begin		// in this case, arg is listRec;		if not hasSlot(arg, 'dataID) then return arg;		entryRemoveFromSoup(work:gotoKey(arg.dataID));		setRemove(header.dataRecs, arg.dataID);		removeSlot(arg, 'dataID);		return arg;		end			end
       ,
     doEdit:
       func() begin	local stmtNo, lineNo;	local header:=_header;	local work:=_work;	if NOT strLen(newStmt) 		then stmtNo:=_RF:getStmtNo(_RF._codePos)		else stmtNo:=newStmt;	if stmtNo=NIL then return;	lineNo:=:labelResolve(newStmt, true);	if NOT lineNo then return;	stmtFrame:=work:gotokey(header.listRecs[lineNo]);	if NOT stmtFrame then return (:error(kError13));	if stmtFrame.ID<>header.listRecs[lineNo] then return (:error(kError13));	:doAda(func() editor:openStmtEditor(:formatLineNo(stmtFrame.stmtNo) && stmtFrame.text), '[], 13);	end
     ,
     scanQuick: nil,
     coDoExp:
       func() begin	if debug then print("coDoExp:" & stmtFrame.internal);	local rhs:="NIL";	if NOT stmtFrame.internal then return "TRUE";		local stmt:=trimstring(stmtFrame.internal);	if beginsWith(stmt,"WHILE") or beginsWith(stmt,"UNTIL") then begin		if beginsWith(stmt,"WHILE") then rhs:="TRUE";		if strLen(stmt)<7 then return (:error(kerror2));		exp:="(" & substr(stmt,6,nil) & ")=" & rhs;		end;				else return (:error(kerror2));end
     ,
     coGosub:
       func() begin	local target:=clone(stmtFrame.internal);	if isReal(stringToNumber(target))		then stmtFrame.display:="GOSUB" && :formatLineNo1(target);		stmtFrame.compiled:=:co(":exGosub(:labelFind('" & :labelMake(target) & "))");	end
     ,
     deleteStmt:
       func(lineNo) begin	if debug then print("deleting lineNo:" & lineNo);	if NOT lineNo then return (:error(kError13));	local header:=_header;	local work:=_work;	local lines:=header.cumLines;		if lineNo>=length(header.listRecs) then begin :addLines(kError5) ; return; end;	local listRec:=work:gotoKey(header.listRecs[lineNo]);	_RF:chGetXLine(lineNo);	local codePos:=_RF._codePos;	              	// codeRec	arrayRemoveCount(_RF._ch.keywords,codePos,1);	arrayRemoveCount(_RF._ch.code,codePos,1);	entryFlushXmit(_RF._ch,nil);	:labelDelete(header.Labels, lineNo);	:saveSub(NIL, lineNo, 'delete);	:labelDelete(header.dataLabels, listRec.dataID);	:updateLineNo(lineNo, -1);	_RF._ch.codeLen:=length(_RF._ch.code)-1;	entryFlushXmit(_RF._ch,nil);	if _RF._ch.codeLen<0 and length(header.codeRecs)>1 then begin		entryRemoveFromSoup(_RF._ch); // no code left in block		arrayRemoveCount(lines,           _RF._codeRecPos,1);		arrayRemoveCount(header.codeRecs, _RF._codeRecPos,1);		_RF._ch:=work:gotoKey(header.codeRecs[_RF._codeRecPos:=0]);		if kChunkTrace then print("Chunk removed: new chunk is " & _RF._ch.ID);		end;	           	// listRec	EntryRemoveFromSoup(listRec); // remove List Form	setRemove(header.listRecs, listRec.ID);	setRemove(header.stmtNos,  listRec.stmtNo);		// dataRec	:saveData('del, listRec);	   end
       ,
     getDirList:
       func(whoFor) begin	local prog;	local files:=[];	foreach store in getStores() do begin		foreach soup in store:getSoupNames() do begin			 		if endsWith(soup, kExt) then begin				soup:=substr(soup,0,strPos(soup,kExt,0));												if whoFor='doDir then begin					soup:=soup & spaces & spaces & spaces;					if newtCard 						then soup:=substr(soup,0,24) && "NewtCard stack" & CR						else soup:=substr(soup,0,24) && "BASIC program" & CR;					end				else soup:=soup & CR;				if findStringInArray(files,soup)=nil then addArraySlot(files, soup);				end;		      if soup and whoFor='doDir and strPos(soup,".TXT",0) then begin	      	soup:=substr(soup,0,strPos(soup,".TXT",0)) & spaces & spaces & spaces;	      	soup:=substr(soup,0,24) && "TXT file" & CR;	      	if findStringInArray(files,soup)=nil then addArraySlot(files, soup);				end; // if whoFor			end;   // foreach soup		end;     // foreach store			foreach package in getPackages() do		if endsWith(package.title, ":PKG") then begin			if whoFor='doDir then begin				prog:=package.title & spaces & spaces & spaces;				prog:=substr(prog,0,24) && "PKG" & CR;				end			else prog:=prog & ":pkg";			if findStringInArray(files,prog)=nil then addArraySlot(files, prog);			end;					    		if whoFor='popup then begin		addArraySlot(files, " Pick program to runÉ");		addArraySlot(files, " ZZ")		end; 	if whoFor='popupStack then begin		addArraySlot(files, " Pick stack to openÉ");		addArraySlot(files, " ZZ")		end;    		sort(files,'|str<|,nil);	if whoFor='popup or whoFor='popupStack then files[1]:='pickSeparator;	return filesend
       ,
     getID:
       func() begin // return next ID and update main.header	local header:=_header;	local work:=_work;	if header.sub='main		then return (header.lastID:=header.lastID+1);			local mainHeader:=work:gotoKey(kMainSub);	mainHeader.lastID:=mainHeader.lastID+1;	entryChangeXmit(mainHeader, nil);		mainHeader.lastID	end
       ,
     coPrint:
       func() begin	stmtFrame.compiled.args:=[];	if stmtFrame.internal=NIL 		then stmtFrame.internal:=quote & quote;		else if strEqual(stmtFrame.internal," ") then stmtFrame.internal:=quote & quote; 	local code:=":exPrint({values:[";  		foreach arg in :getargs(stmtFrame.internal) do begin		if strLen(arg)=0 then arg:=quote & quote;		code:=code & "(" & arg & "),"		end;			code:=substr(code,0,strLen(code)-1) & "],delim:" & quote & executor._delimiters & quote & "})";	stmtFrame.compiled:=:co(code);	end
     ,
     coIf:
       func() begin	local tempFrame,LHS,RHS,op,p,p1;	local stmt:=stmtFrame.internal;  	local thenp:=strPos(stmt," THEN ",0);	if thenp=nil then return (:error(kError2));	local elsep:=strPos(stmt," ELSE ",0);	if elsep=nil		then thenp1:=nil		else thenp1:=elsep-(thenp+6);		 	// First, do the condition 	local condition:=trimString(subStr(stmt,0,thenp)); 	p:=1000; 	if strPos(condition,"=",0) then p:=strPos(condition,"=",0); 	if strPos(condition,"<",0) then p:=min(p,strPos(condition,"<",0)); 	if strPos(condition,">",0) then p:=min(p,strPos(condition,">",0)); 	if p=1000 then begin // if no comparison, then compare to NIL 		p:=strLen(condition); 		condition:=condition & "<>NIL"; 		end; 	LHS:=subStr(condition,0,p); 	if strPos("=<>",subStr(condition,p+1,1),0) then p1:=2 else p1:=1; 	if strLen(condition)<=p+p1 then return (:error(kError2)); 	op:=subStr(condition,p,p1); 	RHS:=subStr(condition,p+p1,nil); 	if debug then print(condition && LHS && op && RHS);   local ifCode:=   	"(if classOf(" & LHS & ")='string and classOf(" & RHS & ")='string   			  then strCompare(" & LHS & "," & RHS & ")" & op & "0    			  else " & condition & ")";	// Block IF <cond> THEN <statements> ELSE <statements> ENDIF	if thenp+6>=strlen(stmt) then begin // block if then		stmtFrame.keyword:=kIFblock;		stmtFrame.compiled:=:co(":exIFblock(" & ifCode & ")");		if debug then print(stmtFrame);		return NIL		end;		// THEN (and ELSE) part of one statement	// now do the THEN clause: it's a whole new statement	tempFrame:=clone(stmtFrame);	stmtFrame:={display: trimString(subStr(stmt,thenp+6,thenp1)),    			   err: nil, internal: nil, lineNo: tempFrame.LineNo};	:interpret();	if stmtFrame.err then return;	local thenCode:=intcode;	stmtFrame:=clone(tempFrame);  	// now do the ELSE clause: it's another whole new statement	if elsep then begin		tempFrame:=clone(stmtFrame);   	stmtFrame:={display: trimString(subStr(stmt,elsep+6,nil)),    			   err: nil, internal: nil, lineNo: tempFrame.LineNo};   	:interpret();   	if stmtFrame.err then return;   	local elseCode:=intcode;   	stmtFrame:=clone(tempFrame);   	end;  	local code:="IF" && ifcode && "THEN" && thencode; 	if elsep then code:=code && "ELSE" && elsecode;	stmtFrame.compiled:=:co(code);     if debug then begin      print("Results of coIf:");      print(stmtFrame);   end;      	end
       ,
     scanner:
       func() begin // 2. add a quote sign at the end if needed // 3. put LET in front of statement that doesn't start with a keyword // 4. change ; to PRINT in front of statement // 5. eliminate multiple blanks // 6. expand ² and ³ to <= and => // 7. eliminate Â characters (line continuation) // 8. change refs to local functions to :func( // 9. substitute values for constants //10. change STR$ to STR_ //11. ignore " THE "  //12. change "x OF y" to "y.x"	local newStmt,atom,c,keyword,comment,stmt;	local p, startp, endp, clim, startarg;	if debug then print ("SCANNER");	stmt:=stmtFrame.display & " ";	stmt:=:scanner_THE(stmt);		//Part 1: Do label, if it exists	p:=:scanLabel(stmt);	if p>0 then begin		stmtFrame.label:=intern(substr(stmt,0,p));		p:=p+2;		if p=strLen(stmt) then stmt:=stmt & "REM " // make it a REM if by itself		end;   	if stmt[p]=$; then // expand ";" to PRINT		if stmtFrame.Label 			then stmt:=substr(stmt,0,p) & "PRINT" && substr(stmt,p+1,nil)			else stmt:="PRINT" && substr(stmt,p+1,nil);							    	//Part 2: figure out what the keyword is	startArg:=strPos(substr(stmt,p,nil)," ",0)+1+p;	keyword:=LSearch(kStatements,subStr(stmt,p,startArg-p-1),0,'|str=|,nil);	if keyword=nil then begin            // it doesn't start with a keyword.		if strPos(stmt,"=",0) then begin // if there's an equal sign, it's a LET			keyword:=LSearch(kStatements,"LET",0,'|str=|,nil);			stmt:=substr(stmt,0,p) & "LET" && substr(stmt,p,nil);			startArg:=p+4;			end		else if charPos(subStr(stmt,p,startArg-p-1),$(,0) then begin 			// a function - treat as a LET			keyword:=LSearch(kStatements,"LET",0,'|str=|,nil);			startArg:=p;			end;		else begin // otherwise, treat as a Call			keyword:=LSearch(kStatements,"CALL",0,'|str=|,nil);			startArg:=p;			end;		end;			stmtFrame.keyword:=kStatementCodes[keyword];	if beginsWith(stmt,"REM ") then return NIL;		if scanQuick then begin // if no need to scan the rest		if debug then print("QuickScan");		stmtFrame.display := trimstring(stmt);		stmtFrame.internal:= stmt; 		scanQuick:=nil;		//return;		end;			//Part 3: do the rest of the statement	stmtFrame.display:=clone(trimString(stmt));	while (p:=charPos(stmt,$Â,0)) do stmt:=substr(stmt,0,p) & substr(stmt,p+1,nil);	stmt:=:scanner_fixWidgetRefs(stmt);	stmt:=:scanner_OF(stmt) & " ";	newStmt:="";   	cLim:=strLen(stmt)-1;	comment:="";	if (p:=strPos(stmt,"//",0)) then cLim:=p-1;	for i:=startArg to cLim do begin		while strEqual(subStr(stmt,i,2),"  ") do i:=i+1; // trim multi blanks		c:=subStr(stmt,i,1);		if strExactCompare(c,quote)=0 then begin   // just pass thru quoted strings         			if (endp:=charPos(stmt,$",i+1)) then // handle \" type strings				while stmt[endp-1]=$\\ do begin					endp:=charPos(stmt,$",endp+1);					if NOT endp then break					end;			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end quote - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$";				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & quote;				i:=strLen(stmt)				end      end // if strExactCompare(c,quote)      			else if strExactCompare(c,"|")=0 then begin   // just pass thru strings in bars			endp:=charPos(stmt,$|,i+1);			if endp then begin				newStmt:=newStmt & subStr(stmt,i,endp-i+1);				i:=endp				end			else begin // no end | - add one!				newStmt:=newStmt & subStr(stmt,i,nil);				newStmt[strLen(newStmt)-1]:=$|;				stmtFrame.display:=subStr(Stmt,0,strLen(Stmt)-1) & "|";				i:=strLen(stmt)				end      end // strExactCompare(c,"|")          		else if charPos(kAlpha,stmt[i],0)=nil or			// floating point constants are of the form 9E...			(beginsWith(c,"E") and 			strPos(kNumeric,subStr(" " & newStmt,strLen(" " & newStmt)-1,nil),0))				then newStmt:=newStmt & c  // not an alpha? just pass it thru				else begin                 // start a possible variable					startp:=i;					chars:=0;					repeat chars:=chars+1 until charPos(kAlphaNumeric,stmt[i+chars],0)=nil						and not strEqual(substr(stmt, i+chars-1,2),".(");					atom:=subStr(stmt,startp,chars);					if (stmt[i+chars]=$( and endsWith(atom,".")=nil) or    // is it a function?						findStringInArray(kKeyword,upcase(clone(atom))) or   // is it a keyword?						(stmt[i+chars]=$: and stmt[i+chars+1]<>$=) or  // is it a frame ref?						beginsWith(atom,"'")  or			     // is it a 'symbol						beginsWith(atom,".")  			       // is it a .framepathname   						then begin // anything but a variable							if stmt[i+chars]=$( and NOT hasSlot(getGlobals().functions, intern(atom))								then begin									if not endsWith(newStmt,":") and stmt[i+chars+1]<>$.										then newStmt:=newStmt & ":";									newStmt:=newStmt & atom // user function									end								else newStmt:=newStmt & atom       // just pass it thru							end                    						else begin												// it's a variable							//if strEqual(atom, "THE") then nil // THE gets stripped							//else begin								if endsWith(atom,"$") then atom[strLen(atom)-1]:=$_;	            	p:=findStringInArray(kConstants.name,upcase(clone(atom)));								if p	// substitute constant value									then newStmt:=newStmt & numberStr(kConstants.value[p])									else newStmt:=newStmt & atom								end;							//end; // if not THE or OF							i:=i+chars-1;         		end;     end; // next i	// return frame	if strEqual(newstmt,"") then newstmt:=NIL;	if newStmt then begin		strReplace(newStmt, "²", "<=",nil);		strReplace(newStmt, "³", ">=",nil);		end;	stmtFrame.internal:= newStmt; 	end
       ,
     getPathExpr:
       func(s) begin	if debug then print ("getPathExpr:" & s);	local symbols:=[];	local level:=0;	local quotes:=NIL;	local p:=0;	for i:=0 to strLen(s)-1 do begin		if (s[i]=$. or s[i]=$[) and quotes=NIL and level=0 then begin			addArraySlot(symbols, substr(s,p,I-p));			p:=i+1			end;		if s[i]=$( then level:=level+1;		if s[i]=$[ then level:=level+1;		if s[i]=$] then level:=level-1;		if s[i]=$) then level:=level-1;		if s[i]=$" then if quotes=TRUE then quotes:=NIL else quotes:=TRUE;		end;	addArraySlot(symbols,substr(s,p,NIL));	if debug then print(symbols);	local path:="[pathExpr:";	for I:=0 to length(symbols)-1 do begin		trimstring(symbols[i]);		if endsWith(symbols[i], "]")			then path:=path & substr(symbols[i],0,strLen(symbols[i])-1) & ","			//else path:=path & "intern(" & $" & symbols[i] & $" & ")" & ","			else path:=path & "'" & symbols[i] & ","		end;	path:=substr(path,0,strlen(path)-1) & "]";	if debug then print(path);	return path;end;
       ,
     coShow:
       func() begin	local code:=":exShow([";	foreach arg in :getArgs(stmtFrame.internal) do begin		trimstring(arg);		// if it's a widget reference - trim it down		if endsWith(arg, "/**/)") then arg:=substr(arg,0,strPos(arg,"(",0)-1);					code:=code & arg & ",";		end;	code:=substr(code,0,strLen(code)-1) & "])";	stmtFrame.compiled:=:co(code);	end
       ,
     doRunInit:
       func() begin	if executor.basicAlphaInUse and visible(editor.basicAlpha) then begin		if debug then print("Hiding Keyboard");		editor.basicAlpha:hide();	end; :doAda(func() :doRun(), '[], 0);	end
     ,
     notRunTime: "interpreter",
     scanLabel:
       func(stmt) begin	if NOT strPos(kAlpha, substr(stmt,0,1), 0) then return 0;	if NOT charPos(stmt,$:,0) then return 0;	local int p:=0;		repeat p:=p+1 until charPos(kAlphanumeric,stmt[p],0)=NIL;		if stmt[p]<>$: then return 0;	if stmt[p+1]<>$  then return 0;	return p	end
     ,
     coChain:
       func() begin	local x:=:getArgs(stmtFrame.internal);	if length(x)=0 or length(x)>2 then return (:error(kError2));	if length(x)=1 then addArraySlot(x,"NIL");	stmtFrame.compiled:=:co(":exChain([" & x[0] & "," & quote & x[1] & quote & "]);");	end
     ,
     coSetIcon:
       func() begin	local arg:=:getargs(stmtFrame.internal);	if length(arg)<>2 then return (:error(kError63));	stmtFrame.compiled:=:co(":exSetIcon(" & arg[0] & "," & arg[1] & ")");end
     ,
     coWDRAW:
       func() begin	local arg:=:getargs(stmtFrame.internal);	if length(arg)=2 then addArraySlot(arg,"{}");	if length(arg)<>3 then return (:error(kError63));	trimstring(arg[0]);	// if it's a widget reference - trim it down	if endsWith(arg[0], "/**/)") then arg[0]:=substr(arg[0],0,strPos(arg[0],"(",0)-1);	stmtFrame.compiled:=:co(":exWdraw([" & arg[0] & "," & arg[1] & "," & arg[2] & "])");	end
       ,
     coErase:
       func() begin	local x:=:getArgs(stmtFrame.internal);	if length(x)=0 or length(x)>2 then return (:error(kError2));		if length(x)=1 then addArraySlot(x,x[0]);	stmtFrame.compiled:=:co(":exErase(['" & :labelMake(x[0]) & ",'" & :labelMake(x[1]) & "])");	end
     ,
     handleInputLine: func(text) editor:handleInputLine(text);,
     coBye:
       func() begin 	if NOT stmtFrame.internal then stmtFrame.internal:="NIL";       stmtFrame.compiled:=:co(":exBye(" & stmtframe.internal & ")");	end
     ,
     coGet:
       func() begin	local args:=:getargs(stmtFrame.internal);	if length(args)<>2 and length(args)<>3 then return (:error(kError63));	if NOT :isaVariable(args[0],true) or NOT :isaVariable(args[1],true) then return;	   	local key:="NIL";	if length(args)=3 then key:=args[2];	stmtFrame.compiled:=:co(":exGet({										chan: " 		& :getPathExpr(args[0]) & ",										frame: "	& quote & args[1] & quote & ",										key: " & key & "})");	end
     ,
     doDir: func() :addlines(:getDirList('doDir)),
     coGoto:
       func() begin	local target:=clone(stmtFrame.internal);	if isReal(stringToNumber(target))		then stmtFrame.display:="GOTO" && :formatLineNo1(target);		stmtFrame.compiled:=:co("_runFlag:=:labelFind('" & :labelMake(target) & ")" );	end
     ,
     isaStringVar:
       func(s) begin	if debug then print("is a strvar" && s);	if endsWith(s,"_:=") then return TRUE;	if endsWith(s,"_") then return TRUE;	if strPos(s,"_[",0) then return TRUE;	return nil	end
     ,
     doTools:
       func() begin	local tools:=getroot().(kToolsSymbol);	local line, toolName;	if tools=NIL then return;	local text:=["The following tools are installed:" & CR, CR];	foreach tool in tools do begin		toolName:=sprintobject(tool);		toolName:=substr(toolName, 0, charPos(toolName, $: , 0)) & spaces & spaces & spaces;		addArraySlot(text, substr(toolName, 0, 20) & getroot().(tool):rev() & CR);		end;			:addLines(text);               end
     ,
     FormatLineNo1: func(stmtNo) executor:formatLineNo1(stmtNo),
     getNewCodeRec:
       func(codeRecPos) begin // create a new Code record, return its ID, set CodeRecPos to new rec	if kChunkTrace then print("getNewCodeRec:" && codeRecPos);	local header:=_header;	_RF._ch:=deepclone(kEmptyCodeRec);	_RF._ch.sub:=_sub;	local ID:=_RF._ch.ID:=:getID();	_RF._codeRecPos:=codeRecPos:=codeRecPos:=min(length(header.codeRecs), codeRecPos+1);	_workSoup:addXmit(_RF._ch,nil);	arrayInsert(header.codeRecs,ID,codeRecPos);		if length(header.cumLines)>0		then arrayInsert(header.cumLines,header.cumlines[codeRecPos-1],codeRecPos);	return ID;	end
       ,
     coCreate:
       func() begin	local args:=:getargs(stmtFrame.internal);	if length(args)<>3 then return (:error(kError63));			if NOT :isaVariable(args[0],true) or   // first arg must be a variable	   (beginsWith(args[1],quote) or :isaVariable(args[1],true))=nil	// 2nd is " " or variable	   or NOT :isaVariable(args[2],true)	   then return;	stmtFrame.compiled:=:co(":exCreate({										chan: " 		& :getPathExpr(args[0]) & ",										filename: " & args[1] & ",										keyName: "	& quote & args[2] & quote & "})");end
       ,
     updateLineNo:
       func(fromLineNo, inc) begin	if kChunkTrace then print("C: updateLineNo:" && fromLineNo && inc);	// When a line is added or deleted, pointers after it need to be updated	local header:=_header;	foreach label, lineNo in header.labels do		if lineNo>=fromLineNo then header.labels.(label):=lineNo+inc;	foreach label, lineNo in header.subs do		if label<>'main and lineNo and abs(lineNo)>=fromLineNo then begin			if lineNo>0 then header.subs.(label):=lineNo+inc			            else header.subs.(label):=lineNo-inc			end;	// fix up the cumlines array	if length(header.cumLines)>0 then begin		fromCodeRecPos:=_RF:findLineNo(fromLineNo);		if fromCodeRecPos=length(header.cumLines) then fromCodeRecPos:=fromCodeRecPos-1;		for i:=fromCodeRecPos to length(header.cumLines)-1			do header.cumLines[i]:=header.cumLines[i]+inc;		end	else header.cumLines:=[0];				if kChunkTrace then print(header.cumLines);	if kChunkTrace then print(header.labels);	end
       ,
     coFunction:
       func() begin	if debug then print("coFunction");	local p,p0,p1,stmt;	stmt:=stmtFrame.display;	p0:=strPos(stmt,"(",0);	p1:=strPos(stmtFrame.internal,"(",0);	if p0=nil then return (:error(kerror2));		while (p:=strPos(stmt,"Â",0)) do stmt:=substr(stmt,0,p) & substr(stmt,p+1,nil);	stmtFrame.compiled:=:co("_RF." & substr(stmtFrame.internal,1,p1-1) & ":=" &									"func" & subStr(stmt,p0,nil))	end
     ,
     coStop: func() stmtFrame.compiled:=:co(":exStop()");,
     coHWInput:
       func() begin	stmtFrame.keyword:=kHWINPUT;		local arg:=:getargs(stmtFrame.internal);	local varType:="NIL";	if length(arg)=0 then return (:error(kError63));	if length(arg)=1 then addArraySlot(arg, quote & quote);	if length(arg)=2 then addArraySlot(arg,"NIL");		// arg[0] is variable name to input to		if :isaStringVar(arg[0]) then varType:="'string";	stmtFrame.compiled:=:co(":exHWInput({										var: " 		 & :getPathExpr(arg[0]) & ",										varType: "   & varType & ",										prompt: "    & arg[1] & ",										popUpList: " & arg[2] & "})"); 	end
       ,
     stripQuotes:
       func(x) begin	if NOT x then return x;	x:=trimstring(x);	if not beginsWith(x,quote) then return x;	x:=subStr(x,1,nil);	if endsWith(x,quote) then x:=substr(x,0,strLen(x)-1);	:stripQuotes(x)	end
     ,
     cotable: nil,
     coEndSub:
       func() begin	stmtFrame.keyword:=kEndSub;	stmtFrame.compiled:=:co(":exEndSub()");	end;
     ,
     doNewProgram:
       func() begin	if newtcard then return :error(kError2);	if not modalConfirm("Warning! NEWPROGRAM wipes out your current program.", 'okCancel) then return;	if debug then print("doNewProgram");	:doNew();	foreach line in kProgramTemplate do :handleInputLine(line);	newStmt:="0050";			//:doAda(func() :doEdit(), '[], 0)	end
       ,
     coDataParse:
       func(arg) begin// if arg starts with a quote, it's a literal,// otherwise try to treat it as a number.   if beginsWith(arg,quote)      then if endsWith(arg,quote)               then return substr(arg,1,strLen(arg)-2);              else :error(kError3);                      a:=StringToNumber(arg);   if a then begin   				if charPos(arg,$. ,0)=nil then a:=floor(a);             end        else :error(kError3);   a	end
       ,
     coBeep:
       func() begin 	if NOT stmtFrame.internal then stmtFrame.internal:="0";    	stmtFrame.compiled:=:co("playSoundIrregardless(gBeeps[" & stmtframe.internal & "]);");	end
     ,
     coCall:
       func() begin	local s:=stmtFrame.internal;	local p:=strPos(s," ",0);	local p1:=strPos(s,"(",0);	if p1 and p1<p then p:=p1;		local funcName:=trimString(substr(s,0,p));	local args:=trimString(substr(s,p,nil));	local argCode:="";	if beginsWith(stmtFrame.display,"CALL")		then if beginsWith(args,"(") 			then args:=substr(args,1,strLen(args)-2)			else :error(kError02);  // CALL form must have parens around arglist			if debug then print("coCall" & ":" & funcname & "," & args);		foreach arg in :getArgs(args) do		if :isaVariable(arg,nil)			then argCode:=argCode & "," & :getPathExpr(arg)			else argCode:=argCode & "," & arg;	if beginsWith(argCode,",") then argCode:=substr(argCode,1,nil);		if not beginsWith(stmtFrame.display,"CALL") and length(:getArgs(args))=0		then // possible simple variable, not a function call!			stmtFrame.compiled:=:co("if classOf(" & funcName & ")='_function				then :" & funcName & "(" & argCode & ")				else " & funcName)		else stmtFrame.compiled:=:co(":" & funcName & "(" & argCode & ")");	end
       ,
     coRead:
       func() begin	local vars:="";	local varTypes:="";	foreach arg in :getargs(stmtFrame.internal) do begin		if NOT :isaVariable(arg, true) then return;		vars:=vars & :getPathExpr(arg) & ",";		if :isaStringVar(arg)			then varTypes:=varTypes & "'string,"			else varTypes:=varTypes & "NIL" & ","         end; 	stmtFrame.compiled:=:co(":exRead({									vars: [" & substr(vars,0, strLen(vars)-1) & "],									varTypes: [" & substr(varTypes,0, strLen(varTypes)-1) & "]})")end
     ,
     labelResolve:
       func(label, showError) begin	// can be called with symbol, string stmtNo, int statNo or label	// returns lineNo	if debug then print("labelResolve:" && label);	local lineNo:=nil;	local header:=_header;		if isInteger(label) then label:="L" & label;	if isString(label) and isReal(stringToNumber(label)) 		then label:="L" & floor(stringToNumber(label));	if isString(label) then label:=intern(label);	if isSymbol(label) then lineNo:=header.labels.(label);		if lineNo=nil then begin		if label='L0 then lineNo:=0;		if label='L9999 and length(header.cumlines)>0 			then lineNo:=header.cumlines[length(header.cumlines)-1];		end;		if lineNo=NIL and showError then return (:error(kError12));	if debug then print("  resolved:" && lineNo);	return lineNo;	end
       ,
     coLet:
       func() begin	if :coLet_widgetRef() then return;		local ops, p, pc;	local pointer:=nil;		if strPos(stmtFrame.internal,":=",1) 		then pointer:=TRUE		else strReplace(stmtFrame.internal,"=",":=",1);			p:=strPos(stmtFrame.internal,":=",0);	if p=NIL then begin // null assign statement		p:=-2;		pointer:=TRUE;		end	else if not :isSpecialVariable(stmtFrame.internal) then begin			// regular assign. Force it into the RunFrame.			stmtFrame.internal:="_RF." & stmtFrame.internal;			p:=p+4			end;   	if not pointer then begin // if it isn't a pointer, than is it an expression?   	ops:="-+/*&" & quote;   	for i:=0 to strLen(ops)-1 do   	  if strPos(subStr(stmtFrame.internal,p+2,nil),substr(ops,i,1),0) then begin   	  	  pointer:=TRUE;   	  	  break;   	  	  end;   	end;  // if a frame or array, always clone it!	if strPos(substr(stmtFrame.internal,p+2,nil),"{",0) or	   strPos(substr(stmtFrame.internal,p+2,nil),"[",0) then pointer:=NIL;	// is target a string?	if :isaStringVar(substr(stmtFrame.internal,0,p+2))		then stmtFrame.compiled:=:co(substr(stmtFrame.internal,0,p+2) &			"(if classof(" & subStr(stmtFrame.internal,p+2,nil) & ")='string		then " & subStr(stmtFrame.internal,p+2,nil) & "		else sPrintObject(" & subStr(stmtFrame.internal,p+2,nil) & "))"																			)   	else if pointer=NIL						then stmtFrame.compiled:=:co(substr(stmtFrame.internal,0,p+2) &       							 "deepClone(" & subStr(stmtFrame.internal,p+2,nil) & ")" )      		  else stmtFrame.compiled:=:co(stmtFrame.internal);end
       ,
     doListGOTOComment:
       func(listParms, line) begin	local temp, stmt, p, lineNo, stmtNo;	local header:=_header;	local work:=_work;	stmt:=stmtFrame.text;	if listParms[2] then return line;	if strPos(stmt,"//",0) then return line;	p:=:scanLabel(stmt);	if p>0 then p:=p+1;	stmt:=trimString(substr(stmt,p,nil));	if NOT beginsWith(stmt, "GOTO") and NOT beginsWith(stmt, "GOSUB") then return line;	if debug then print("Looking for comment:" & line);		lineNo:=header.labels.(:labelMake(substr(stmt,strPos(stmt," ",0)+1,nil)));	if not lineNo then return line;	temp:=work:gotoKey(header.listRecs[lineNo]);	if temp and temp.ID=header.listRecs[lineNo] then begin		if beginsWith(temp.text,"REM") then line:=line && "//" & subStr(temp.text,4,nil);		if (p:=strPos(temp.text,": REM",0)) then line:=line && "//" & substr(temp.text, p+6, nil);		end;	return line;	end
       ,
     labelAdd:
       func(labelFrame, lineNo, label) begin	if kChunkTrace then print("labelAdd:" & sprintObject(labelFrame) & lineNo && sprintobject(label));	if NOT label then return;	if labelFrame.(label) then return (:error(kError7));	labelFrame.(label):=lineNo;	if kChunkTrace then print(labelFrame);	end
     ,
     coELSE:
       func() begin	if stmtFrame.internal<>NIL then return (:error(kError2));	stmtFrame.compiled:=:co(":exElse()");	end
     ,
     viewClass: 74 /* clView */,
     coFind:
       func() begin	if debug then print("CoFind");	local arg:=:getargs(stmtFrame.internal);		if length(arg)=0 then return (:error(kError63));	if length(arg)=1 then addArraySlot(arg,"NIL");	if length(arg)=2 then addArraySlot(arg,"NIL");		// arg[1] is variable name to return entry to	if not strEqual(arg[1], "NIL") then begin		arg[1]:=:getPathExpr(arg[1])		end;	stmtFrame.compiled:=:co(":exFind({										findStr: "   & arg[0] & ",										var: " 		   & arg[1] & ",										fileName: "  & arg[2] & "})");	end
       ,
     doLoad:
       func() begin	local x:=trimString(newStmt);	if strLen(x)=0 then x:=systemEntry.ProgramName;	if debug then print(x);	if strEqual(x,"SCRATCH") then return;	:init_RF();	:doLoadx(x);	end
     ,
     coSub:
       func() begin	if debug then print("coSub");	local p,funcName,code,s,code1;	s:=trimString(stmtFrame.internal);	p:=strPos(s,"(",0);	if NOT p or p<1 or NOT endsWith(s,")") then return :error(kError11);	funcName:=trimString(substr(s,0,p));	if beginsWith(funcName, ":") then funcName:=substr(funcName,1,nil);	if NOT :isaVariable(funcName,true) then return :error(kError9);	stmtFrame.funcNameSym:=intern(funcName);			code:="";	code1:="_context:'" & funcName & ",";	foreach arg in :getArgs(substr(s,p+1,strLen(s)-p-2)) do begin		code:=code & trimString(arg) & ",";		code1:=code1 & trimString(arg) & ":" & trimString(arg) & ",";		end;	if endsWith(code, ",") then code:=substr(code,0,strLen(code)-1);	if endsWith(code1, ",") then code1:=substr(code1,0,strLen(code1)-1);		code:="if _loading then _RF." & funcName & ":=func(" & code & ") ";	code:=code & ":exSub({" & code1 & "}) 		else if not newtCard then :chGetStatement([" & kEndSub & "])";	stmtFrame.compiled:=:co(code);	end
     ,
     coDel:
       func() begin	local args:=:getargs(stmtFrame.internal);	if length(args)<>2 then return (:error(kError63));	if NOT :isaVariable(args[0],true) or NOT :isaVariable(args[1],true) then return;	stmtFrame.compiled:=:co(":exDel({			chan: " 	& quote & args[0] & quote & ",			frame: "	& args[1] & "})");	end
     ,
     saveSub:
       func(subName,lineNo,op) begin	if debug then print("saveSub:" && subName && lineNo && op);	// add, replace or delete slot in subs table in main header	if lineNo=0 and newtcard then return; // already done by Module mechanism	local header:=_work:gotokey(kMainSub);	if op<>'delete and isInteger(header.subs.(subName)) and header.subs.(subName)>0		then return (:error(kError27));	if _sub<>'main and lineNo<>0 and op<>'delete then return (:error(kError26));		lineNo:=-1*lineNo;			if (op='delete or op='replace) then :labelDelete(header.subs, lineNo);		if (op='add    or op='replace) then :labelAdd(header.subs, lineNo, stmtFrame.funcNameSym);	entryFlushXmit(header, nil);	end
       ,
     coReturn: func() stmtFrame.compiled:=:co(":exReturn()");,
     coCls: func()	stmtFrame.compiled:=:co("interpreter:doCls()");,
     coRestore:
       func() begin	local target:=clone(stmtFrame.internal);	if target=nil or target="" then targetl:="0";		if isReal(stringToNumber(target))		then stmtFrame.display:="RESTORE" && :formatLineNo1(target);		stmtFrame.compiled:=:co(":exRestore(:dataLabelFind('" & :labelMake(target) & "))");	end
     ,
     saveHeader:
       func() begin	if _mainRF._runState then return;	if kChunkTrace then if _RF._ch then print("C: saveHeader:" & _RF._ch.LineNo);	local header:=_header;	if _RF._ch and frameDirty(_RF._ch) and isSoupEntry(_RF._ch) then begin		if kChunkTrace then print("C:   ch flushed");		entryFlushXmit(_RF._ch,nil);		end;	if frameDirty(header) then begin		if kChunkTrace then print("C:   header flushed");		entryFlushXmit(header,nil);		end		end
     ,
     coGo:
       func() begin	if debug then print("CoGo");	strReplace(stmtFrame.internal," ",",",1);		local arg:=:getargs(stmtFrame.internal);		if length(arg)=0 then return (:error(kError63));	if length(arg)>1 and LSearch(["back","title","first","prev","next","last"],arg[0],0,'|str=|,nil)		then (:error(kError63));	if length(arg)=1 then addArraySlot(arg,"NIL");	if NOT LSearch(["back","title","first","prev","next","last","card","app","stack"],arg[0],0,'|str=|,nil)		then return (:error(kError2));	stmtFrame.compiled:=:co(":exGo({										action: '"  & arg[0] & ",										var: " 		  & arg[1] & "})");	end
     ,
     coWindow:
       func() begin	local arg:=:getargs(stmtFrame.internal);	local code:="";	if length(arg)<1 then return (:error(kError63));	if length(arg)=2 then addArraySlot(arg,quote & "pt_userView" & quote);	stmtFrame.compiled:=:co(":exWindow({		win: " 		& :getPathExpr(arg[0]) & ",		specName:"  & :getPathExpr(arg[1]) & ",		widget:"		& arg[2] & "});");end
     ,
     coDim:
       func() begin	local code:="";	foreach arg in :getargs(stmtFrame.internal) do      code:=code & :coDimParse(arg) & ";";   	stmtFrame.compiled:=:co(code);end
     ,
     saveStmt:
       func(stmtNumber,stmt) begin // save a new or existing statement	// This still assumes there will be a line number at the beginning of the statement	local lineNo, listEntry, stmtNo, stmtNoSymbol, oldLabel;	if debug then print("saveStmt:" && stmtNumber & ":" & Stmt);	local header:=_header;	local work:=_work;      	stmtNo:=floor(stringToNumber(stmtNumber));	if stmtNo=nil then return; // help - no line numbers	if stmtNo<=0  then return (:error(kError5));	_RF._lastStmtNo:=stmtNo;	stmtNoSymbol:=intern("L" & stmtNo);       	// line number entered by itself deletes a line	if strEqual(stmt,"") then return (:deleteStmt(:labelResolve(stmtNumber, true)));	// otherwise, it needs to be processed	stmtFrame:={lineNo: stmtNo, display: stmt,              internal: "",keyword: nil, compiled: {}, label: nil, err: nil};      	:interpret();	if stmtFrame.err then return nil;        	if debug then print(stmtFrame); 	codePos:=:findLabel(stmtNoSymbol); 		if NOT codePos then begin // add a new statement		if debug then print("C: Add new statement " & lineNo);		lineNo:=bInsertRight(header.stmtNos, stmtNo, '|<|, nil, true); // help		if NOT lineNo then return :error(kError6);		:saveCode(lineNo, stmtFrame.keyword, stmtFrame.compiled);		:labelAdd(header.labels, lineNo, stmtFrame.label);		:labelAdd(header.labels, lineNo, stmtNoSymbol);		listEntry:={sub: _sub, stmtNo: stmtNo, type: 'list,			text:  stmtFrame.display,			ID: :getID()};		if stmtFrame.keyword=kDATA then begin			listEntry.dataID:=:saveData('add, lineNo);			:labelAdd(header.dataLabels, listEntry.dataID, stmtFrame.label);			:labelAdd(header.dataLabels, listEntry.dataID, stmtNoSymbol);			end;		if stmtFrame.keyword=kSUB then :saveSub(stmtFrame.funcNameSym, lineNo, 'add);		_workSoup:addXmit(listEntry,nil);     				arrayInsert(header.listRecs, listEntry.ID, lineNo);		end;	else begin // replace an existing statement		lineNo:=header.labels.(stmtNoSymbol);		if debug then print("C: Replace lineNo " & lineNo);		// list format		listEntry:=work:gotokey(header.listRecs[header.labels.(stmtNoSymbol)]);		oldLabel:=:scanLabel(listEntry.text);		if oldLabel=0 			then oldLabel:=nil			else oldLabel:=intern(substr(listEntry.text, 0, oldLabel));		if oldLabel<>stmtFrame.label then begin			if oldLabel then begin				removeSlot(header.labels, oldLabel);				removeSlot(header.datalabels, oldLabel);				end;			:labelAdd(header.labels, lineNo, stmtFrame.label);			:labelAdd(header.dataLabels, listEntry.dataID, stmtFrame.label);			end;		if stmtFrame.keyword=kSUB then :saveSub(stmtFrame.funcNameSym, lineNo, 'replace);				listEntry.text:=stmtFrame.display;		if stmtFrame.keyword<>kDATA then listEntry:=:saveData('del, listEntry);		entryFlushXmit(listEntry,nil);				// code format    		_RF._ch.code[codePos]:=stmtFrame.compiled;		_RF._ch.keywords[codePos]:=stmtFrame.keyword;		entryFlushXmit(_RF._ch, nil);			       		// data format                                  		if _RF._ch.keywords[codePos]=kDATA then begin			if not hasSlot(listEntry, 'dataID) then begin 				listEntry.dataID:=:saveData('add, lineNo);				entryFlushXmit(listEntry,nil);						end;			else begin				dataEntry:=work:gotoKey(listEntry.dataID);				dataEntry.args:=stmtFrame.data;				entryFlushXmit(dataEntry,nil);				end			end // data format			 		end // replace record	end
       ,
     commsFlag: nil,
     coFor:
       func() begin	local compare, endd, incr, decr;	local stmt:=stmtFrame.internal;	local equals:=strPos(stmt,"=",0);	local tooo:=strPos(stmt," TO ",0);	if tooo=nil then return (:error(kError2));	local stepp:=strPos(stmt," STEP ",0);	local var:=trimString(subStr(stmt,0,equals));	local start:=trimString(substr(stmt,equals+1,tooo-equals)); 	if stepp then begin		endd:=trimString(substr(stmt,tooo+3,stepp-tooo-3)); //end		stepp:=trimString(substr(stmt,stepp+5,nil)); 		end	else begin   	stepp:="1";		endd:=trimString(substr(stmt,tooo+3,nil));		end;	if debug then print(var && start && endd && stepp);	stmtFrame.compiled:=:co(":exFor(			{	idxName:"    && quote & var & quote & ",				stepp:"  && stepp & ",				start:"	&& start & ",				endd:"	&& endd & ",				up:"	   && stepp & ">0,				stepOK:" && stepp & "<>0,				incrOK: (" & stepp & ">0 and " & start & "<=" & endd & ") or ("							  & stepp & "<0 and " & start & ">=" & endd & "),				init:"    && "_RF.(" & :getPathExpr(var) & "):=" & start & ",				idxPath:" && :getPathExpr(var) & "			})");				end
       
    };


constant |layout_InterpreterUnit| := interpreter;
// End of file InterpreterUnit
// Beginning of text file InterpreterUnit.f
definition := EnsureInternal(Clone(kInterpreterUnitFrame));definition.interpreterUnit := getlayout("interpreterUnit");DefineUnit(EnsureInternal('|interpreterUnit:NSB|), definition);InstallScript := func(partFrame, removeFrame) nil;RemoveScript := func(removeFrame) nil;
// End of text file InterpreterUnit.f
// Beginning of text file widgetLib
defconst('kWidgetLib, {	// this one is a special case: it puts up a simple window	pt_userView: {goto: NIL, gosub: NIL, drawing: [], type: 'ignore, visible: TRUE},	app:			{_proto: {}, type: 'ignore, expert: kExpertExpert, visible: TRUE},	azTabs:	{item: "azTabs",					_proto: protoAZtabs,					goto: nil, gosub: nil,					viewBounds: SetBounds(100, 70, 325, 88),					viewFlags: vClickable,					viewJustify: vjCenterH+vjCenterV,					visible: TRUE,					pickLetterScript: func(letter) begin						windowSp
£Gø£GÀec.text:=letter;						executor:userClickAction(NIL,self) 						end,					contents: 'text,					type: 'button, expert: kExpertExpert},	azVertTabs:		{item: "azVertTabs",						_proto: protoAZVertTabs,						goto: nil, gosub: nil,						viewBounds: SetBounds(100, 90, 125, 226),						viewFlags: vClickable,						viewJustify: vjCenterH+vjCenterV,						visible: TRUE,						pickLetterScript: func(letter) begin							windowSpec.text:=letter;							executor:userClickAction(NIL,self) 							end,					
£Gø£GÀ	contents: 'text,						type: 'button, expert: kExpertExpert},  	checkbox:	{item: "checkbox",						_proto: protoCheckBox, 						viewValue: NIL,						text: "Checkbox", 						viewBounds: {left: 100, right: 200, top:100, bottom: 120},						viewFlags: vClickable,          	viewFont: ROM_fontSystem10,          	viewFormat: nil,          	visible: TRUE,  					valueChanged: func() begin windowSpec.viewvalue:=self.viewValue end,  					contents: 'viewValue,						viewClickScript: func(unit) begin 
£Gø£GÀ							inherited:?viewClickScript(unit);    				  executor:userClickAction(unit,self)     				  end,    				type: 'button, expert: kExpertScript},	closeBox:	{item: "closeBox",						_proto: protoCloseBox,						declareSelf: 'base,						viewFlags: vClickable + vReadOnly,						visible: TRUE,						buttonClickScript: func() executor:userClickAction(NIL,self),						type: 'button, expert: kExpertExpert},	datePicker: {item: "datePicker",						_proto: protoDatePicker, 						viewBounds: {left: 1
£Gø£GÀ00, right: 220, top: 120, bottom: 200},						viewFlags: vClickable,						selectedDates: [time()],						viewFormat: nil,						viewSetupFormScript: func() selectedDates:=[time()],						visible: TRUE,						dateChanged: func(dates) begin							local context:=self._parent;							if NOT hasSlot(context, 'windowSpec) then context:=context._parent;							windowSpec.selectedDates:=context.dates;							executor:userClickAction(NIL,context) 							end,						contents: 'selectedDates,						type: 'fie
£Gø£GÀld, expert: kExpertScript},			  							digitalClock: {item: "digitalClock",						_proto: protoDigitalClock,			  						 						viewBounds: {left: 1, right: 119, top: 101, bottom: 128},						time: time(),						viewFlags: vClickable,						visible: TRUE,						timeChanged: func() begin							local context:=self._parent;							if NOT hasSlot(context, 'windowSpec) then context:=context._parent;							windowSpec.time:=context.time;							executor:userClickAction(NIL,context) end,						contents: '
£Gø£GÀtime,						type: 'field, expert: kExpertScript},   				  						 	draw:		 	{item: "draw",						drawing: nil,						drawDrawing: func() begin							if debug then print("doDrawing");							:lockScreen(TRUE);							:drawShape(drawing, styleFrame);							:lockScreen(NIL);							refreshviews();							end,						viewClass: clEditView, 						viewBounds: {Left:1, right: 100, top:1, bottom: 100},						viewDrawScript: func() if drawing and length(drawing)>0 then :drawDrawing(),						viewFlags: vCli
£Gø£GÀckable+vGesturesAllowed+vShapesAllowed,						viewFormat: vfFillWhite+vfFrameBlack+vfPen(1)+vfLinesLtGray,						viewLineSpacing: 32,						viewChildren: clone([]),						viewFont: simpleFont18,						viewAddChildScript: func(newOne) begin							if length(windowSpec.viewChildren)=0 then windowSpec.viewChildren:=[];							addArraySlot(windowSpec.viewChildren, newOne);							:doAda(func() _rf:userClickAction(NIL,self), '[], 0);							NIL end,						visible: TRUE,						contents: 'viewChildren,				
£Gø£GÀ		type: 'field, expert: kExpertScript},   				  			     	// this one doesn't work: it may be the viewChildren slot for the checkbox	floatNGo:	 {item: "floatNGo",						_proto: protofloatNGo,						viewBounds: {left: 50, right: 100, top: 6, bottom: 40},						text: "FloatNGo",						viewChildren: [{_proto: protoStaticText}],						visible: TRUE,						type: 'ignore, expert: kExpertExpert},   				  	glance:	 {item: "glance",					_proto: protoGlance,					viewBounds: {left: 100, right: 200, top: 6
£Gø£GÀ0, bottom: 75},					visible: TRUE,					text: "Glance",					type: 'ignore, expert: kExpertExpert},	gauge:   {item: "gauge",					viewClass: clGaugeView,					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);    				 executor:userClickAction(unit,self)     				 end,					viewValue:50,					viewBounds: {left: 100, right: 200, top: 90, bottom: 100},					viewFlags: vReadOnly+vClickable,					visible: TRUE,					gaugedrawlimits: TRUE,					minValue: 0,					maxValue: 100,	
£Gø£GÀ				viewSetupFormScript: func() NIL,					contents: 'viewValue,					type: 'field, expert: kExpertExpert},   				  	labelInput:	 {item: "labelInput",						_proto: protoLabelInputLine,						viewFlags: vReadOnly+vClickable,						viewBounds: {left:100, right: 240, top: 40, bottom: 60},						currLabelCommand: 0,						entryFlags: vVisible+vClickable+vGesturesAllowed+vCharsAllowed+vNumbersAllowed,						labelfont: ROM_fontSystem9Bold,						labelCommands: ["one","two"],						label: "Label",						t
£Gø£GÀext: "",						viewValue: 0,						textSetup: func() begin setup:=true; text end,						setup: NIL,						viewShowScript: func() begin setValue(entryLine, 'text, text) end,						visible: TRUE,						labelActionScript: func(x) begin windowspec.viewValue:=x;							local s:=self._parent;							NIL end,						textChanged: func() begin windowSpec.text:=self.text;							local s:=self._parent;							if setup then setup:=NIL											 else executor:userClickAction(NIL,s) 							end,						contents: '
£Gø£GÀtext,						type: 'field, expert: kExpertExpert},	labelPicker: {item: "labelPicker",						_proto: protoLabelPicker,						viewBounds: {left:100, right: 240, top: 40, bottom: 60},						checkCurrentItem: TRUE,						labelCommands: ["One","Two","Three"],						text: "labelPicker",						viewValue: 0,						visible: TRUE,						textSetup: func() begin labelCommands[viewValue] end,						labelActionScript: func(x) begin 							windowspec.viewValue:=x;							executor:userClickAction(NIL,self); 					
£Gø£GÀ		NIL end,						contents: 'viewValue,						type: 'field, expert: kExpertExpert},	LargeCloseBox: {item: "largeCloseBox",							_proto: protoLargeCloseBox,							declareSelf: 'base,							viewFlags: vClickable + vReadOnly,							visible: TRUE,							buttonClickScript: func() executor:userClickAction(NIL,self),							type: 'button, expert: kExpertExpert},				  							month:	 {item: "month",					viewClass: clMonthView,					viewBounds: {left: 100, right: 200, top: 120, bottom: 180},					vie
£Gø£GÀwFlags: vClickable,					viewFormat: 0,					visible: TRUE,					selectedDates: [time()],					labelFont: ROM_fontsystem9Bold,					dateFont: ROM_fontSystem9,					monthChangedScript: func() begin 						windowSpec.selectedDates:=self.selectedDates;						executor:userClickAction(NIL,self) 						end,					contents: 'selectedDates,					type: 'field, expert: kExpertExpert},	newSetClock: {item: "newSetClock",						_proto:  protoNewSetClock,						viewBounds: {left: 1, right: 64, top:1, bottom: 64},
£Gø£GÀ						viewFlags: vClickable,						visible: TRUE,						minutes: date(time()).minute, hours: date(time()).hour,						timeChanged: func() begin 							windowSpec.hours:=hours;							windowSpec.minutes:=minutes;							windowSpec.time:={hours: hours, minutes: minutes};							:dirty();							executor:userClickAction(NIL,self) 							end,						contents: 'time,						type: 'field, expert: kExpertScript},    				  				      	numberPicker: {item: "numberPicker",						_proto: protoNumberPicker,		
£Gø£GÀ				viewBounds: {left: 1, right: 200, top: 131, bottom: 160},						viewFlags: 0,						visible: TRUE,						minValue: 0,						maxValue: 9999999,						Value: 0,						showLeadingZeros: TRUE,						clickDone: func() begin							local context:=self._parent;							if NOT hasSlot(context, 'windowSpec) then context:=context._parent;							windowSpec.value:=context.value;							setvalue(windowSpec, 'value, windowSpec.value);							executor:userClickAction(NIL,context) end,						contents: 'value,		
£Gø£GÀ				type: 'field, expert: kExpertScript},    				  				   						  	paragraph: {item: "paragraph",					drawing: nil,					drawDrawing: func() begin						if debug then print("doDrawing");						:lockScreen(TRUE);						:drawShape(drawing, styleFrame);						:lockScreen(NIL);						refreshviews();						end,					viewClass: clParagraphView,					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);    				executor:userClickAction(unit,self)     				end,					viewBounds: {Left:
£Gø£GÀ1, right: 100, top:150, bottom: 240},					viewDrawScript: func() if drawing and length(drawing)>0 then :drawDrawing(),					viewFlags: vReadOnly+vClickable,					viewFormat: vfFillWhite+vfFrameBlack+vfPen(1),					viewJustify: vjLeftH,					viewLineSpacing: 16,					text: "paragraph",					viewFont: simpleFont12,					visible: TRUE,					contents: 'text,					type: 'field, expert: kExpertExpert},	//peoplePicker: {_proto: protoPeoplePicker},	pictureButton: {item: "pictureButton",							_proto: p
£Gø£GÀrotoPictureButton,							icon: NIL,							viewBounds: {Left:1, right: 32, top:1, bottom: 32},							viewFormat: vfFrameBlack + vfpen(2) + vfround(4),							viewFlags: vClickable+vReadOnly,							visible: TRUE,							buttonClickScript: func() executor:userClickAction(NIL,self),							type: 'button, expert: kExpertScript}, 			  				   						      				  				   						   				  				   	picker:		{item: "picker",						_proto: protoPicker,						Bounds: {left:1, right: 95, top:120, bottom: 140},			
£Gø£GÀ			pickItems: [{item: "Picker", pickable: true, mark: kCheckMarkChar},							'pickseparator,"Two","Three"],						viewFormat: vfFrameBlack+vfFillWhite+vfPen(2)+vfround(4),						visible: TRUE,						pickActionScript: func(x) begin 							windowSpec.viewvalue:=x;							executor:userClickAction(NIL,self) 							end,						contents: 'viewValue,						type: 'ignore, expert: kExpertScript},				  				       				  				    	popupButton:	 {item: "popupButton",						_proto: protoPopupButton,						viewF
£Gø£GÀlags: vClickable+vReadOnly,						viewBounds: {Left:100, right: 160, top:1, bottom: 16},						text: "  Popup",						popup: ["one","two",'pickSeparator,"none"],						pickActionScript: func(x) begin							viewValue:=x;							executor:userClickAction(NIL,self); 							NIL end,						viewValue: 0,						viewFont: ROM_fontsystem9Bold,						viewJustify: vjcenterv+vjcenterh+onelineonly,						viewFormat: vfFrameBlack + vfpen(2) + vfround(4),						visible: TRUE,						contents: 'viewValue,						type
£Gø£GÀ: 'button, expert: kExpertScript}, 			  				   						  	rCheckbox: {item: "right checkbox",					_proto: protoRCheckBox,					viewValue: NIL,					text: "right checkbox",					viewBounds: {left: 1, right: 105, top:100, bottom: 120},					indent: 6,					viewFlags: vClickable,					viewFont: ROM_fontSystem10,          viewFormat: nil,          visible: TRUE,					valueChanged: func() begin windowSpec.viewvalue:=self.viewValue end,					viewSetupFormScript: func() begin indent:=viewBounds.right-10;
£Gø£GÀ end,					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);						executor:userClickAction(unit,self) 						end,					contents: 'viewValue,					type: 'button, expert: kExpertScript},   	scroller: {item: "scroller",					_proto: {},					text: "text",					contents: 'text,					boxTitle: "BoxTitle",					editOK: TRUE,					viewBounds: {Left:110, right: 220, top:1, bottom: 100},					viewClickScript: func(unit) begin						if hasSlot(self, '_parent) and hasSlot(self._paren
£Gø£GÀt, 'yMax) then return; // no taps if in edit mode						inherited:?viewClickScript(unit);    				executor:userClickAction(unit,self)     				end,    			visible: TRUE,					type: 'field, expert: kExpertScript},  				  						     				  						 	setClock: {item: "setClock",					_proto: protoSetClock,					viewBounds: {left: 1, right: 64, top:1, bottom: 64},					viewFlags: vClickable+vStrokesAllowed,					visible: TRUE,					minutes: date(time()).minute, hours: date(time()).hour,					timeChanged: 
£Gø£GÀfunc() begin 						windowSpec.hours:=hours;						windowSpec.minutes:=minutes;						windowSpec.time:={hours: hours, minutes: minutes};						:dirty();						executor:userClickAction(NIL,self) end,					contents: 'time,					type: 'field, expert: kExpertExpert},  				     				 						 				  						 	slider:  {item: "slider",					_proto: protoSlider, viewValue:50,					minValue: 0,					maxValue: 100,					gaugeDrawLimits: TRUE,					viewFlags: vClickable,					viewBounds: {left: 100, right: 200, to
£Gø£GÀp: 90, bottom: 100},					viewSetupFormScript: func() nil,					visible: TRUE,					changedSlider: func() begin 						windowSpec.viewvalue:=self.viewValue;						executor:userClickAction(NIL,self) end,					contents: 'viewValue,					type: 'field, expert: kExpertScript},	status:	 {_proto: protoStatus, 						type: 'ignore, visible: TRUE, expert: kExpertExpert},	text:	   {item: "text",					viewClass: clParagraphView,					viewBounds: {Left:110, right: 220, top:1, bottom: 100},					viewFlags: vC
£Gø£GÀlickable+vGesturesAllowed+vCharsAllowed+vPunctuationAllowed+vNumbersAllowed,					viewFormat: vfFillWhite+vfFrameBlack+vfPen(1)+vfLinesGray,					viewJustify: vjLeftH,					viewLineSpacing: 16,					visible: TRUE,					text: "Text Box",					contents: 'text,					viewFont: userFont18,					tabs: [20,40,60,80,120,140,160,180],					viewChangedScript: func(slot,view) begin windowSpec.text:=self.text;						executor:userClickAction(NIL,self) end,					type: 'field, expert: kExpertScript},    				  				
£Gø£GÀ         		 	textButton: {item: "textButton",						_proto: protoTextButton,						GOTO: nil,						GOSUB: nil,						viewBounds: {Left:1, right: 60, top:1, bottom: 16},						viewFlags: vClickable+vReadOnly,						text: "Button",						contents: 'text,						viewFont: ROM_fontsystem9Bold,						viewFormat: vfFrameBlack + vfpen(2) + vfround(4),						visible: TRUE,						buttonClickScript: func() executor:userClickAction(NIL,self),						type: 'button, expert: kExpertScript}, 			  				   						  	
£Gø£GÀtextList: {item: "textList",					_proto: protoTextList,					buttonClickScript: func(unit) begin    					:doAda(func() executor:userClickAction(nil,self), '[], 0); 						inherited:?buttonClickScript(unit);    				end,					viewBounds: {top: 10, left: 10, right: 100, bottom: 100},					visible: TRUE,					useScrollers: TRUE,					useMultipleSelections: NIL,					listItems: ["one","two","three"],					viewFormat: vfFrameBlack + vfpen(1) + vfFillWhite,					viewSetupDoneScript: func() begin :setupLi
£Gø£GÀst(); :redochildren() end,					contents: 'selectedItems,					scrollAmounts: [1,5,20],					type: 'button, expert: kExpertExpert},  title:	 {item: "title",  				_proto: protoStaticText,   				viewBounds: {Left:1, right: 60, top:20, bottom: 35},					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);    				 executor:userClickAction(unit,self)     				 end,  				viewJustify: vjLeftH,  				viewFont: ROM_fontSystem12Bold,  				viewFlags: vReadOnly+vClickable,  				text
£Gø£GÀ: "title",  				viewFormat: nil,  				visible: TRUE,  				contents: 'text,   				type: 'field, expert: kExpertScript},   });defconst('homePathP, strPos(home, "NewtCard Shell", 0));defconst('homePath, if homePathP then substr(home, 0, homePathP) else home);OpenResFile(homePath & "Unit- VisualDesigner:Resource.rsrc");call func() begin	local icons := {};	local skip := ['app, 'status, 'glance, 'floatNGo, 'picker, 'pt_userView,];	foreach slot, value in kWidgetLib do begin		if not LSearch(sk
£Gø£GÀip, slot, 0, '|=|, nil) then			icons.(slot) := GetPictAsBits(SPrintObject(slot), nil);		end;	DefConst('kWidgetIcons, icons);end with ();CloseResFile();
s(home, "NewtCard Shell", 0));defconst('homePath, if homePathP then substr(home, 0, homePathP) else home);OpenResFile(homePath & "Unit- VisualDesigner:Resource.rsrc");call func() begin	local icons := {};	local skip := ['app, 'status, 'glance, 'floatNGo, 'picker, 'pt_userView,];	foreach slot, value in kWidgetLib do begin		if not LSearch(sk
// End of text file widgetLib
// Beginning of file ExecutorUnit
executor :=
    {
     ENV:
       func(slotname) // user function	return getroot().(appSymbol).systemEntry.(intern(slotname));
       ,
     exWait:
       func(waitTime) begin	// Wait has two functions: to let the newton sleep, and to give a chance	// for another event to be picked up by the main event driver		// The wait is identified by the time() is was issued. When exWait1()	// is executed, the wait number (in waitOutstanding) is compared	// to the number of the wait that was passed in exWait1(). If the wait is	// still valid, execution continues.		// A wait can be invalid for two reasons:	//   1. a click occured in a window, setting waitOutstanding to nil	//   2. a new program was started.	// The waitOutstanding could be different than the wait that was passed if	// the original wait was ended and a new one issued. In this case, exWait1	// discards the old wait.		// if waitTime is -1, then the program does not resume execution automatically			_runFlag:=nil;	if waitTime<>-1 then begin		_waitOutstanding:=ticks();		if debug then print("Issue wait1 request:" & _waitOutstanding);		local w:=_waitOutstanding;		AddDelayedCall(func()			if (getroot().(appSymbol).viewCObject) then _RF:exWait1(w), '[], waitTime);		end	else _waitIndefinite:=TRUE;end
       ,
     _context: kAppSymbol,
     deleteCardFixPointers:
       func(entry,prevCard,nextCard) begin	if debug then print("deleteCardFixPointers:" & entry.sub);	local tempcard;		if card.(nextCard) then begin		tempCard:=:getEntry(card.(nextCard));		tempCard.(prevCard):=card.(prevCard);		entryFlushXmit(tempCard, nil);		end;			if card.(prevCard) then begin		tempCard:=:getEntry(card.(prevCard));		tempCard.(nextcard):=card.(nextCard);		entryFlushXmit(tempCard, nil);		end;		//adjust background or stack header	entry.cardcount:=entry.cardcount-1;	if entry.firstCard=card.ID then begin		if card.(nextCard) 			then entry.firstCard:=card.(nextCard)			else entry.firstCard:=entry.lastCard; //only one card		end;			if entry.lastCard=card.ID then begin		if card.(prevCard)			then entry.lastCard :=card.(prevCard)			else entry.lastCard:=entry.firstCard; //only one card		end;	end
       ,
     exWindow1:
       func(newWindow, widget) begin // actually create the window	if hasslot(newWindow, 'widgetType) then widget:=newWindow.widgetType;	local n;	local proto:=widgetLib.(intern(widget));	local baseView:=currentLayer;		if NOT proto or (proto._proto=NIL and proto.viewClass=NIL and NOT strEqual(widget,"pt_userView")) 		then return (:error(kError23));	if classof(newWindow)<>'frame then return (:error(kError24));		if strEqual(widget,"pt_userView") then newWindow._proto:=executor.pt_userview	else if strEqual(widget,"scroller") then newWindow._proto:=executor.scroller	else if strEqual(widget,"app") then newWindow._proto:=executor.app;		if proto then foreach slot,value in proto do		if NOT hasSlot(newWindow, slot) then newWindow.(slot):=value;	if newWindow.draggable and not hasSlot(newWindow, 'viewClickScript)		then newWindow.viewClickScript:=func(unit) :drag(unit,nil);		addArraySlot(_userViews, addStepView(baseView, newWindow));	n:=length(_userViews)-1;	_userViews[n].windowspec:=newWindow;	return _userViews[n]end
       ,
     isANumber:
       func(var) //returns a number, or if not a number, returns value unchanged//this is needed 'cus StringToNumber doesn't handle "45 LIST" properlybegin	if classOf(var)<>'string then return var;	if StringToNumber(var)=NIL then return var;	local validChars:=kNumeric & "E-";	for i:=0 to strLen(var) do		if strPos(validChars, substr(var,i,1), 0)=NIL then return var;	local x:=stringToNumber(var);	if x=floor(x) then x:=floor(x);	return xend
       ,
     copyWidget:
       func(widget) begin //make a copy of widget - symbol is passed	local w, scriptname, widgetcopy, clipboardDataFrame, ID;	w:=baseview.(backgroundmode).widgets.(widget);	if w=nil then return; // no such widget	scriptName:=:makeScriptName('widget, backgroundmode, widget);	ID:=baseview.(backgroundmode).subs.(scriptName);	if debug then print(widget && scriptName);		widgetCopy:={spec: deepClone(w), sub: ID, pointers: {} };	// sub header	:copyID(widgetCopy.pointers,ID);		local subEntry:=:getEntry(ID);	// listrecs	foreach ID in subEntry.listRecs do :copyID(widgetcopy.pointers,ID);		// datarecs	foreach ID in subEntry.datarecs do :copyID(widgetcopy.pointers,ID);		// coderecs	foreach ID in subEntry.coderecs do :copyID(widgetcopy.pointers,ID);	clipBoardDataFrame:={label: "",											 types: [['newtcard]],											 data:  [[widgetCopy]],											 bounds: {} };	if w.type='button 		then clipBoardDataFrame.label:="Button"		else clipBoardDataFrame.label:="Field";	setClipBoard(ensureInternal(clipBoardDataFrame));	end
       ,
     updateSlots:
       func(frame, specFrame) begin	// this method is used to update slots in stack, background and card records	_ignoreWidgetChanges:=true;	if hasSlot(specFrame, 'name) and specFrame.name=nil then specFrame.name:="";	foreach slot, value in specFrame do		frame.(slot):=value;	_ignoreWidgetChanges:=nil;	end
       ,
     _openStackInProgress: nil,
     exEnterNewtonPress:
       func(pkgName) begin	local pkgRef, pkgInfo, data, dataPtr, dataLen, line, title, contents, h, page, blocks;	title:="";	pkgRef:=getPkgRef(pkgName, getDefaultStore());	if NOT pkgRef then begin // see if it's of the form bookname.title		p:=strPos(pkgName, "/",0);		if NOT p then return (:error(kErrorM11));		title:=subStr(pkgName, p+1, nil);		pkgName:=subStr(pkgName, 0, p);		pkgRef:=getPkgRef(pkgName, getDefaultStore());		if NOT pkgRef then return (:error(kErrorM11));		end;					pkgInfo:=getPkgRefInfo(pkgRef);	if NOT hasSlot(pkgInfo, 'parttypes) or pkgInfo.partTypes[0]<>'book		then return (:error(kErrorM11));	enterInProgress:=TRUE;	if NOT title then begin	// simple book with just a program in it		data:=pkgInfo.parts[0].book.contents[0].data;		end	else begin // find the title in the table of contents		contents:=pkginfo.parts[0].book.browsers[0].list;		for i:=0 to length(contents)-1 do			if beginsWith(contents[i].item.data, title) then break (h:=i);		if not h then return (:error(kErrorM11));		page:=pkginfo.parts[0].book.rendering[0].contents[0][h]-1;		blocks:=pkginfo.parts[0].book.rendering[0].pages[page].blocks;		data:="";		for i:=1 to length(blocks)-1 do			data:=data & CR & blocks[i].item.data;	end;		dataPtr:=0;	dlen:=strLen(data);	while enterInProgress do begin		nextCR:=strPos(data,CR,dataPtr);		if NOT nextCR then break;		line:=substr(data,dataPtr,nextCR-dataPtr);		dataPtr:=nextCR+1;				if debug then print(line);		:progress(pkgName,"Entering...",floor(100*dataPtr/dlen));		editor:handleInputLine(line);		end;	enterInProgress:=nil;	:progress(nil,nil,nil);			end
       ,
     getEntryWithScript:
       func(sub) begin	local script:=sPrintObject(sub);	if beginsWith(script, "stack")  then return stack      else	if beginsWith(script, "bg")     then return background else	if beginsWith(script, "cd")     then return card	end
     ,
     userClickAction:
       func(unit,context) begin	if _RF._runFlag then return NIL; // only during a WAIT!	if _ignoreWidgetChanges then return NIL;	if debug then print("userClickAction");	local newLine;	local ws:=context.windowSpec;	if unit then begin		local box:=context:globalBox();		ws.firstX:=getpoint(firstX, unit)-box.left;		ws.firstY:=getpoint(firstY, unit)-box.top;		ws.lastX :=getpoint(lastX, unit)-box.left;		ws.lastY :=getpoint(lastY, unit)-box.top;		ws.unit:=unit;		end;	ws.tempFlag:=TRUE;	for i:=0 to length(_RF._userViews)-1 do		if _RF._userViews[i].windowSpec.tempFlag then _RF.wStat:=i;	removeSlot(ws, 'tempFlag);	if not newtCard then begin		local goto:=ws.goto;		local gosub:=ws.gosub;		if NOT goto and NOT gosub then begin			goto:=context.goto;			gosub:=context.gosub;			if NOT goto and NOT gosub then return NIL		end;		if debug then print(" GOTO :" & sprintObject(goto));		if debug then print(" GOSUB:" & sprintObject(gosub));		  				if gosub then begin			addArraySlot(_RF._gosubStack,_RF:getLineNo(_RF._codePos));			if _RF._waitIndefinite then begin // make negative to return to this line				local GS:=_RF._gosubStack;				GS[length(GS)-1]:=-1 * GS[length(GS)-1];				end;			newLine:=interpreter:labelResolve(gosub, true);			end		else newLine:=interpreter:labelResolve(goto, true);			if NOT newLine then return (:error(kError12));		_RF._codePos:=_RF:chGetXLine(newLine);		if _RF._codePos=-1 then return (:error(kError12));		_RF._waitOutstanding:=NIL;		_RF._waitIndefinite:=NIL;		_mainRF._runState:=TRUE; // resume execution			_RF._runFlag:=0;		if NOT systemEntry.enableBreak // actually execute the program			then :doAda(func() _RF:doRun1(), '[], 1); // actually execute the program			else :doAda(func() _RF:doRun1withBreak(), '[], 1);		end	else begin		local scriptName;		if context.cardView 			then scriptName:=:makeScriptName('widget, 'card, context.widgetName)			else scriptName:=:makeScriptName('widget, 'background, context.widgetName);				:doActions('widget, context.leaveSound, context.leaveEffect, scriptName);		if context.placesToGo			then :doAda(func() _rf:exGo(context.placesToGo), '[], 3);		end;end
       ,
     openRF:
       func(rf) begin	// open a new runframe RF, with parent being the current runFrame.	if debug then print("openRF:" && rf._context);	local old_RF:=_RF;	_RF:=deepclone(kEmptySubRF);	_RF._parent:=old_rf;	_RF._ch:=old_RF._ch;	_RF._codeRecPos:=old_RF._codeRecPos;	_RF._funcFrame:=rf;	_RF._oldSub:=_header.ID;	if not newtCard then _RF._runFlag:=0;	_RF:initSymbolTable();	foreach slot,val in rf do //this loads the parameters and _currFuncFrame		if classOf(val)='pathexpr 			then _RF.(slot):=old_RF.(val)			else _RF.(slot):=val;	killFrames.(rf._context):=_RF;	_rf		end
       ,
     exOn:
       func(compiled) begin	if debug then print(compiled);	if compiled.type<>'onError then begin  // ON GOTO or ON GOSUB		local result:=compiled.test;   	if classof(result)<>'int and classof(result)<>'real then return (:error(kError16));   	if result<1 or result>length(compiled.targets) then return;   	if compiled.type='gosub then addArraySlot(_gosubStack,:getLineNo(_codePos));   	_runFlag:=_header.labels.(compiled.targets[result-1]);   	if NOT _runFlag then return (:error(kError12));		if debug then print("ON.result:" & result & " runFlag:" & _runFlag);   	return NIL   	end;   	// ON ERR	_errorCounter:=:labelFind(compiled.targets[0])    	end
       ,
     resumeExecution:
       func() begin	// if there was an input error, _codePos is already set. Otherwise, execute next _codePos	if NOT _inputError			then :chGetNextXLine();		else _inputError:=NIL;	if debug then print("Execution will resume at " & :getLineNo(_codePos));	_runFlag:=0;	if NOT systemEntry.enableBreak // actually execute the program		then :doRun1() // actually execute the program		else :doAda(func() _RF:doRun1withBreak(), '[], 1); 	end
       ,
     viewSetupDoneScript:
       func() begin	if debug then print("executor.viewSetupDoneScript");	if not hasSlot(executor, 'stepChildren) 		then executor.stepchildren:=clone(executor.stepchildren);	if not newtCard then begin		local filename:=kSoupName;		_workSoup:=:getNonUnionSoup(:makeProgramName(filename));		if _workSoup=nil then begin			if not kUpdate 				then interpreter:getNewSoup(filename);				else begin					:notify(kNotifyAlert,"NS BASIC Update " & substr(kVersion, 8, nil),						"Please install your original copy of NS BASIC, " & 						"then reinstall this update.");					screenview:close();			  end // else			end; // if			// check if prior 4 format worksoup		if not hasSlot(_workSoup._proto.indexes[1], 'rev)			or _workSoup._proto.indexes[1].rev<>4 then begin			_workSoup:RemoveFromStore();			:getNewSoup(filename);			systemEntry.programName:=NIL;			end;			_work:=_workSoup:query({indexpath: 'ID});		// clean up: worksoup could contains runtime workfile		_work:reset();		_sub:='main;		_header:=_work:gotokey(kMainSub);		if hasSlot(_header, 'coderecs)			then _RF._ch:=_work:gotokey(_header.codeRecs[_RF._codeRecPos:=0]);		_subs:=_header.subs;		end // if NS BASIC					else begin  // NewtCard open		if not systemEntry.programName then			if :getNonUnionSoup(:makeProgramName("Home"))				then systemEntry.programName:=:makeProgramName("Home")				else systemEntry.programName:=:makeProgramName("Untitled");					:doAda(func()			if :getNonUnionSoup(systemEntry.programName) 				then _rf:openStack(systemEntry.programName)				else if :getNonUnionSoup(:makeProgramName("Home"))					then _rf:openStack("Home")					else if :getNonUnionSoup(:makeProgramName("Untitled"))						then _rf:openStack("Untitled")						else _rf:newStack({name: "Untitled"}),			'[], 500);		end	end
       ,
     renameStack:
       func(oldStackName, newStackName) begin	if oldStackName=nil then oldStackName:=stack.name;	if newStackName=nil then return nil;	if debug then print("rename stack:" && oldstackname && newstackname);		if :getNonUnionSoup(:makeProgramName(newStackName)) then begin		:error(kErrorM5);		return nil;		end;		local oldStack:=:getNonUnionSoup(:makeProgramName(oldStackName));	if not oldStack then begin		:error(kErrorM10);		return nil;		end;			oldstack:setName(:makeProgramName(newStackName));		if newtCard then begin // update name slot on stack record		local oldStackquery:=oldStack:query({indexpath: 'ID});		local tempStack:=oldStackQuery:gotoKey(kMainSub);		tempStack.name:=newStackName;		entryFlushXmit(tempStack, nil);		end;	if debug then begin		setValue(stackName, 'text,			stack.Name & CR &			background.ID && background.sub && background.name & CR &			card.ID && card.Name);		refreshviews();		end;	return true;		end
       ,
     closeRF:
       func() begin	if _RF._context='main then return;	// close the current runframe, set runframe to _parent and put _header back	if debug then print("closeRF:" & _rf._context && _rf._parent._context);	local old_RF;	old_RF:=_RF;	_RF:=old_RF._parent;	removeSlot(killFrames, _rf._context);		//set up return values	foreach slot,val in old_rf._funcFrame do //this loads the parameters and _currFuncFrame		if classOf(val)='pathexpr then _RF.(val):=deepClone(old_RF.(slot));	if not newtCard then _RF._runFlag:=0;	if hasSlot(old_rf, '_oldsub) then begin // switch to previous sub (if this was a sub block)		_header:=:getEntry(old_RF._oldSub);		_sub:=_header.sub;		_subs:=_header.subs;		end;	old_RF:=nil; // it won't go away until the :doRun returns from _runFlag=NIL	nil	end
       ,
     copyIntoFrame:
       func(entry) begin	local subEntry;	local frame:=deepclone(entry);	frame.pointers:={};	// now, put the contents of the records pointed to into pointers{ID_x: {value}}	foreach sub,ID in entry.subs do begin		// sub header		:copyID(frame.pointers,ID);				local subEntry:=:getEntry(ID);		// listrecs		foreach ID in subEntry.listRecs do :copyID(frame.pointers,ID);				// datarecs		foreach ID in subEntry.datarecs do :copyID(frame.pointers,ID);				// coderecs		foreach ID in subEntry.coderecs do :copyID(frame.pointers,ID);				end;		frame	end
       ,
     exExit:
       func(arg)	if arg=kDo then begin		if debug then print("exExit DO: _doStackTop:" & _doStackTop);		if _doStackTop=NIL then return (:error(kError61));		:exDoPop();			:chGetStatement([kLoop]);		end	else if arg=kFor then begin		if debug then print("exExit FOR: forNextTop:" & _forNextTop);		if _forNextTop=NIL then return (:error(kError61));		:exForPop();		:chGetStatement([kNext]);		end;					
     ,
     exLoop:
       func(cond) begin	if _doStackTop=NIL then return (:error(kError60));	if debug then print("exLoop: _doStackTop:" & _doStackTop);	if debug then print(cond);		if cond 		then _runFlag:=_doStackTop		else :exDoPop();end
     ,
     _How_RF_works:
       nil/* This slot is just for documentationHow _RF worksThe slot _RF is the current context (or Run Frame). It is contained in the base view.Normally, it is equivilent to the special variable, self. It contains all the variables that are local to the current environment, and has a _parent slot that references the next higher up environment.In the case of NewtCard, the lowest level is normally a card. _RF will have the local slots, andthe _parent slot will point to another _RF, for the background. It, in turn, will havea _parent slot pointing to the stack's _RF (which is also referenced as _mainRF). Finally,the main _RF's _parent is executor.When a script is running, a new _RF is created, with its parent being the _card thatcalled it.In the case of an NS BASIC program, the main program is _mainRF, as is _RF; unlessa subroutine is running. Then the subroutine becomes _RF with its _parent being _mainRF.In each _RF, there is always a _context slot. This helps identify what the _RF is for.The main one is always called 'main; for NewtCard, it contains the card.sub orbackground.sub value. For NS BASIC, it's the name of the subroutine.Context SwitchingRemember I said "normally" in the first paragraph? The exception is when we're changingcontexts. The way this is done is that the _RF frames are reorganised (a new one added,or one removed). Care need to be taken that all variables are fully referenced when thisis done. Most of this work happens in the openRF() and closeRF() methods.The context gets changed next time a call is made to anything in executor. These callsshould always be done to _RF: thereby all variable references are to the current _RF,and the actual methods are found by _parent inheritance in the executor frame.The _bgcd frameIn executor, there's a _bgcd frame that makes it easier to keep track of which runframebelongs to what. It has three slots, background, card and script.While _bgcd.background and _bgcd.script always point to the current object, script is NIL if not running. Otherwise it points to the _topmost_ script: the one thatwas started directly from the the stack, background or card. If another script is called from that script, _bgcd.script is not changed.If the card changes while a script is running, the _parent of the topmost script is setto the new card.*/
     ,
     exEnter:
       func(fileName) begin	local s, stmtno, stmt, p, currLine;	if fileName=nil then return (:error(kErrorM10));	if strPos(fileName, "/", 0) or getPkgRef(filename,getDefaultStore()) then begin		:doada(func() :exEnterNewtonPress(filename), '[], 6);		return		end;		if strPos(fileName,kExt,0) then begin		if endsWith(filename, kExt) then fileName:=substr(filename,0,strPos(filename,kExt,0));		fileName:=:makeProgramName(fileName);		end;	if debug then print("ENTERing" && fileName);		if fileName=nil then return (:error(kErrorM10));	local enterSoup:=defStore:getsoup(filename);	if enterSoup=nil then return (:error(kErrorM10));	enterInProgress:=TRUE;	if interpreter.stmtFrame then currLine:=interpreter.stmtFrame.stmtNo; // remember current line number			local enterQ:=enterSoup:query({type: 'index});	local enterEntry:=enterQ:entry();	while enterEntry and enterInProgress do begin		stmtno:=stmt:=nil;		if hasSlot(enterEntry, 'lineNo) and hasSlot(enterEntry, 'text) 			then begin // This is a program file			stmtNo:=enterEntry.LineNo;						if classOf(stmtNo)='string   // Pre-3.10 format				then if beginsWith(enterEntry.lineNo,"D") or beginsWith(enterEntry.LineNo,"X")					then stmtNo:=nil;			if classOf(stmtNo)='int then // 3.10 and later				if stmtNo=kHeadBase					then stmtNo:=nil					else if stmtNo>kListBase then stmtNo:=numberStr(stmtNo-kListBase);								stmt:=trimString(enterEntry.text);			end		else // this is a straight text file			if hasSlot(enterEntry, 'text) then begin				s:=trimString(enterEntry.text);				p:=strPos(s," ",0);				stmtNo:=trimString(substr(s,0,p));				stmtNo:=:formatLineNo1(stmtNo);									if p then stmt:=trimString(substr(s,p,nil)) else stmt:="";				end;		if classof(stmtNo)='int then stmtNo:=numberStr(stmtNo);		if stmtNo then begin			if debug then print(stmtNo && stmt);			interpreter:saveStmt(stmtno, stmt);			end;		enterEntry:=enterQ:next()	end;  // while	if _runFlag and currLine then interpreter.stmtFrame:=:chGetXLine(currLine); // go back to current line	enterInProgress:=nil;			end
       ,
     hexdump:
       func(str,startpt,endpt) begin //user function	local text, x, line, output, str, strLen;	output:="";	if not startpt then startpt:=0;	if not endpt then endpt:=length(str);	strLen:=endpt-startpt;	for i:=startpt to endpt by 16 do begin		text:="";		line:=substr(sprintobject(i+10000),1,NIL) & ":";		for byte:=i to min(i+15,strLen-4) by 4 do begin			x:=clone("1");			binarymunger(x,0,8,str,byte,4);			line:=line && strhexdump(x,4);			x:=extractByte(str,byte);			if x<32 or x>128 then x:=46;			text:=text & chr(x);			x:=extractByte(str,byte+1);			if x<32 or x>128 then x:=46;			text:=text & chr(x);			x:=extractByte(str,byte+2);			if x<32 or x>128 then x:=46;			text:=text & chr(x);			x:=extractByte(str,byte+3);			if x<32 or x>128 then x:=46;			text:=text & chr(x);			end;		while strlen(line)<46 do line:=line & " ";		if debug then print(line & text);		output:=output & line & text & chr(13);		end;	return output	end
       ,
     viewFormat: 336,
     deleteCard:
       func() begin	if debug then print("delete Card" && card.ID);	if stack.cardCount=1 then begin		:notify(kNotifyAlert, systemEntry.programName, "Can't delete only card in stack.");		return nil;		end;			if background.cardCount=1 then begin		if modalConfirm("Last card in background. Delete background?", 'okCancel)			then :deleteBackground();			else return nil;		return true;		end;		local oldHeaderID:=:headerSave();  // save script _RF	_bgcd.card:=:closeRF();	:deleteCardEntry('normal);			entryFlushXmit(stack, nil);			//position card to previous (or firstCard if eof) record.	local ID:=card.prevCardStack;	if NOT ID then ID:=stack.firstCard;	card.ID:=nil;  //mark as stale		:openCard(ID);	:headerRestore(oldHeaderID); // if running a script, set _RF back	end
       ,
     displayLayerWidgets:
       func(backgroundMode) begin	if debug then print("displayLayerWidgets:" & backgroundMode && _rf._context);	local cardRF:=nil;	local contents, widget, widgetname;		// if we're displaying bg widgets, we need to change our _RF	if backgroundMode='background and _rf._parent._context<>'main then begin		cardRF:=_rf;		_rf:=_rf._parent;		end;		_rf._widgets:=deepclone(baseview.(backgroundMode).widgets);		if backgroundMode='card then begin		if _rf._widgets then			foreach w in _rf._widgets do w.cardView:=TRUE;		//remove contents slot in widget; reset value in widgetSpec;		local backgroundWidgets:=_bgcd.background._widgets;		if backgroundWidgets then foreach widgetName, frame in backgroundWidgets do begin			widget:=backgroundWidgets.(widgetName);			contents:=widget.contents;			if contents and hasVariable(widget, contents) then begin				removeSlot(widget, contents);				widget.windowSpec.(contents):=clone(background.widgets.(widgetName).(contents));				end			end;		_ignoreWidgetChanges:=TRUE;		// update background widgets		if card.bgWidgets then			foreach widget, value in card.bgWidgets do				foreach slot, value in card.bgWidgets.(widget) do					setvalue(backgroundWidgets.(widget), slot, clone(value));						// update card widgets		if card.cdWidgets then			foreach widget, value in card.cdWidgets do				foreach slot, value in card.cdWidgets.(widget) do					setvalue(_bgcd.card._widgets.(widget), slot, clone(value));						_ignoreWidgetChanges:=nil;		end;	if _rf._widgets then begin		_RF:exWindow({specName: '_widgets, win: '_widgetList, widget: NIL});		_RF:exShow(_rf._widgetList);		end;		if cardRF then _rf:=cardRF; // put it back	end
       ,
     exOpen:
       func(compiled) begin	local query, soup;	if debug then print("exOpen");	if debug then print(compiled);		local soup:=getUnionSoup(compiled.filename);	if NOT soup then return (_rf.FSTAT:=1);		try query:=soup:query(compiled.querySpec);		onexception |evt.ex| do return (:error(kErrorM2));			addArraySlot(_openFiles, {soup: soup, query: query, flag: nil, entry: nil,														 key: compiled.querySpec.indexpath});	_RF.(compiled.chan):=length(_openFiles)-1; 			_rf.FSTAT:=0;	end
     ,
     enterInProgress:
       nil /* Set to true while ENTER command is processing.   Set to nil when ENTER command complete or an error is encountered */
     ,
     exWPRINT:
       func(compiled) begin	if debug then print(compiled);	if classof(compiled.win)<>'int then return (:error(kError25));	setValue(_userViews[compiled.win], 'text, sprintObject(compiled.value));	refreshviews();end
     ,
     labelFind:
       func(lineNo) // given a label, returns a lineNo	if hasSlot(_header.labels, lineNo)		then return _header.labels.(lineNo);		else return (:error(kError12));
       ,
     pasteFromFrame:
       func(mode, paste) begin	local subEntry:=nil;	local specFrame:={name: paste.name};	local newSub;											if mode='background then begin		_rf:newBackground(specframe);		entry:=background;		end	else entry:=card;  // new bg created the new card already		//copy slots	entry.name:=paste.name;	entry.drawings:=paste.drawings;	entry.widgets:=paste.widgets;	entry.arriveSound:=paste.arriveSound;	entry.leaveSound:=paste.leaveSound;	entry.arriveEffect:=paste.arriveEffect;	entry.leaveEffect:=paste.leaveEffect;	if mode='card then begin		entry.cdWidgets:=paste.cdWidgets;		entry.bgWidgets:=paste.bgWidgets;		end;										_rf:=_bgcd.(mode);	foreach sub, ID in paste.subs do begin		// copy sub header		newSub:=sPrintObject(sub);		p:=strPos(newSub,"_",4);		if mode='background			then newSub:=intern(background.sub & substr(newSub,p,nil));			else newSub:=intern("CD_" & card.id & substr(newSub,p,nil));		entry.subs.(sub):=:pasteID(paste, ID); // use old name for now- rename later		subEntry:=:getEntry(entry.subs.(sub));				// copy records to their new locations		foreach i,j in clone(subEntry.listRecs) do subEntry.listRecs[i]:=:pasteID(paste,j);		foreach i,j in clone(subEntry.dataRecs) do subEntry.dataRecs[i]:=:pasteID(paste,j);		foreach i,j in clone(subEntry.codeRecs) do subEntry.codeRecs[i]:=:pasteID(paste,j);		entryFlushXmit(subEntry,nil);				// update SUB statement with new subroutine name		:renameASub(sub, newSub);				end;	entryFlushXmit(entry,nil);	end
       ,
     exClose:
       func(compiled)	if length(compiled)>0 		then foreach ch in compiled do 			if :checkChan(ch) then _openFiles[ch]:=NIL					else _openFiles:=[];
     ,
     exNext:
       func (idxName) begin	local FNT;	if NOT (FNT:=_forNextTop) then return (:error(kError22));	if NOT strEqual(idxName, FNT.idxName) then return (:error(kError22));	local int idx:=_RF.(FNT.idxPath) + FNT.Stepp; 	if debug then print("Do NEXT " & idxName && idx);	if ( if FNT.up then idx>FNT.endd else idx<FNT.endd)		then :exForPop()  // loop complete		else begin        // continue loop			_runFlag:=FNT.lineNo;			_RF.(FNT.idxPath):=idx;			end;	end
       ,
     getStmtNo:
       func(codePos) //given codePos in current codeRec, return the statement number	//may go away with statement numbers, or at least return lineNo	return _header.stmtNos[:getLineNo(codePos)];
       ,
     makeScriptName:
       func(type, mode, widgetName) begin	// type is 'stack, 'background, 'card or 'widget	// mode is 'arrive or leave for first three, 	//         'card or 'background for widget.	// widgetName is only for type widget.		local scriptname:=nil;		if type='stack		then scriptname:="stack_" & mode	else if type='background		then scriptname:=background.sub & "_" & mode	else if type='card		then scriptname:="cd_" & card.ID & "_" & mode	else if type='widget then begin		if mode='background			then scriptname:=background.sub & "_w" & widgetName			else scriptname:="cd_" & card.id & "_w" & widgetName;		end;				intern(scriptName);end
       ,
     exHWInputArg:
       func(arg) begin	if HWInput.varType='string		then _RF.(HWInput.var):=sPrintObject(arg)		else _RF.(HWInput.var):=:isANumber(arg);	   	_inputFlag:=nil;	:resumeExecution();	end
     ,
     exInput:
       func(compiled) begin	if length(compiled.vars)=0 then return;	if NOT _runFlag then return NIL;	_inputFlag:=true;	_runFlag:=NIL;	_inputPtr:=0;	_inputCompiled:=compiled;	:printLineFlush();	if strLen(systemEntry.inputPrompt)>0 then interpreter:addLines([systemEntry.inputPrompt]);	if strEqual(systemEntry.io, "scre") then begin		:doada(func() setKeyView(editor, strLen(editor.text)), '[], 10); 		if basicAlphaInUse then begin			if editor.basicAlpha.viewCObject=nil then editor.basicAlpha:open();			editor.basicAlpha:show();			end		end;	if length(_inputStack)=0 then return NIL;	:exInputArg();	if _runState then :resumeExecution();	end
     ,
     openStack:
       func(fileName) begin	if debug then print("openStack:" && filename);	// can be called with stack.name or fullfilename with extension	if not filename or strEqual(filename,"") then filename:="Untitled";	local p,worksoup,query,header, longFileName;	longFilename:=:makeProgramName(filename);			if not :getNonUnionSoup(longFilename) then begin		:notify(kNotifyAlert, systemEntry.programName, "Stack " & filename & " does not exist.");		return		end;			if stack then :closeStack();		systemEntry.programName:=longFilename;		systemEntry.useScratch:=nil;	if endsWith(filename, kExt) then fileName:=substr(filename,0,strPos(filename,kExt,0));	interpreter.newStmt:=filename;	interpreter:doLoad();	if interpreter.stmtFrame.err then return;		stack:=_header;		if not stack.firstCard then begin		:notify(kNotifyAlert, systemEntry.programName, "Stack " & filename & " is not a valid stack. Remove it before restarting NewtCard.");		return		end;			_sub:='main;	:loadSubs('stack);		background:={ID: nil};	card:=nil;	_mainRF._cardsVisited:=[];	_RF._cardQuery:=_workSoup:query({indexPath: 'name});	_openStackInProgress:=true;	if not :openCard(filename) then :openCard(stack.firstCard);	_openStackInProgress:=nil;	_rf:=_mainRF;	_subs:=stack.subs;	_rf:doActions('show, stack.arriveSound, 										stack.arriveEffect, 										:makeScriptName('stack,'arrive, nil));	_rf:=_bgcd.background;	_subs:=background.subs;	_rf:doActions('show, background.arriveSound, 										background.arriveEffect, 										:makeScriptName('background,'arrive, nil));	_rf:=_bgcd.card;	_subs:=card.subs;	_rf:doActions('show, card.arriveSound, 										card.arriveEffect, 										:makeScriptName('card,'arrive, nil));	end;	
       ,
     viewFlags: 1,
     sendIRRemote:
       func(trans,reps) begin //user function	if length(trans)<6 then return NIL;	if classOf(reps)<>'int then return NIL;	if reps<1 then return NIL;	local cookie:=OpenRemoteControl();	if cookie=NIL then return NIL;	trans[5]:=length(trans)-6;	local c:=setLength(clone(""),24+length(trans)*4);	for i:=0 to length(trans)-1 do stuffLong(c,i*4,trans[i]);	SendRemoteControlCode(cookie,c,reps);	CloseRemoteControl(cookie);	return TRUE;	end
       ,
     exEndIF:
       func()  begin // END IF	if debug then print("exEnd If:" && _thenLevel);	if _thenLevel=0 then return (:error(kError88));	_thenLevel:=_thenLevel-1;	end
       ,
     exWait1:
       func(waitNumber) begin	// see exWait for full explanation of sleep & clicks	if waitNumber<>_waitOutstanding then begin  // a userproto got clicked while we slept		if debug then print("end Wait cancelled:" & waitNumber);		return		end;						 	if debug then print("end Wait: resume execution:" & waitNumber);	if debug then print(_runstate);	// no click - just go to next statement	_waitOutstanding:=NIL;	if not _runState then return;	if debug then print("calling resumeExecution"); 	:resumeExecution();end
       ,
     closeStack:
       func() begin	:closeEntry('card, card);	:closeEntry('background, background);	:closeEntry('stack, stack);	end;
     ,
     dontInitSymbolTable: nil,
     ioPrint:
       func(ep, text) io:ioPrint(ep, text) //user function
       ,
     _temp: nil,
     frameToOrderedArray:
       func(frame) begin // This function takes a frame of frames and returns an array of those frames// sorted by the 'order slot in each frame.	if debug then print("Frame to ordered array called");	local result:=[];	foreach slot, widget in frame do begin		widget.widgetName:=slot;		addArraySlot(result, widget);		end;	sort(result, '|<|, 'order);	result;	end
       ,
     exHide:
       func(compiled) begin	local baseView:=currentLayer;	_hideUserViewsRunning:=TRUE;	if length(compiled)>0 then begin	foreach win in compiled do		if classof(win)='int 			then _userViews[win]:hide()		else if classOf(win)='array then begin			foreach w in win do							if classof(w)='int 					then _userViews[w]:hide()					else return (:error(kError23))			end		else if classOf(win)='frame then begin			win:hide();			win.visible:=NIL;			end;		else return (:error(kError23));				baseview:dirty();		refreshviews();		end;	else :hideUserViews();	_hideUserViewsRunning:=NIL;end
     ,
     initSymbolTable:
       func() begin	if debug then print("initsymboltable");	:clearCurrentException();	if not newtcard then :hideUserViews();	_errorCounter:=0;	_inputLineHold:="";		if NOT dontInitSymbolTable then begin		_gosubStack:=[];		_forNextStack:=[];		_forNextTop:=NIL;		_doStack:=[];		_doStackTop:=NIL;		_inputStack:=[];			 	// _inputStack holds results from the input stream until an INPUT statement can get it.				// It is used in the exInputArg function		_lastLineNo:=0; // used in execution		_lastStmtNo:=0; // used in editing		_waitOutstanding:=nil;		_thenLevel:=0;		_trace:=nil;		_openFiles:=[];		foreach slot,value in _RF do			if NOT beginsWith(sPrintObject(slot),"_") then removeSlot(_RF, slot);		end	else dontInitSymbolTable:=NIL;	if chainParam then chainParam:=chainParam; //help 	end
       ,
     getNewBGName:
       func() begin //find first unused BG_n	local i:=0;	while hasSlot(stack.backgrounds, intern("BG_" & i)) do i:=i+1;	"BG_" & i;	end
       ,
     headerRestore:
       func(oldHeaderID) begin	if NOT oldHeaderID then return nil;		// if oldHeaderID isn't nil then we're running a script, and we have to	// set the parent of the script to the new card,	// and set the header back to the script.		_bgcd.script._parent:=_rf;  // set the parent of the script to the new card	_RF:=_bgcd.script;          // and put our _RF back to the script	if debug then print("headerRestore" && _rf._oldSub && card.id && _bgcd.script._context);	_RF._oldSub:=card.ID;	_header:=:getEntry(oldHeaderID);	_subs:=_header.subs;		end
       ,
     exGosub:
       func(newLineNo) if newLineNo then begin	_runFlag:=newLineNo;	addArraySlot(_gosubStack,:getLineNo(_codePos));	if debug then display("GOSUB");	if debug then print(_gosubStack);	endelse return (:error(kError12));
     ,
     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     duplicateStack:
       func(oldStackName, newStackName) begin	if oldStackName=nil then oldStackName:=stack.name;	if newStackName=nil then newStackName:=stack.name && "Copy";		if :getNonUnionSoup(:makeProgramName(newStackName)) then return (:error(kErrorM5));		local oldStack:=:getNonUnionSoup(:makeProgramName(oldStackName));	if not oldStack then return (:error(kErrorM10));		local newStack:=interpreter:getNewSoup(newStackName);	newStack:removeAllEntriesXmit(nil);			oldstack:copyEntriesXmit(newStack,nil);		if newtCard then begin // update name slot on stack record		local newStackquery:=newStack:query({indexpath: 'ID});		local tempStack:=newStackQuery:gotoKey(kMainSub);		tempStack.name:=newStackName;		entryFlushXmit(tempStack, nil);		end;	end
       ,
     saveWidgetValues:
       func(context) begin	// save card's values for bg widgets in card.xxWidgets (xx=cd or bg)	// only keep changed slotnames and values	if debug then print("saveWidgetValues:" && context && if card then card.ID);	local currValue, bgValue, contents, styles, visible;			local theWidgets:=_bgcd.(context)._widgets;	local changes:={};	if not theWidgets or length(theWidgets)=0 then return;	foreach widget, layout in theWidgets do begin		contents:=theWidgets.(widget).contents;    // get the name of the value		if contents then begin			currValue:=theWidgets.(widget).(contents); // the actual view			bgValue:=theWidgets.widgets.(widget).(contents);  // the template			if classof(currValue)='string and classOf(bgValue)='string then begin				if not strEqual(bgValue,currValue) then begin					if not hasSlot(changes, widget) then changes.(widget):={};					changes.(widget).(contents):=currValue					end				end			else begin // not a string				if classOf(bgValue)='string or bgValue<>currValue then begin					if not hasSlot(changes, widget) then changes.(widget):={};					changes.(widget).(contents):=currValue;					end				end	//if classOf			end;	//if contents			// do styles slot (if there is one)			if (styles:=theWidgets.(widget).styles) then begin				if not hasSlot(changes, widget) then changes.(widget):={};				changes.(widget).styles:=styles;				end;			// do visible slot			if context='background // save visible property in widget proto				then background.widgets.(widget).visible:=theWidgets.(widget).visible				else begin					if not hasSlot(changes, widget) then changes.(widget):={};					changes.(widget).visible:=theWidgets.(widget).visible;					end;		end;    //foreach			if context='card 		then card.cdWidgets:=deepclone(changes)		else card.bgWidgets:=deepclone(changes);	if debug then print(changes);				end
       ,
     exPrint:
       func(compiled) begin	if debug then print(compiled);	for i:=0 to length(compiled.values)-1 do begin		_printLine:=_printLine & :getFormatArbObject(compiled.values[i]);		if compiled.delim[i]=$, 			then _printLine:=_printLine & substr(spaces,0,10-floor(fmod(strLen(_printLine),10)))		end;          	_printPending:=TRUE;	if endsWith(compiled.delim, CR) then :printLineFlush();	end
     ,
     openCard:
       func(key) begin	if debug then print("openCard:" & key);	local entry;		// find card. key can be ID or Name	if isInteger(key) then begin			if card and card.ID=key then return; // already at this card!		entry:=_work:gotokey(key);		if not entry or key<>entry.ID or entry.type<>'card then return nil		end		else if isString(key) then begin		if card and strEqual(card.name,key) then return; // already at this card!		entry:=_cardQuery:gotokey(key);				// skip 'stack or 'background recs with same key		while entry and entry.type<>'card and strEqual(entry.name, key)			do entry:=_cardQuery:next();					if not entry or not strEqual(key,entry.name) then return nil		end	else return nil;	:hideCardViews();	local oldHeaderID:=:headerSave();  // save script _RF			:closeEntry('card, card);	local oldBG:=nil;	if card then oldbg:=card.background;	card:=entry;	addArraySlot(_cardsVisited, card.ID);	if length(_cardsVisited)>32 then arrayRemoveCount(_cardsVisited,0,1);	//did background change?		if oldBg<>card.background then _RF:openBackground(stack.backgrounds.(card.background));		_bgcd.card:=_RF:openRF({_context: intern("Card_" & card.ID)});	_header:=card;	_subs:=card.subs;	_RF:loadSubs('card);			if debug then begin		setValue(stackName, 'text,			stack.name & CR &			background.ID && background.sub && background.name & CR &			card.ID && card.Name);		refreshviews();		end;			_RF:displayLayer('card);	:headerRestore(oldHeaderID); // if running a script, set _RF back	:doActions('show, card.arriveSound, 										card.arriveEffect, 										:makeScriptName('card,'arrive, nil));											return card.ID	end;
       ,
     packIt:
       func() begin	if not getroot().|packman:nsbasic|		then return (:error(kError37))		else getroot().|packman:nsbasic|:packman(			{soupName: systemEntry.programname,		   doInstall: TRUE,		   autoDelete: TRUE,		   //autoInstall: TRUE,		   });	end
       ,
     getLineNo:
       func(codePos)  //given codePos in current codeRec, return the lineNo	return _header.cumLines[_codeRecPos]-(_RF._ch.codeLen-codePos);
       ,
     formatLineNo:
       func(LineNo) subStr(numberStr(floor(LineNo+10000)),1,nil)// takes a numeric line number and returns line number as "0000"	
       ,
     kanjiPresent: nil,
     hideUserViews:
       func() begin	if not _bgcd.background then return;	:hideCardViews();	local baseView;	if newtCard		then baseView:=backgroundlayer		else baseView:=executor;	if debug then print("Hide User Views");	_hideUserViewsRunning:=TRUE;	// this is to get around an apparent bug that is a view such as a picker is looking for a tap	// and gets closed before it happens, bad things don't appear.	// this code also in appProto.viewHideScript	local userViews:=_bgcd.background._userViews;	for i:=0 to length(userViews)-1 do 		if userViews[i].viewCObject and NOT userViews[i].keepView			then userViews[i]:hide();  // clean out all card views from baseView.stepChildren	baseView.stepChildren:=[];	if not _mainRF._shuttingDown then baseView:redoChildren();		 	userViews:=[];	if newtCard then begin		backgroundLayer.shapeArray:=[];		backgroundLayer.styleFrame:={};		end;	if baseview then baseView:dirty();	_hideUserViewsRunning:=NIL;	end
       ,
     exShow:
       func(compiled) begin	if debug then begin write("exShow:");print(compiled);end;		local baseView:=currentLayer;	if NOT visible(baseView) then baseView:show();	foreach win in compiled do		if classof(win)='int 			then begin				if _userViews[win].visible then _userViews[win]:show();				end		else if classOf(win)='array then begin			foreach w in win do							if classof(w)='int 					then begin if _userViews[w].visible then _userViews[w]:show() end					else return (:error(kError23))			end		else if classOf(win)='frame then begin			win:show();			win.visible:=TRUE;			end;					else return (:error(kError23));			baseView:dirty();	refreshviews();end
     ,
     progressView: nil,
     formatArbObj:
       func (object,currDepth) begin  local whatPrimClass:=primClassOf(object);  local whatClass:=classOf(object);  local temp;  local i:=0;   if (currDepth>systemEntry.printDepth and 		(classof(object)='Frame or classof(object)='Array)) then begin			_temp:=_temp & "<" & classOf(object) & ":" & length(object) & ">";  	  return NIL  	  end;    if whatPrimClass='immediate or whatClass='symbol 		then _temp:=_temp & :formatArbObj1(object,currDepth);      	else if whatClass='string 		then if currDepth=0 then _temp:=_temp & object		else _temp:=_temp & quote & object & quote;  	else if whatClass='array then begin		_temp:=_temp & "[";		foreach slotName,elementVal in object do begin			i:=i+1;			if i>1 then _temp:=_temp & ",";			:formatArbObj(elementVal,currDepth+1)			end;		_temp:=_temp & "]";		end;        	else if whatClass='frame or whatPrimClass='Frame then begin		_temp:=_temp & "{";		foreach slotName,elementVal in object do begin			i:=i+1;			_temp:=_temp & (if i>1 then ",") & slotName & ":";			if slotName<>'_proto and slotName<>'_parent				then :formatArbObj(elementVal,currDepth+1);				else _temp:=_temp & "<" & classOf(object) & ":" & length(object) & ">";			end;		_temp:=_temp & "}";		end;	else begin		temp:=:formatArbObj1(object,currDepth);		if strEqual(temp,"") 			then _temp:=_temp & "<" & classof(object) & ">";			else _temp:=_temp & temp;		end;      end
     ,
     exChain:
       func(compiled) begin	if newtCard then return nil;  interpreter.newStmt:=quote & compiled[0] & quote;	if compiled[1] then interpreter.newStmt:=interpreter.newStmt & "," & compiled[1]	:printLineFlush();	_runFlag:=NIL;	:doAda(func() interpreter:doRun(), '[], 0);	end
     ,
     exSetIcon:
       func(progName, icon) begin	if debug then print("setIcon: " & progName);	if classOf(icon)<>'bitmap then return (:error(kError34));	local workSoup:=:getNonUnionSoup(progName & kExt);	if workSoup=nil then return (:error(kErrorM10));	local work:=worksoup:query({indexpath: 'ID});	local iconEntry:=work:gotokey(kMainsub);	iconEntry.icon:=icon;	entryFlushXmit(iconEntry, nil);	end
     ,
     dataLabelFind:
       func(lineNo) 	if lineNo and hasSlot(_header.dataLabels, lineNo)		then return _header.dataLabels.(lineNo);		else return (:error(kError12));
     ,
     exWDraw:
       func(args) begin	if debug then print(args);	local win;	if classOf(args[0])='int		then win:=U.userviews[args[0]]		else win:=args[0];			win.drawing:=args[1];	setValue(win, 'styleFrame, args[2]);	win:doDrawing('drawDrawing, NIL)		end
     ,
     exErase:
       func(args) begin	local stmtList:=[];	local currentLineNo:=0;		if _codePos>=0 then currentLineNo:=:getLineNo(_codePos);	if currentLineNo=-1 then currentLineNo:=0;		if debug then print("delete range:" & args[0] && args[1]);	local fromLineNo:=:labelFind(args[0]);	local toLineNo:=:labelFind(args[1]);		if NOT fromLineNo or NOT toLineNo then return (:error(kError12));	// collect line numbers in range	foreach label, lineNo in _header.labels do		if lineNo>=fromLineNo and lineNo<=toLineNo and beginsWith(sPrintObject(label),"L")			then addArraySlot(stmtList, substr(sPrintObject(label),1,nil));	if debug then print(stmtList);	for i:=0 to length(stmtList)-1 do interpreter:saveStmt(stmtList[i],"");		:chGetXLine(currentLineNo);			end
       ,
     getArgs:
       func(s) begin	// this function splits s in an array of arguments on commas	_delimiters:=CR;	if NOT s then return [];   if strEqual(trimString(s),"") then return [];   if charPos(s,$, ,0)=nil and charPos(s,$; ,0)=NIL then return [s];		   local c;   local numArgs:=level:=0;   local quotes:=nil;   local p:=[-1];   local args:=[];   _delimiters:="";      // create a list p of comma delimiters   for i:=0 to strLen(s)-1 do begin      c:=subStr(s,i,1);      if strExactCompare(c,quote)=0 then if quotes then quotes:=nil else quotes:=true;      if quotes=nil then begin         if strPos("[{(",c,0) then level:=level+1;         if strPos("]})",c,0) then level:=level-1      end;      if (strExactCompare(c,",")=0 or strExactCompare(c,";")=0)       	and quotes=nil and level=0 then begin      	addArraySlot(p,i);      	_delimiters:=_delimiters & c      	end         end;	if (endsWith(s,",") or endsWith(s,";"))=nil		then _delimiters:=_delimiters & CR;	   // if the brackets balance, then cut string up into args    if level=0 then begin      addArraySlot(p,strLen(s));      for i:=0 to strLen(_delimiters)-1 do          addArraySlot(args,trimString(subStr(s,p[i]+1,p[i+1]-(p[i]+1))))      end   else :error(kError11);	if debug then print (args);  args     	end
       ,
     exBye:
       func(exitValue) begin	if debug then print("exBye");	if chainProg then chainReturn:=deepclone(exitValue);	_runFlag:=_inputFlag:=_mainRF._runState:=NIL;	editor.ignoreUpdates:=TRUE; // turn off viewChanged 	:doAda(func() getroot().(appSymbol):close(), '[], 60);	end
       ,
     exGet:
       func(compiled) begin	If debug then print(compiled);		local chan:=_RF.(compiled.chan);  if NOT :checkChan(chan) then return;			_rf.FSTAT:=0;	if compiled.key then begin // lookup with key specified			if _openFiles[chan].key=nil // attempt to use a key without index				then return (:error(kErrorM3));			try _openFiles[chan].Entry:=_openFiles[chan].Query:gotoKey(compiled.key);			onexception |evt.ex| do       	:error([sPrintObject(currentException().name) &&               sPrintObject(currentException().error) & CR]);              			if NOT strEqual(sPrintObject(compiled.key), sPrintObject(_openFiles[chan].Entry.(_openFiles[chan].Key)))				then _rf.FSTAT:=2; // not found; next key returned			end		else // lookup with no key specified		 if _openFiles[chan].Flag=nil // and we haven't read a record yet			then _openFiles[chan].Entry:=_openFiles[chan].Query:entry()			else if _openFiles[chan].Entry						then _openFiles[chan].Entry:=_openFiles[chan].Query:next()						else return (:error(kErrorM6)); // attempt to read past EOF				_openFiles[chan].Flag:=true;		if _openFiles[chan].Entry=nil then begin //EOF			_rf.FSTAT:=1;			_RF.(intern(compiled.frame)):=NIL;			end		else _RF.(intern(compiled.frame)):=deepclone(_openFiles[chan].Entry)									end  
       ,
     doRun1withBreak:
       func() if _codePos<>-1 and _runState then begin	//must be called from _RF context	if debug then print("Executing statement (with break)" && :getStmtNo(_codePos) && :getLineNo(_codePos) && _codePos && _codeRecPos && _context);	if _trace then print(:getStmtNo(_codePos));	_RF._y:=_ch.code[_codePos];	try :_y()		onexception |evt.ex| do			:error({name: clone(currentException().name), 			   errorCode: clone(currentException().data.errorCode)});	if _runflag=0 then begin		if _codePos>=_ch.codeLen			then :chGetNextXLine()  // next statement			else _codePos:=_codePos+1;		end		else begin                // GOTO or GOSUB			if _runFlag=nil then return;			_lastLineNo:=:getLineNo(_codePos);			if :findLineNo(_runFlag)=_codeRecPos				then _codePos:=_ch.codeLen-(_header.cumLines[_codeRecPos]-_runFlag);				else :chGetXLine(_runFlag);			if _codePos=-1 then return :error(kError13);			_runFlag:=0			end;	:doAda(func() _RF:doRun1withBreak(), '[], 3);	end
       ,
     newBackground:
       func(specFrame) begin	if debug then print("newBackground");		if _bgcd.card then begin		:closeEntry('card, card);		:closeRF();		end;	if _bgcd.background then begin		:closeEntry('background, background);		:closeRF();		end;		local sub:=:getNewBGName();	if not hasSlot(specFrame, 'name) then specFrame.name:=sub;		_bgcd.background:=background:=interpreter:getNewHeadRec(sub);	stack.backgrounds.(intern(sub)):=background.ID;	entryFlushXmit(stack, nil);		// initialize values in background	:updateSlots(background,specFrame);	background.cardCount:=0;	background.firstCard:=nil;	background.lastCard:=nil;	background.drawRec:=nil;	background.widgetsRec:=nil;	entryFlushXmit(background,nil);	_bgcd.background:=:openRF({_context: background.sub});			_RF:hideUserViews();		//create first card in background	:newCard({});	if debug then print("new Background " & background.sub && background.ID);	if backgroundMode='card then :toggleBackgroundMode();	end
       ,
     exCreate:
       func(compiled) begin	if debug then print("exCreate");	if debug then print(compiled);	local querySpec,chan,query,soup,qspec;	foreach store in getStores() do		if store:getsoup(compiled.filename) then return (_rf.FSTAT:=1);	querySpec:=[{structure: 'slot, type: 'string, path: intern(compiled.keyName)}];	if RegisterCardSoup(compiled.filename, queryspec, AppSymbol, ["rec","recs"])=nil then begin		_rf.FSTAT:=1;		return :error(kErrorM14);		end;	qspec:={type: 'index, indexpath: queryspec[0].path};	if debug then print(qspec);			// now, open the file	soup:=getUnionSoup(compiled.filename);	if soup=nil then return (_rf.FSTAT:=1);	try query:=soup:query(qSpec);		onexception |evt.ex| do begin		  _rf.FSTAT:=2;			return :error(kErrorM2);			end;				addArraySlot(_openFiles, {soup: soup, query: query, flag: nil, entry: nil,														 key: querySpec[0].path});	_RF.(compiled.chan):=chan:=length(_openFiles)-1; 	if debug then print(_openFiles);	_rf.FSTAT:=0;end
       ,
     displayLayer:
       func(backgroundMode) begin	if debug then print("displayLayer:" & backgroundMode && _rf._context);	if _mainRF._shuttingDown then return;	local layer;		if backgroundMode='background or backgroundMode='backgroundDrawingsOnly then begin		currentLayer:=backgroundLayer;		target:='background;		end	else begin		currentLayer:=cardLayer;		target:='card		end;			// display draw layer from card or background	local drawings:=baseview.(target).drawings;	if drawings then begin		currentLayer.shapeArray:=drawings.shapes;		currentLayer.styleFrame:=drawings.styles;		end	else begin		currentLayer.shapeArray:=[];		currentLayer.styleFrame:={};		end;	if backgroundMode<>'backgroundDrawingsOnly and backgroundMode<>'cardDrawingsOnly		then :displayLayerWidgets(target);		currentLayer:dirty();	end
       ,
     ShowFoundItem:
       func(entry, finder) begin	getroot().finddrawer:close();	if debug then begin		print("showFoundItem");		end;		local _findParms:=baseview._rf._findParms;		if hasSlot(entry,'type) and entry.type='list and _findParms.var=NIL then begin		:doAda(func() editor:handleInputLine("edit" && entry.stmtNo), '[], 9);		end 	else if _findParms.var then _RF.(_findParms.var):=entry		else if newtCard and hasSlot(entry, 'type) and entry.type='card then begin		_RF:openCard(entry.ID);		end;		baseView._rf._findParms:=nil;	end
     ,
     exForPop:
       func() begin	ArrayRemoveCount(_forNextStack,length(_forNextStack)-1,1);	if length(_forNextStack)=0		then _forNextTop:=NIL		else _forNextTop:=_forNextStack[length(_forNextStack)-1]						end
     ,
     exStop:
       func() begin	:printLineFlush();	playSound(rom_simpleBeep);	local lineNo:=:formatLineNo(max(0,:getStmtNo(_codePos)));	interpreter:addLines(["Stop at " & lineNo & CR]);	:setRunStateOff();	end
     ,
     exHWInput:
       func(compiled) begin	if debug then print(compiled);	_inputFlag:=true;	_runFlag:=NIL;	_inputPtr:=0;	:printLineFlush();	HWInput.var:=compiled.var;	HWInput.varType:=compiled.varType;	if compiled.prompt then begin		setValue(HWInput, 'label, sPrintObject(compiled.prompt));		HWInput.indent:=12+strFontWidth(sPrintObject(compiled.prompt),{family: 'espy, face:1, size: 9})		end;	if compiled.popUpList 		then setValue(HWInput, 'labelCommands, compiled.popUpList);		else removeSlot(HWInput, 'labelCommands);   HWFloater:open();end
     ,
     _ignoreWidgetChanges:
       nil // set to true when changing widget values - stops userClickScript from triggering.
       ,
     clearCurrentException:
       func() 	if currentException() then		foreach slot,value in currentException() do			currentException().(slot):=nil;
     ,
     exEndSub:
       func() begin	if debug then print("endSub" && _RF._context);	if editor then begin // if the editor screen is showing, stay in subroutine		:setRunStateOff();		return		end;			_runFlag:=nil;		if _RF=_bgcd.script then begin // end of top level - time to knock off		:closeRF();		_bgcd.script:=nil;		:setRunStateOff();		if _RF=_bgcd.card then _header:=card		else if _RF=_bgcd.background then _header:=background		else if _RF=_mainRF then _header:=stack		else breakloop();		_subs:=_header.subs;		end	else begin // otherwise, bubble up and complete previous script		:closeRF();		if not systemEntry.enableBreak then begin			if _RF._codePos>=_RF._ch.codeLen				then _RF:chGetNextXLine()  // next statement				else _RF._codePos:=_RF._codePos+1			end;			if NOT systemEntry.enableBreak // restart calling routine			then _RF:doRun1()			else _RF:doAda(func() _RF:doRun1withBreak(), '[], 2); 		end;	end
       ,
     currentLayer:
       NIL// In NewtCard, reference to cardLayer or BackgroundLayer. Set by DisplayLayer.
       ,
     viewJustify: 0,
     hideCardViews:
       func() begin	if not _bgcd.card then return;	if debug then print("Hide Card Views: from " & _rf._context);	// card views are in _userView for the current runFrame and in cardLayer.stepChildren			_hideUserViewsRunning:=TRUE;	// this is to get around an apparent bug that is a view such as a picker is looking for a tap	// and gets closed before it happens, bad things don't appear.	// this code also in appProto.viewHideScript	local userViews:=_bgcd.card._userViews;	for i:=0 to length(userViews)-1 do 		if userViews[i].viewCObject and NOT userViews[i].keepView			then userViews[i]:hide();				    // clean out all card views from cardLayer.stepChildren	cardLayer.stepChildren:=[];	if not _mainRF._shuttingDown then cardLayer:redoChildren();		  // clean out all card views from _userViews	_bgcd.card._userViews:=[];		cardLayer.shapeArray:=[];	cardLayer.styleFrame:={};	if cardLayer then cardLayer:dirty();	_hideUserViewsRunning:=NIL;	end
       ,
     doRun1:
       func () while _codePos<>-1 do begin	//must be called from _RF context	if debug then print("Executing statement" && :getStmtNo(_codePos) && :getLineNo(_codePos) && _codePos && _codeRecPos && _context);	_RF._y:=_ch.code[_codePos];	try _RF:_y()		onexception |evt.ex| do 			:error({name: clone(currentException().name), 			   errorCode: clone(currentException().data.errorCode)});		if _runflag=0 then begin			if _codePos>=_ch.codeLen				then :chGetNextXLine()  // next statement				else _codePos:=_codePos+1			end			else begin              // GOTO or GOSUB				if _runFlag=nil then break;				_lastLineNo:=:getLineNo(_codePos);				if :findLineNo(_runFlag)=_codeRecPos					then _codePos:=_ch.codeLen-(_header.cumLines[_codeRecPos]-_runFlag);					else :chGetXLine(_runFlag);				if _codePos=-1 then return :error(kError13);				_runFlag:=0				end	end // while
       ,
     exRead:
       func(compiled) begin	if debug then print(compiled);	local dataVal;	if _dataPos=nil then return (:error(kError15));	local header:=_header;	for i:=0 to length(compiled.vars)-1 do begin 		// if NOT kRunTime then begin HELP 		if NOT nil then begin       if _dataPos>=length(_data.args) then begin      	_dataRecPos:=_dataRecPos+1;      	if _dataRecPos>=length(header.dataRecs) then return (:error(kError15));				_data:=:getEntry(header.dataRecs[_dataRecPos]);				_dataPos:=0				end;			dataVal:=_data.args[_dataPos];      end		else begin // running from package (HELP?)			if _dataPos>=length(_data.data[dataCounter]) then begin				_dataPos:=0;      	_dataRecPos:=_dataRecPos+1;      	if _dataRecPos>=length(header.dataRecs) then return (:error(kError15));				end;			dataVal:=_data.data[_dataRecPos][_dataPos];			end;					if compiled.varTypes[i]='string			then _RF.(compiled.vars[i]):=sPrintObject(dataVal)			else _RF.(compiled.vars[i]):=deepclone(dataVal);		_dataPos:=_dataPos+1		 		end  // for iend
       ,
     chDispose:
       func() begin	if _runState then return;	if _ch and _ch.lines=-1 then return;	if kChunkTrace then if _ch then print("C: disposeOldChunk:" & _ch.LineNo);	if _ch and frameDirty(_ch) and isSoupEntry(_ch) then begin		if kChunkTrace then print("C:   ch flushed");		entryFlushXmit(_ch,nil);		end;	if frameDirty(_header) then begin		if kChunkTrace then print("C:   header flushed");		entryFlushXmit(_header,nil);		end		end
     ,
     ioConnect:
       func(service, options) begin //user function	io:open();	io:ioConnect(service, options);	end
       ,
     exInputArgKanji:
       func(s) begin	local kanji:="";	local second:=NIL;	local byte, firstByte;	local toU:=GetRoot().|JTables:ENFOUR|.toU;	getroot().(appSymbol).temp1:=s;						for i:=0 to length(s)-1 do begin		byte:=ExtractByte(s,i);		if second then begin 			StuffByte(firstByte,1,byte);			kanji:=kanji & ConvertToUniJ(firstByte,1,toU);  			second:=nil;			end;		else 			if (((byte>128) and (byte<159)) or ((byte>223) and (byte<240))) then begin				second:=TRUE;				firstByte:=Stringer(array(0,nil));				StuffByte(firstByte,0,byte);				end;			else begin				firstbyte:=clone("");				stuffbyte(firstbyte,0,byte);				kanji:=kanji & ConvertToUniJ(firstByte,1,toU);				end;		end; // for i	getroot().(appSymbol).temp2:=kanji;						return kanji;end
       ,
     setRunStateOff:
       func() begin	// must be run from _RF context	local header:=_header;	if _codePos and _codePos<>-1 and header and hasSlot(header, 'cumlines) and length(header.cumLines)>0		then _lastLineNo:=:getLineNo(_codePos)		else _lastLineNo:=NIL;	if debug then print("SetRunStateOff at " & _lastLineNo);	if kProfileOn then enableProfiling(NIL);	if editor and editor.basicAlpha=nil then return; // this can only happen if NSB is closed by another app	:printLineFlush();	_runFlag:=nil;	if _runState then interpreter:addLines(["* "]);	if strEqual(systemEntry.io,"scre") and editor		then :doada(func() if editor and hasSlot(editor, 'text) 													then setKeyView(editor, strLen(editor.text)), '[], 0);	_inputFlag:=_mainRF._runState:=nil;	if header and header.codeRecs then _ch:=:getEntry(header.codeRecs[_codeRecPos:=0]);	if editor and editor.BasicAlphaInUse and NOT chainProg then editor.basicAlpha:open();	printFormat:='list;		if progressView then begin		progressView:close();		progressView:=nil;		end		end	//else :exBye(NIL);
       ,
     deleteCardEntry:
       func(mode) begin	if debug then print("DeleteCardEntry " && card.ID && mode);	//if mode='normal, then just the card is being deleted	//if mode='bg, then all the cards in the bg are being deleted and there's	//                  no need to update the background record.			entryRemoveFromSoupXmit(card,nil);		:deleteAllSubs(card); //delete any scripts			:deleteCardFixPointers(stack, 'prevCardStack, 'nextCardStack);		// only if background isn't being deleted	if mode='normal then		:deleteCardFixPointers(background, 'prevCardBG, 'nextCardBG);end
       ,
     findLineNo:
       func(lineNo) 	// This function figures out what code block a lineNo is in	bSearchLeft(_header.cumLines, lineNo,'|<|,nil)
       ,
     exElse:
       func() begin	if debug then print("exElse:" && _thenLevel);	if _thenLevel=0 then return (:error(kError88));	:chGetStatement([kEndIf]);	if _codePos=-1 then interpreter:addLines(kError87);		end
     ,
     exDoPop:
       func() begin	if debug then print("exDoPop");	if debug then print(_doStack);	if _doStackTop then begin		ArrayRemoveCount(_doStack,length(_doStack)-1,1);		if length(_doStack)=0			then _doStackTop:=NIL			else _doStackTop:=_doStack[length(_doStack)-1]		end;	end
     ,
     closeEntry:
       func(type, entry)	begin	if debug then print("closeEntry:" & type);	if entry and entry.ID then begin								entryFlushXmit(entry,nil);		:doActions('hide, entry.leaveSound, 											entry.leaveEffect, 											:makeScriptName(type, 'leave, nil));		end;			if type='card and card and card.id then begin		:saveWidgetValues('card);		:saveWidgetValues('background);		entryFlushXmit(entry, nil);		:hideCardViews();		end	else if type='background then _RF:hideUserViews();		if entry and entry.ID then :closeRF();	if type<>'stack then _bgcd.(type):=NIL;	baseview.(type):=nil;	end
     ,
     checkChan:
       func(chan) begin	if debug then print("getChan");	if debug then print(chan);	if classof(chan)<>'int                   then return (:error(kErrorM13));	if  chan>length(_openFiles)-1 or chan<0 then return (:error(kErrorM13));	if _openFiles[chan]=nil                 then return (:error(kErrorM13));	if _openFiles[chan].soup=nil            then return (:error(kErrorM13));	TRUE	end
     ,
     Find:
       func(what, results, scope, statusView) begin	if debug then begin		print("find:");		print(what);		print(results);		print(scope);		end;			local _runstate:=baseView._mainRF._runState;	local _findParms:=baseView._rf._findParms;	local _openfiles:=baseView._rf._openFiles;	if NOT _findParms then _findParms:={findStr: what, var: nil, fileName: NIL};	if NOT _findParms.fileName then begin		if not _runState 			then _findParms.filename:=systemEntry.programName			else if length(_openFiles)>0				then _findParms.filename:=_openFiles[0].soup:getName();				else _findParms.filename:=systemEntry.programName;		end;			if debug then print("searching in " & _findParms.filename);	  	self.title:=_findParms.filename;	:standardFind(what, _findParms.filename, results, statusView, nil);	if debug then print("find return");	if length(results)=0 then :doAda(func() getroot().findDrawer:close(), '[], 10);	baseView._rf._findParms:=_findParms;end
     ,
     pasteID:
       func(paste, pasteID) begin	// get a frame out of pointers, save it, and return the record number	local entry:=paste.pointers.(intern("ID_" & pasteID));	entry.ID:=interpreter:getID();	_workSoup:addXmit(entry,nil);	entry.ID	end
       ,
     deleteASub:
       func(subName) begin	if debug then print("deleteAsub:" & subname);	local entry:=:getEntryWithScript(subname);	local headerID:=entry.subs.(subName);		if headerID and headerID>0 then begin		local header:=:getEntry(headerID);		if header and header.sub=subName then begin // could be nil - but only if stack corrupted!			entryRemoveFromSoupXmit(header,nil);						// delete code recs			foreach ID in header.codeRecs do 				entryRemoveFromSoupXmit(:getEntry(ID),nil);							// delete data recs			foreach ID in header.dataRecs do 				entryRemoveFromSoupXmit(:getEntry(ID),nil);							// delete list recs			foreach ID in header.listRecs do 				entryRemoveFromSoupXmit(:getEntry(ID),nil);						end				end	else nil; // (HELP!) deal with inline subs somehow	removeSlot(entry.subs, subname);			end
       ,
     exFind:
       func(compiled) begin	if debug then print(compiled);	getroot().findDrawer:open();	//getroot().findDrawer:hide();				:doAda(func() getroot():findIt(compiled.findstr, 'findFrontMost, 'text, nil),'[],10);	if compiled.var then _rf.(compiled.var):=nil;	_rf._findParms:=compiled;	end
       ,
     chGetStatement:
       func(statement) begin	//must be called from _RF context	if kChunkTrace then print("C: Looking for:");	if kChunkTrace then print(statement);	local level:=0;	if _codePos=-1 then return NIL;	local kw:=_ch.keywords[_codePos];		while NOT lsearch(statement, kw,0,'|<|,nil) OR Level>0 do begin		if kw=kLoop OR kw=kEndIf or kw=kNext or kw=kEndSub then level:=level-1;		:chGetNextXLine();		if kChunkTrace then print("C: checking in " & _codePos);		if _codePos=-1 then return NIL;		kw:=_ch.keywords[_codePos];		if kw=kDo OR kw=kIfBlock OR kw=kFor OR kw=kSub then level:=level+1;		if kChunkTrace then print(_codePos && level);		end;	if kChunkTrace then print("C: found:" & _codePos);	end
       ,
     exSub:
       func(funcFrame) begin	local target;	if debug then write("exSub" && _context & " ");	if debug then print(funcFrame);	:openRF(funcFrame);	if not _bgcd.script then _bgcd.script:=_RF; //only top script is pointed to	if card then target:=card.subs.(funcFrame._context);	if not target and background then target:=background.subs.(funcFrame._context);	if not target and stack then target:=stack.subs.(funcFrame._context);	if target=NIL then return;		if target<0		then _RF:chGetXLine(-1*target+1) // subroutine is in current module		else begin                       // sub starts as first line of different module			_header:=:getEntry(target);			_subs:=_header.subs;			_sub:=_header.sub;			_RF:chGetXLine(1);			:initDataPtr();			end;	if _RF._codePos=-1 then begin // no lines of code - don't bother starting		:closeRF();		if _bgcd.card=_rf then _bgcd.script:=nil; // no script still executing		end	else begin		_RF._runFlag:=0;		if NOT systemEntry.enableBreak // actually execute the subroutine			then _RF:doRun1()			else _RF:doAda(func() _RF:doRun1withBreak(), '[], 4);		end		end	
       ,
     doImmediate:
       func(stmt) begin	if debug then print("doImmediate:" & stmt);	interpreter.stmtFrame:={lineNo: nil,               display: stmt,               internal: "",               keyword: nil,               compiled: {},               err: nil};	interpreter:interpret();	if interpreter.stmtFrame.err then return;	if debug then print(interpreter.stmtFrame);	if interpreter.stmtFrame=nil then interpreter.stmtFrame:={err: nil, keyword: ""};	_RF._y:=interpreter.stmtFrame.compiled;	try _RF:_y()		onexception |evt.ex| do			:error({name: clone(currentException().name), 			   errorCode: if currentException().error			    						then currentException().error			    						else clone(currentException().data.errorCode)});				end
     ,
     chGetXLine:
       func (lineNo) begin //get a lineNo: return _codePos	//must be called from _RF context	if kChunkTrace then print ("C: getXLine: " & lineNo);	if NOT lineNo then return;	local header:=_header;	local newID:=:findLineNo(lineNo);	if newID=length(header.cumlines) then return (_codePos:=-1);		if kChunkTrace then if not _ch or newID<>_ch.ID then print("C: reading new codeRec:" & newID);	if not _ch or header.codeRecs[newID]<>_ch.ID then begin //need to load new codeRec		if kChunkTrace then print("C: reading new chunk:" & header.codeRecs[newID]);		_RF._ch:=:getEntry(header.codeRecs[_codeRecPos:=newID]);		end;			_codePos:=_ch.codeLen-(header.cumLines[_codeRecPos]-lineNo);		if kChunkTrace then print("C: " & newID && _codePos);	_codePos	end
       ,
     exDel:
       func(compiled) begin	local chan:=_RF.(intern(compiled.chan));   if NOT :checkChan(chan) then return;			_rf.FSTAT:=1;	//check if the record exists	local key:=compiled.frame.(_openFiles[chan].key);	local oldEntry:=_openFiles[chan].Query:gotoKey(key);	if oldEntry and 		strEqual(sPrintObject(key), sPrintObject(oldEntry.(_openFiles[chan].Key)))		then begin		  if debug then print("Found it!");		  entryRemoveFromSoupXmit(oldEntry,nil);		  _openFiles[chan].entry:=oldEntry:=NIL;		  _rf.FSTAT:=0		  end;end
       ,
     initdataPtr:
       func() begin	_RF._dataPos:=0;   	//if NOT runTime then begin HELP!		if length(_header.dataRecs)=0			then _RF._dataPos:=nil			else _RF._data:=:getEntry(_header.dataRecs[_RF._dataRecPos:=0]);	//	end  //else _RF._dataRecPos:=0;	end
       ,
     exReturn:
       func() begin	local top:=length(_gosubStack)-1;	if debug then display ("RETURN");	if debug then print (_gosubstack);	if top>=0 then begin		local newLineNo:=_gosubStack[top];		ArrayRemoveCount(_gosubStack,top,1); 		if newLineNo>=0 then:chGetXLine(newLineNo) 									   else _runFlag:=-1*newLineNo; // set *-1 if waitIndefinite, so it continues to wait		end	else :error(kError19);end
       ,
     FormatLineNo1:
       func(stmtNo) begin// stmtNo is a string// returns line number as "0000" or nil if invalid line no	local x:=stringToNumber(stmtNo);	if x=nil or x<0 or x>9999 then return (:error(kError5));	return subStr(numberStr(floor(x+10000)),1,nil)	end
       ,
     gBeeps: kBeeps,
     printFrame:
       func(frame) begin	if frame=NIL then return ["NIL" & CR];	local lines:=[];  	local mySlot;	foreach slot,value in frame do begin		mySlot:=sPrintObject(slot);		if NOT beginsWith(mySlot,"_") then begin			if endsWith(mySlot,"_") then mySlot[strLen(mySlot)-1]:=$$;			_temp:=""; 		 	:formatArbObj(value,0);      	   			addArraySlot(lines,mySlot & ":" & _temp & CR);      end;	end;	_temp:=nil; 	return lines;	end
     ,
     _delimiters: nil,
     exRestore:
       func(lineNo) begin	if debug then print("exRestore:" & lineNo);	if not lineNo then return (:error(kError12));		_dataRecPos:=lsearch(_header.dataRecs,lineNo,0,'|=|,nil);	_data:=:getEntry(lineNo);	_dataPos:=0;	end
     ,
     formatArbObj1:
       func (obj,currDepth) begin  if obj=NIL then return "NIL";  if obj=TRUE then return "TRUE";  return sPrintObject(obj);	end
     ,
     deleteBackground:
       func() begin	if debug then print("deleteBackground:" & background.sub);	if length(stack.backgrounds)=1 then return nil; // can't delete only bg		if background.cardCount>1 and		not modalConfirm("Delete this background and its" && background.cardcount && "cards?",				'okCancel) then return;		:closeEntry('card, card);		// delete all the cards for the bg	local nextCard; 	nextCard:=background.firstCard;	while nextCard do begin		card:=:getEntry(nextCard);		:deleteCardEntry('bg);				nextCard:=card.nextCardBG;		end; // while nextCard	card:=nil;								// update the stack	local bg:=background;	:closeEntry('background, background);	removeSlot(stack.backgrounds, bg.sub);	entryFlushXmit(stack,nil);		// remove the background and get another one.	:deleteAllSubs(bg);	entryRemoveFromSoupXmit(bg,nil);	:openCard(stack.firstCard);		end
       ,
     viewSetupFormScript:
       // be sure to call inherited:?ViewSetupFormScript()func() begin	if newtCard		then currentLayer:=backgroundLayer		else currentLayer:=executor;	_bgcd:={background: nil, card: nil, script: nil};	self.viewBounds:=baseView.viewbounds;	inherited:?ViewSetupFormScript();	end
       ,
     renameASub:
       func(oldSubName, newSubName) begin	if debug then print("renameAsub:" & oldSubName && newSubName);	local entry:=:getEntryWithScript(oldSubName);	local headerID:=entry.subs.(oldSubName);		//fix the code of the sub statement	if headerID and headerID>0 then begin		local subEntry:=:getEntry(headerID);		if subEntry and subEntry.sub=oldSubName then begin 			// update SUB statement with new subroutine name			_header:=subEntry;			interpreter:saveStmt("0010","sub " & newSubName & "()");							end;									//now, fix up the sub slots on the card record		entry.subs.(newSubName):=entry.subs.(oldSubName);		removeSlot(entry.subs,oldSubName);		entryFlushXmit(entry,nil);				//...and on the sub record		subEntry.sub:=newSubName;		entryFlushXmit(subEntry,nil);				//...and on the coderecs, datarecs and listrecs		foreach ID in subEntry.codeRecs do begin			entry:=:getEntry(ID);			entry.sub:=newSubName;			entryFlushXmit(entry,nil);			end;		foreach ID in subEntry.dataRecs do begin			entry:=:getEntry(ID);			entry.sub:=newSubName;			entryFlushXmit(entry,nil);			end;		foreach ID in subEntry.listRecs do begin			entry:=:getEntry(ID);			entry.sub:=newSubName;			entryFlushXmit(entry,nil);			end;		end;		end
       ,
     dumpStack:
       func(stackname) begin	if strEqual(stackname, "") then stackname:=systemEntry.programname;	local workSoup:=getunionsoup(:makeProgramName(stackname));	local work:=workSoup:query({indexpath: 'ID});	local entry:=work:entry();	local result:=CR;	while entry do begin		result:=result & entry.ID && entry.type;				if entry.type='head or entry.type='bg then begin			result:=result && :getFormatArbObject({				subs: entry.subs,				cardCount: entry.cardCount,				firstCard: entry.firstcard,				lastCard: entry.lastcard,				name: entry.name				});			end;				else if entry.type='card then begin			result:=result && :getFormatArbObject({				subs: entry.subs,				widgets: if entry.widgets then length(entry.widgets),				background: entry.background,				pointers: [entry.prevCardStack, entry.nextCardStack,entry.prevCardBG,entry.nextCardBG],				name: entry.name,				});			end;		else if entry.type='sub then begin			result:=result && entry.sub && :getFormatArbObject({				subs: entry.subs,				dataRecs: entry.dataRecs,				listRecs: entry.listRecs,				codeRecs: entry.codeRecs				});			end;		else if entry.type='list then begin			result:=result && entry.sub && entry.stmtNo && entry.text;			end;					else if entry.type='code then begin			result:=result && entry.sub && entry.codeLen			end;			result:=result & chr(13);		entry:=work:next();		end;		result	end;
     ,
     exGo:
       func(compiled) begin	if debug then print(compiled);	local ID, tempCard, action;	action:=compiled.action;			if action='back then begin		if length(_cardsVisited)<2 then return nil;		setLength(_cardsVisited,length(_cardsVisited)-1);		ID:=_cardsVisited[length(_cardsVisited)-1];		:openCard(ID);		setLength(_cardsVisited,length(_cardsVisited)-1);		end			else if action='title then begin		:openCard(stack.name);		end				else if action='first then begin		:openCard(stack.firstCard)		end					else if action='prev then begin		if card.prevCardStack 			then :openCard(card.prevCardStack)			else :openCard(stack.lastCard)		end			else if action='next then begin		if card.nextCardStack 			then :openCard(card.nextCardStack)			else :openCard(stack.firstCard)		end				else if action='last then begin		:openCard(stack.lastCard)		end			else if action='card then begin		:openCard(compiled.var)		end	else if action='stack then begin		:openStack(compiled.var)		end			else if action='app then begin		if getroot().(intern(compiled.var)) then begin			baseview:close();			getroot().(intern(compiled.var)):open();			end		else return (:error(kErrorM9));		end;end
     ,
     exWindow:
       func(compiled) begin	if debug then write("exWindow:");	if debug then print(compiled);	local windowSpec:=_RF.(compiled.specName);	local windowList:=_RF.(compiled.win);		// determine the format of the windowSpec and create each window	if classOf(windowSpec)='frame then		if (foreach slot,value in windowSpec do // only need to look at 1 element to tell						if classOf(value)='frame and hasSlot(value, 'widgetType)							then break NIL							else break TRUE)						then begin //frame with single widget in it			if debug then print("exWindow: single frame");			_RF.(compiled.specName):=:exWindow1(windowSpec, compiled.widget);			_RF.(compiled.win):=length(_userViews)-1;			end					else begin // frame of frames			if debug then print("exWindow: frame of frames");			_RF.(compiled.win):=array(length(windowSpec),0);			foreach i,widget in :frameToOrderedArray(windowSpec) do begin				_RF.(compiled.specName).(widget.widgetName):=:exWindow1(widget, compiled.widget);				_RF.(compiled.win)[i]:=length(_userViews)-1;				end			end			else if classOf(windowSpec)='Array then begin // old style array of frames			if debug then print("exWindow: array of frames");			_RF.(compiled.win):=array(length(windowSpec),0);			for i:=0 to length(windowSpec)-1 do begin				_RF.(compiled.specName)[i]:=:exWindow1(windowSpec[i], compiled.widget);				_RF.(compiled.win)[i]:=length(_userViews)-1;				end;			if not _runstate then return; // will be set to nil if an error occured			end				else return (:error(kError23));	end
       ,
     progress:
       func(title1, title2, value) begin //user function	if NOT progressView and value then begin		progressView:=buildContext(progressLink._proto);		progressView:open();		end;			if value then progressView:updateValue(title1, title2, value);		if progressView and not value then begin		progressView:close();		progressView:=nil;		end;	end
       ,
     exIFblock:
       func(cond) begin	if debug then if cond then print("IFblock:" & TRUE);	if debug then if cond=NIL then print("IFblock:" & NIL);	_thenLevel:=_thenLevel+1;	if NOT cond then begin		:chGetStatement([kElse, kEndIf]);		if _codePos=-1 then interpreter:addLines(kError87);		endend 
     ,
     pasteCard:
       func() begin	// take frame created by copyCard and put it into stack	entryFlushXmit(card,nil);	entryFlushXmit(background,nil);	local clipBoardDataFrame:=getClipBoard();	if debug then begin print("pasteCard");print(clipBoardDataFrame) end;	if not clipBoardDataFrame or clipBoardDataFrame.types[0][0]<>'newtcard then return nil;	if not strEqual(clipBoardDataFrame.label,"Card") then return; 	local pasteCard:=clipBoardDataFrame.data[0][0];		//background	:pasteFromFrame('background, pasteCard.background);	pasteCard.card.background:=background.sub;	:pasteFromFrame('card, pasteCard.card);	setClipboard(nil);		_header:=background;	_subs:=background.subs;	_rf:=_bgcd.background;	_RF:loadSubs('background);		_header:=card;	_subs:=card.subs;	_rf:=_bgcd.card;	_RF:loadSubs('card);	:displayLayer('background);		if backgroundMode='background then :toggleBackgroundMode(); // will display card layer	end
       ,
     newStack:
       func(specFrame) begin	if not hasSlot(specFrame, 'name) then specFrame.name:="Untitled";	local longProgramName:=:makeProgramName(specFrame.name);	if debug then print("NewStack " & longProgramName);	if :getNonUnionSoup(longProgramName) then		if not modalConfirm("Stack " & specFrame.name & " already exists. Overwrite?", 'okCanceldefaultCancel)			then return;			 	:hideUserViews();	if stack then :closeStack();		if :getNonUnionSoup(longProgramName) then begin // wipe out old soup with same name		_work:=_workSoup:=_mainRF._cardQuery:=		stack:=background:=card:=_header:=nil;		foreach store in getStores() do begin			local soup:=store:getSoup(longProgramName);			if soup then soup:RemoveFromStoreXmit(nil);			end;		soup:=nil		end;   // if getSoup...    		_workSoup:=:getNonUnionSoup(longProgramName);	if _workSoup=nil then interpreter:getNewSoup(specFrame.name);	_work:=_workSoup:query({indexpath: 'ID});	_mainRF._cardQuery:=_workSoup:query({indexpath: 'name});	_sub:='main;	_header:=:getEntry(kMainSub);	_subs:=_header.subs;	systemEntry.programName:=longProgramName;	systemEntry.useScratch:=nil;	stack:=_header;	:updateSlots(stack,specFrame);	stack.backgrounds:={};	stack.cardCount:=0;	stack.firstCard:=nil;	stack.lastCard:=nil;	stack.markedCards:=[];	stack.drawRec:=nil;	stack.widgetsRec:=nil;	entryFlushXmit(stack, nil);	_mainRF._cardsVisited:=[];	//create first background in stack	:newBackground({});	if backgroundmode='background then :toggleBackgroundMode()	end		
       ,
     answer: func(question, options) modalConfirm(question, options),
     LoadASub:
       func(sub, lineNo) begin	if sub='main then return;	if sub<>_sub and lineNo then begin		if debug then print("Loading subroutine..." & sub && lineNo);		if lineNo>=0 then begin // it's a sub: put lineNo 0 of sub into call table			_header:=:getEntry(lineNo);			lineNo:=0;			end		else begin			lineNo:=-1*lineNo;			// put us back to 			if _header.sub<>'main then _header:=:getEntry(_subs.(_sub))			end;				// now, execute the function line to load the function into _RF		local codePos:=_RF:chGetXLine(lineNo);		_RF._y:=_RF._ch.code[codePos];		try _RF:_y()			onexception |evt.ex| do			:error({name: clone(currentException().name), 			   errorCode: clone(currentException().data.errorCode)});		end;		_codePos:=-1	end
       ,
     doActions:
       func(mode,sound,effect,script) begin	if _openStackInProgress then return;	if debug then begin		write("doActions:" & mode & ":"); write(sound); write(effect); print(script);		end;	//sound		if sound and hasVariable(getglobals().soundregistry, sound)		then playsound(getglobals().soundregistry.(sound));		//effect	if mode='show then begin		if visible(wrapper) then wrapper:hide();		wrapper.viewEffect:=effect;		wrapper:show();		wrapper:moveBehind(executor);		end	else begin		wrapper.viewEffect:=effect;		if effect then wrapper:hide()		end;	//script	if script and hasVariable(_rf, script) then begin		_mainRF._runState:=TRUE; // start execution		_mainRF._y:=getVariable(_rf, script);		_mainRF:_y(); // I thought this didn't work, but it seems OK now?		//:doAda(func() _mainrf:_y(), '[], 2);	// this didn't work - it runs the same script 3 times			end;	end
       ,
     exFor:
       func(compiled) begin	compiled.lineNo:=:getLineNo(_codePos+1);	if debug then print(compiled);			if NOT compiled.stepOK then return :error(kError59); // Zero Step	// initialize and check if loop will have an iterations	if NOT compiled.incrOK then begin	// completion condition met before FOR/NEXT starts		:chGetStatement([kNext]);		if debug then print(_codePos);		return NIL;		end;	// Everything is OK, start it up!	removeSlot(compiled, 'init);	removeSlot(compiled, 'stepOK);	removeSlot(compiled, 'incrOK);	removeSlot(compiled, 'start);	addArraySlot(_forNextStack,compiled);	_forNextTop:=_forNextStack[length(_forNextStack)-1];	end
       ,
     _bgcd:
       nil //will contain a frame with 'card and 'background slots, referring to their _RF's.
       ,
     pasteWidget:
       func() begin	// take frame created by copyWidget and put it onto current background or card	local widget, scriptname, subentry, entry, newsub, pasteWidget, clipBoardDataFrame;	entryFlushXmit(card,nil);	entryFlushXmit(background,nil);	entry:=baseview.(backgroundMode);	clipBoardDataFrame:=getClipBoard();	if debug then begin print("pasteWidget");print(clipBoardDataFrame) end;	if not clipBoardDataFrame or clipBoardDataFrame.types[0][0]<>'newtcard then return nil;	if not strEqual(clipBoardDataFrame.label,"BUTTON") 		 and not strEqual(clipBoardDataFrame.label,"FIELD") then return;	pasteWidget:=clipBoardDataFrame.data[0][0];		// put widgetSpec onto card or header	if not entry.widgets then entry.widgets:={};	widget:=intern(clipBoardDataFrame.label & "_" & length(entry.widgets));	entry.widgets.(widget):=pasteWidget.spec;			// If there's a script, set it up under the old name	if pasteWidget.sub then begin		scriptName:=pasteWidget.pointers.(intern("ID_" & pasteWidget.sub)).sub;		entry.subs.(scriptName):=:pasteID(pasteWidget, pasteWidget.sub); // use old name for now- rename later		subEntry:=:getEntry(entry.subs.(scriptName));				// copy records to their new locations		foreach i,j in clone(subEntry.listRecs) do subEntry.listRecs[i]:=:pasteID(pasteWidget,j);		foreach i,j in clone(subEntry.dataRecs) do subEntry.dataRecs[i]:=:pasteID(pasteWidget,j);		foreach i,j in clone(subEntry.codeRecs) do subEntry.codeRecs[i]:=:pasteID(pasteWidget,j);		entryFlushXmit(subEntry,nil);				// update SUB statement with new subroutine name		if backgroundMode='background			then newSub:=intern(background.sub & "_w" & widget);			else newSub:=intern("CD_" & card.id & "_w" & widget);		:renameASub(scriptName, newSub);		_RF:loadSubs(backgroundMode);		end;		:displayLayer(backgroundMode);	setClipboard(nil);	end
       ,
     copyID:
       func(pointers, ID)		pointers.(intern("ID_" & ID)):=deepClone(:getEntry(ID));
     ,
     chgetNextXLine:
       func () begin	// this routine increments _codePos to the next statement	// if there is no next line (end of program), return NIL else TRUE	// must be called from _RF context	if kChunkTrace then print("C: GetNextXLine..." & _codePos && "in" && _codeRecPos && _context);	if (_codePos:=_codePos+1)<=_ch.codeLen then return TRUE; // are we lucky?		if kChunkTrace then print("C: End of block - get next");	local header:=_header;		if (_codeRecPos:=_codeRecPos+1)>length(header.codeRecs)-1 then begin		if kChunkTrace then print("C:   End of Program");		_codePos:=-1;		if newtCard then :exEndSub() else :setRunStateOff();		return NIL		end;			_ch:=:getEntry(header.codeRecs[_codeRecPos]);	_codePos:=0;	if kChunkTrace then print("C:   return: " & _ch.ID);	return TRUE;		end
       ,
     viewClass: 74 /* clView */,
     basicAlphaInUse: true,
     getformatArbObject:
       func(s) begin	_temp:=clone("");	:formatArbObj(s,0);	local l:=clone(_temp);	_temp:=NIL;	return l;	end
     ,
     printLineFlush:
       func() begin	local returnValue:=_printLine;	if not _printPending then return;	if NOT visible(baseView) then baseView:show();	interpreter:addlines([_printLine & CR]);	_printLine:="";	_printPending:=NIL;	returnValue	end
     ,
     exEnviron:
       func(compiled) begin	if debug then print("exEnviron");	local io:=compiled.oldio;	local lStore:=compiled.oldstore;   	if NOT classOf(systemEntry.io)='string then begin   	systemEntry.io:=io;   	:error(kError1);   	return   	end;   	 // delete this code Dec 31/96	     if strEqual(systemEntry.io, "Screen") then systemEntry.io:="scre"	else if strEqual(systemEntry.io, "s0") then systemEntry.io:="extr";	else if strEqual(systemEntry.io, "IR") then systemEntry.io:="infr";		if NOT strEqual(io,systemEntry.io) then begin // change io mode   	if debug then print("changing IO mode from " & io & " to " & systemEntry.io); 		if connect then connect:updateText(systemEntry.io);		end;	if lStore<>systemEntry.store then :setStore();   	 	end
       ,
     exMakePackage:
       func(progName) begin	if NOT getroot().|makePkg:NSB| exists then return (clone(:error(kError35)));	if not modalConfirm("MAKEPACKAGE will make a package out of your program. Do it now?", 'okCancel) then return;	if progName=NIL then begin		if strEqual(systemEntry.programName, ksoupName) then return (clone(:error(kError32)));    interpreter:copySoupEntries(kSoupName,systemEntry.programName);		progName:=systemEntry.programName;		end;	if NOT endsWith(progName, kExt) then progName:=progName & kExt;	if debug then print("makePackage: " & progName);	if not :getNonUnionSoup(progName & kExt) then return (:error(kErrorM10));	getroot().(kMakePkgSym):open();	refreshViews();	end
     ,
     deleteAllSubs:
       func(entry)	foreach subName, recNo in entry.subs do :deleteASub(subName)
     ,
     exDelete:
       func(fileName) begin	local deleted,filename,soup;	if fileName=nil then return :error(kErrorM10);	if endsWith(filename,kExt) then filename:=filename;	if strEqual(filename,kSoupName) then return (:error(kError2));	deleted:=NIL;		foreach store in getStores() do begin   	soup:=store:getSoup(filename);   	if soup then begin   		if debug then print("removing " & filename);   		soup:RemoveFromStoreXmit(nil);   		deleted:=TRUE;   		end;   	end;	UnregisterCardSoup(filename);	if NOT deleted then :error(kErrorM10);end
     ,
     exDo:
       func(cond)	if cond then begin		if debug then print("exDo TRUE: _doStackTop:" & _doStackTop);		// if this isn't the current loop, add a new loop		local lineNo:=:getLineNo(_codePos);		if _doStackTop=NIL OR			(_doStackTop and _doStackTop<>lineNo) then begin				if debug then print(_doStack);				addArraySlot(_doStack,lineNo);				_doStackTop:=lineNo;				end;		end;	else begin // end the loop		if debug then print("exDO NIL: _doStackTop:" & _doStackTop);		:exDoPop();			:chGetStatement([kLoop]);	end
       ,
     getEntry:
       func(ID) begin	//get ID. If record not found, force an error.	local entry:=_work:gotokey(ID);	if entry and ID=entry.ID then return entry;		if debug then print("key not found." && ID && (if entry then entry.ID else "") );	if debug then breakloop();	:error(["Internal Error: key not found" & CR]);	return NIL	end
       ,
     newCard:
       func(specFrame) begin	if debug then print("newCard");	if hasSlot(specFrame, 'name) and specFrame.name then begin		if strEqual(specFrame.name, "") or not specFrame.name			then removeSlot(specFrame, 'name);			else begin				local tempCard:=_cardQuery:gotoKey(specFrame.name);						// skip 'stack or 'background recs with same key				while tempCard and tempCard.type<>'card and strEqual(tempCard.name, specFrame.name)					do tempCard:=_cardQuery:next();						if tempCard and strEqual(tempCard.name,specFrame.name) then begin					:notify(kNotifyAlert, systemEntry.programName, "Card " & specFrame.name & " already exists.");					return nil;					end;			end	end;	if card then begin		:saveWidgetValues('card);		:saveWidgetValues('background);		entryFlushXmit(card, nil);		end;			local oldHeaderID:=:headerSave();  // save script _RF	card:=interpreter:getNewCardRec();		// initialize values on card	local oldlastcardbg,oldlastcardStack,tempCard;	:updateSlots(card,specFrame);	card.background:=background.sub;	card.nextCardbg:=nil;	card.nextCardStack:=nil;	oldlastcardbg:=card.prevCardbg:=background.lastCard;	oldlastcardStack:=card.prevCardStack:=stack.lastCard;		entryFlushXmit(card,nil);		// update pointers on prev card in bg	if oldlastcardbg then begin		tempCard:=:getEntry(oldlastcardbg);		tempCard.nextCardBG:=card.ID;		end;					// update pointers on prev card in stack	if oldlastcardbg<>oldlastcardStack then begin // both same card - save time!		if oldlastcardbg    then entryFlushXmit(tempCard,nil);			if oldlastcardStack then tempCard:=:getEntry(oldlastcardStack);		end;	if oldlastcardStack then begin		tempCard.nextCardStack:=card.ID;		entryFlushXmit(tempCard,nil);		end;			// update values on background	background.cardCount:=background.cardCount+1;	background.lastCard:=card.ID;	if NOT background.firstCard then background.firstCard:=card.ID;	entryFlushXmit(background, nil);		// update values on stack	stack.cardCount:=stack.cardCount+1;	stack.lastCard:=card.ID;	if NOT stack.firstCard then stack.firstCard:=card.ID;	entryFlushXmit(stack, nil);	if debug then print("New Card is " & card.ID);	addArraySlot(_cardsVisited, card.ID);		if debug then begin		setValue(stackName, 'text,			stack.Name & CR &			background.ID && background.sub && background.name & CR &			card.ID && card.Name);		refreshviews();		end;	if _rf._parent._context<>'main then begin		:hideCardViews(); // hide previous card		_bgcd.card:=:closeRF();  //new bg has no prev card		end;			_bgcd.card:=:openRF({_context: intern("Card_" & card.ID)});	_header:=card;	_subs:=_header.subs;	if backgroundMode='background then :toggleBackgroundMode();		// clear values on bg widgets	_ignoreWidgetChanges:=true;	local backgroundWidgets:=_bgcd.background._widgets;	if backgroundWidgets then foreach widget, value in backgroundWidgets do begin		local contents:=backgroundWidgets.(widget).contents; // get the name of the value		if contents then setvalue(backgroundWidgets.(widget), contents, 			clone(background.widgets.(widget).(contents)));		end;	_ignoreWidgetChanges:=nil;		:headerRestore(oldHeaderID); // if running a script, set _RF back	end
       ,
     exEnd:
       func() begin		if debug then print("exEnd" & CR);		_sub:='main;		_RF:setRunStateOff();		end
     ,
     elements:
       func(frameName) begin// return an array containing the sorted list of elements - user functionlocal elementNames:=array(length(frameName),nil);local i:=0;foreach element,value in frameName do begin	elementnames[i]:=sPrintObject(element);	i:=i+1	end;	if debug then print(elementnames);return sort(elementNames,'|str<|,nil);end
       ,
     loadSubs:
       func(context) begin	// context is 'stack, 'background or 'card. If NIL, then current context.	if debug then print("loadSubs:" & context);	// load subs into _RF	local codePos, response, script, entry, sublist;	local oldHeader:=_header;	local oldRF:=_rf;	if context then begin		subList:=baseview.(context).subs;		if context='stack			then _rf:=_mainRF			else _rf:=_bgcd.(context);		end	else subList:=clone(_header.subs);		_loading:=true;	foreach sub, lineNo in subList do		try :loadASub(sub, lineNo) onException |evt.ex| do begin			response:=modalconfirm(				"Bad Script: " & sub & CR & "Please send details to support@nsbasic.com.",				["OK","Clear it"]);			if response=1 then :deleteASub(sub);							end;	_rf:=oldRF;			_header:=oldHeader;	_subs:=_header.subs;	_loading:=nil;	end
       ,
     exPut:
       func(compiled) begin	local oldEntry, rewrite, chan, key;	chan:=_RF.(compiled.chan);  if NOT :checkChan(chan) then return;		if _openFiles[chan].key=nil then begin		_rf.FSTAT:=1;		return (:error(kErrorM12));		end;			_rf.FSTAT:=0;	//check if the record exists	key:=compiled.frame.(_openFiles[chan].key);			try oldEntry:=_openFiles[chan].Query:gotoKey(key);		onexception |evt.ex| do begin			_rf.FSTAT:=1;      return (:error(kErrorM4)); // "key not a string"      end;	rewrite:=nil;	if oldEntry and strEqual(sPrintObject(key), sPrintObject(oldEntry.(_openFiles[chan].Key))) then begin		rewrite:=true;		if debug then print ("REWRITE")		end;			if debug then print (oldEntry);			// either replace it or add a new one	if rewrite		then entryReplace(oldentry, compiled.frame)		else _openFiles[chan].soup:addToDefaultStore(compiled.frame);	end 
       ,
     headerSave:
       func() begin	// if running a script, need to change card while keeping script	// This sets the _rf to the new card while it's housekeeping is done.	// headerRestore sets the _RF and _header back	if _bgcd.script and _bgcd.card then begin 		_rf:=_bgcd.card;   // set our _RF to the card temporarily so the closeRF works properly		return _header.ID;		end	else return nil;		end
       ,
     copyCard:
       func() begin	//make a copy of the current card	local cardCopy:={card: :copyIntoFrame(card), 									 background: :copyIntoFrame(background)};	local clipBoardDataFrame:={label: "Card",															types: [['newtcard]],															data:  [[cardcopy]],															bounds: {} };	setClipBoard(ensureInternal(clipBoardDataFrame));														end
       ,
     exInputArg:
       func() begin	local compiled:=_inputCompiled;	if debug then print (compiled);	local argList;	input:=_inputStack[0];	arrayRemoveCount(_inputStack,0,1);	if length(compiled.vars)=1		then argList:=[input]		else begin				argList:=:getargs(input);				if _inputPtr+length(argList)>length(compiled.vars) then begin					_inputError:=_runFlag:=TRUE;					return :error(kError46);					end			  end;	foreach arg in argList do begin		if debug then print("inputArg:" & arg);      		if _inputPtr>length(compiled.vars) then begin			_inputError:=_runFlag:=TRUE;			return (:error(kError46))      end; //if		//if compiled.varTypes[_inputPtr]='string then *** may not be needed? ***		if endsWith(arg, CR) then arg:=subStr(arg,0,strLen(arg)-1);		if beginsWith(arg, LF) then arg:=subStr(arg,1,nil);		if classOf(arg)='binary and kanjiPresent			then arg:=:exInputArgKanji(arg);		if compiled.varTypes[_inputPtr]='string			then _RF.(compiled.vars[_inputPtr]):=sPrintObject(arg)			else _RF.(compiled.vars[_inputPtr]):=:isANumber(arg);		_inputPtr:=_inputPtr+1;		// input is complete		if debug then print("input item " & _inputPtr && length(compiled.vars));		if _inputPtr=length(compiled.vars) then begin			if debug then print ("input complete");			_inputFlag:=nil;			_inputCompiled:=NIL;			if visible(editor.BasicAlpha) then editor.BasicAlpha:hide();						end // if _inputPtr      	   end // foreachend
       ,
     deleteStack:
       func() begin	if stack.cardCount>1 and		not modalConfirm("Delete this stack and its " & stack.cardcount & " cards?",				'okCancel) then return;	:closeStack();	foreach store in getStores() do begin   	soup:=store:getSoup(systemEntry.programname);   	if soup then begin   		if debug then print("removing " & systemEntry.programname);   		soup:RemoveFromStoreXmit(nil);   		end;   	end;	UnregisterCardSoup(systemEntry.programname);	if :getNonUnionSoup(:makeProgramName("Home"))		then _rf:openStack("Home")				else if :getNonUnionSoup(:makeProgramName("Untitled"))			then _rf:openStack("Untitled")			else _rf:newStack({name: "Untitled"});		end
     ,
     openBackground:
       func(ID) begin	if background and background.ID=ID then return;	if debug then print("openBackground:" & ID);		:closeEntry('background, background);	background:=:getEntry(ID);		_bgcd.background:=:openRF({_context: background.sub});	_header:=background;	_subs:=background.subs;	:loadSubs('background);	:doActions('show, background.arriveSound, 										background.arriveEffect, 										:makeScriptName('background,'arrive, nil));	:displayLayer('background);	end
     ,
     ioDisconnect:
       func(ep) io:ioDisconnect(ep); //user function
       
    };

HWfloater :=
    {viewBounds: {left: 1, top: 229, right: 220, bottom: 294},
     declareSelf: 'base,
     viewFlags: 580,
     viewQuitScript:
       func() begin	if debug then print("HW: viewQuitScript" & HWInput.entryline.text);	_RF:exHWInputArg(sPrintObject(HWInput.entryline.text));end
     ,
     viewSetupFormScript:
       func() if hasSlot(HWInput,'labelcommands) then		if classof(HWInput.LabelCommands)<>'array then			removeSlot(HWInput,'labelCommands);
     ,
     viewJustify: 144,
     _proto: @180 /* protoFloatNGo */
    };
AddStepForm(executor, HWfloater);
StepDeclare(executor, HWfloater, 'HWfloater);

HWinput :=
    {viewBounds: {left: 2, top: 9, right: 228, bottom: 33},
     label: "Input:",
     viewFlags: 517,
     viewFont: userFont12,
     text: "",
     _proto: @189 /* protoLabelInputLine */
    };
AddStepForm(HWfloater, HWinput);
StepDeclare(executor, HWinput, 'HWinput);





app := {_proto: App};
AddStepForm(executor, app);
StepDeclare(executor, app, 'app);



PT_userview := {_proto: view};
AddStepForm(executor, PT_userview);
StepDeclare(executor, PT_userview, 'PT_userview);



scroller := {_proto: scrollerProto};
AddStepForm(executor, scroller);
StepDeclare(executor, scroller, 'scroller);


progressLink := LinkedSubview(progressFloater,
    {viewBounds: {left: 23, top: 111, right: 183, bottom: 151}});
AddStepForm(executor, progressLink);
StepDeclare(executor, progressLink, 'progressLink);

// After Script for executor
thisView := executor;
thisView.kMaxStepChildren:=length(thisView.StepChildren);


constant |layout_ExecutorUnit| := executor;
// End of file ExecutorUnit
// Beginning of text file ExecutorUnit.f
definition := EnsureInternal(Clone(kExecutorUnitFrame));definition.executorUnit := getlayout("executorUnit");DefineUnit(EnsureInternal('|executorUnit:NSB|), definition);InstallScript := func(partFrame, removeFrame) nil;RemoveScript := func(removeFrame) nil;
£F¤
// End of text file ExecutorUnit.f
// Beginning of text file Visual Designer Data
constant kProcrastinate:=1000;defconst ('kFillPattern, setLength(SetClass(clone("\u0000000000000001"),'pattern),8));defconst ('kLinePattern, setLength(SetClass(clone("\u0000000100000001"),'pattern),8));defConst('kProperties, ["text","title","viewBounds","viewEffect",	"viewFlags","viewFont","viewFormat","viewJustify","viewValue",	"widgetName","widgetType"]);	defconst('kViewFlags,  ['vvisible,'vapplication,'vcalculatebounds,												'vclipping,'vfloating,'vreadonly,'vclickable,'vnoflags,									
£Gø£GÀ			'vnothingallowed,'vanythingallowed, 'vstrokesallowed,												'vgesturesallowed,'vshapesallowed,'vsingleunit,'vcharsallowed,												'vlettersallowed, 'vnamefield, 'vpunctuationallowed, 'vcapsrequired,												'vnumbersallowed, 'vphonefield, 'vdatefield, 'vtimefield, 												'vnospaces]);defconst('kValues, {	bounds:  		{format: 'bounds},	boxTitle:		{format: 'string},	checkCurrentItem: {format: 'boolean},	currLabelCommand: {format: 'int},	dateFont:		{format: 'font},	editOK:
£Gø£GÀ			{format: 'boolean},	entryFlags:	{format: 'flags, values: kViewFlags},	gaugeDrawLimits: {format: 'boolean},	GOTO:				{format: 'eval},	GOSUB:			{format: 'eval},	hours:			{format: 'int},	indent:			{format: 'int},	label:			{format: 'string},	labelFont:	{format: 'font},	listItems:  {format: 'eval},	minutes:		{format: 'int},	minValue:		{format: 'int},	maxValue:		{format: 'int},	selectedDate: {format: 'eval},	showLeadingZeros: {format: 'boolean},	text: 			{format: 'string},	title: 			{for
£Gø£GÀmat: 'string},	useMultipleSelections: {format: 'boolean},	useScrollers: {format: 'boolean},	value:			{format: 'int},	viewBounds: {format: 'bounds}, 	viewEffect: {format:  'effect, values: ['fxCheckerBoardEffect, 'fxBarnDoorOpenEffect,								  			'fxBarnDoorCloseEffect, 'fxVenetionBlindsEffect, 'fxIrisOpenEffect,								  			'fxIrisCloseEffect, 'fxPopDownEffect, 'fxDrawerEffect, 								  			'fxZoomOpenEffect, 'fxZoomCloseEffect, 'fxZoomVerticalEffect]},	viewFlags:	{format: 'flags, values: k
£Gø£GÀViewFlags},	viewFont:		{format: 'font},	viewFormat:	{format: 'format,												fillValues: ['vfnone,'vffillwhite,'vffillltgray,'vffillgray,												'vffilldkgray,'vffillblack,'vffillcustom],												frameValues: ['vfnone,'vfframewhite,'vfframeltgray,												'vfframegray,'vfframedkgray,'vfframeblack,'vfframematte],												lineValues: ['vfnone,'vfLinesWhite,'vfLinesLtGray,'vfLinesGray,												'vfLinesDkGray,'vfLinesBlack]},	viewIdleFrequency: {format: 'int},	viewLineSpacin
£Gø£GÀg: {format: 'int},	viewJustify:{format: 'justify, 												horizontalValues: ['VjLeftH,'vjRightH,'vjCenterH,'vjFullH],												verticalValues: ['vjTopV,'vjCenterV,'vjBottomV,'vjFullV],												textLimitValues:['noLineLimits,'oneLineOnly, 'oneWordOnly],												unusedValues:['vjVMask,'vjParentLeftH,												'vjParentCenterH,'vjParentRightH,'vjParentFullH,'vjParentHMask,												'vjParentTopV,'vjParentCenterV,'vjParentBottomV,'vjParentFullV,												'vjParentVMask,'vjParent
£Gø£GÀMask,'vjSiblingNoH,'vjSiblingCenterH,												'vjSiblingRightH,'vjSiblingFullH,'vjSiblingLeftH,'vjSiblingHMask,												'vjSiblingNoV,'vjSiblingCenterV,'vjSiblingBottomV,'vjSiblingFullV,												'vjSiblingTopV,'vjSiblingVMask,'vjSiblingMask,'vjChildrenLasso,												'vjReflow]},	viewValue:	{format: 'eval},	widgetName: {format: 'string},	widgetType: {format: 'widgetType}	});								  			defconst('kfaceValues, ['kfaceNormal,'kfaceBold,'kfaceItalic,'kfaceUnderline,												'kfa
£Gø£GÀceOutline,'kfaceSuperscript,'kfaceSubscript]);defconst('ksizeValues, ["9","10","12","14","18"]);constant vfPen:= 256;constant vfRound:= 16777216;constant vfInset:= 65536;constant vfShadow:= 262144;				defconst('vConstants,{	// viewFormat constants  vffillwhite: vffillwhite,	vffillltgray: vffillltgray,	vffillgray: vffillgray,	vffilldkgray: vffilldkgray,	vffillblack: vffillblack,	vffillCustom: vfCustom,	vfframewhite: vfframewhite,	vfframeltgray: vfframeltgray,	vfframegray: vfframegray
£Gø£GÀ,	vfframedkgray: vfframedkgray,	vfframeblack: vfframeblack,	vfframematte: vfframematte,	vfnone: vfnone,	vfwhite: vfwhite,	vfltgray: vfltgray,	vfgray: vfgray,	vfdkgray: vfdkgray,	vfblack: vfblack,	vfcustom: vfcustom,	vfmatte: vfmatte,	vfLinesWhite: vfLinesWhite,	vfLinesLtGray: vfLinesLtGray,	vfLinesGray: vfLinesGray,	vfLinesDkGray: vfLinesDkGray,	vfLinesBlack: vfLinesBlack,	vfPen: vfPen,	vfRound: vfRound,	vfInset: vfInset,	vfShadow: vfShadow,	// viewJustify constants	vjLeftH: Vj
£Gø£GÀLeftH,	vjRightH: vjRightH,	vjCenterH: vjCenterH,	vjFullH: vjFullH,	vjHMask: vjHMask,	vjTopV: vjTopV,	vjCenterV: vjCenterV,	vjBottomV: vjBottomV,	vjFullV: vjFullV,	vjVMask: vjVMask,	vjParentLeftH: vjParentLeftH,	vjParentCenterH: vjParentCenterH,	vjParentRightH: vjParentRightH,	vjParentFullH: vjParentFullH,	vjParentHMask: vjParentHMask,	vjParentTopV: vjParentTopV,	vjParentCenterV: vjParentCenterV,	vjParentBottomV: vjParentBottomV,	vjParentFullV: vjParentFullV,	vjParentVMask: vjParent
£Gø£GÀVMask,	vjParentMask: vjParentMask,	vjSiblingNoH: vjSiblingNoH,	vjSiblingCenterH: vjSiblingCenterH,	vjSiblingRightH: vjSiblingRightH,	vjSiblingFullH: vjSiblingFullH,	vjSiblingLeftH: vjSiblingLeftH,	vjSiblingHMask: vjSiblingHMask,	vjSiblingNoV: vjSiblingNoV,	vjSiblingCenterV: vjSiblingCenterV,	vjSiblingBottomV: vjSiblingBottomV,	vjSiblingFullV: vjSiblingFullV,	vjSiblingTopV: vjSiblingTopV,	vjSiblingVMask: vjSiblingVMask,	vjSiblingMask: vjSiblingMask,	vjChildrenLasso: vjChildrenLasso,	vj
£Gø£GÀReflow: vjReflow,	noLineLimits: noLineLimits,	oneLineOnly: oneLineOnly,	oneWordOnly: oneWordOnly,		// viewFlag Constants	vvisible: vvisible,	vapplication: vapplication,	vcalculatebounds: vcalculatebounds,	vclipping: vclipping,	vfloating: vfloating,	vreadonly: vreadonly,	vclickable: vclickable,	vnoflags: vnoflags,	vnothingallowed: vnothingallowed,	vanythingallowed: vanythingallowed,	vstrokesallowed: vstrokesallowed,	vgesturesallowed: vgesturesallowed,	vshapesallowed: vshapesallowed,
£Gø£GÀ	vsingleunit: vsingleunit,	vcharsallowed: vcharsallowed,	vlettersallowed: vlettersallowed,	vnamefield: vnamefield,	vpunctuationallowed: vpunctuationallowed,	vcapsrequired: vcapsrequired,	vnumbersallowed: vnumbersallowed,	vphonefield: vphonefield,	vdatefield: vdatefield,	vtimefield: vtimefield,	vnospaces: vnospaces,		// viewEffect constants	fxCheckerBoardEffect: fxCheckerBoardEffect, 	fxBarnDoorOpenEffect: fxBarnDoorOpenEffect,								  				fxBarnDoorCloseEffect: fxBarnDoorCloseEffect,
£Gø£GÀ	fxVenetianBlindsEffect: fxVenetianBlindsEffect, 	fxIrisOpenEffect: fxIrisOpenEffect,	fxIrisCloseEffect: fxIrisCloseEffect, 	fxPopDownEffect: fxPopDownEffect, 	fxDrawerEffect: fxDrawerEffect, 	fxZoomOpenEffect: fxZoomOpenEffect, 		fxZoomCloseEffect: fxZoomCloseEffect, 	fxZoomVerticalEffect: fxZoomVerticalEffect,		// viewFont constants	kfaceNormal: kfaceNormal,	kfaceBold: kfaceBold,	kfaceItalic: kfaceItalic,	kfaceUnderline: kfaceUnderline,	kfaceOutLine: kfaceOutline,	kfaceSuperscript: k
£Gø£GÀfaceSuperScript,	kfaceSubscript: kfaceSubscript	});
risOpenEffect: fxIrisOpenEffect,	fxIrisCloseEffect: fxIrisCloseEffect, 	fxPopDownEffect: fxPopDownEffect, 	fxDrawerEffect: fxDrawerEffect, 	fxZoomOpenEffect: fxZoomOpenEffect, 		fxZoomCloseEffect: fxZoomCloseEffect, 	fxZoomVerticalEffect: fxZoomVerticalEffect,		// viewFont constants	kfaceNormal: kfaceNormal,	kfaceBold: kfaceBold,	kfaceItalic: kfaceItalic,	kfaceUnderline: kfaceUnderline,	kfaceOutLine: kfaceOutline,	kfaceSuperscript: k
// End of text file Visual Designer Data
// Beginning of file widgetSlip

// Before Script for widgetSlipBase
//print(OpenResFile(home & "resource.rsrc"));if kAppSymbol='|visualDesignerUnit:NSB|	then print(OpenResFile(home & "resource.rsrc"))	else print(OpenResFile(home & "Unit- VisualDesigner:Resource.rsrc"));DefConst('iconPickerBitmap, getPictAsBits("iconPicker", nil));CloseResFile();


widgetSlipBase :=
    {viewBounds: {left: 0, top: 32, right: 216, bottom: 200},
     Display:
       func(x, y, cbf) begin	type:=x;	mode:=y;	self.callBackFunc:=cbf;	if visible(widgetSlipLink) then widgetSlipLink:close();	widgetSlipLink:open();		end
     ,
     type: 'Stack,
     mode: nil,
     callBackFunc: nil,
     _defaultButton: ,
     viewSetupFormScript:
       func()begin	if HasSlot(widget, 'icon) then local height:=166 else height:=130;	if not HasSlot(self, 'viewBounds) then begin		local theBottom := GetAppParams().AppAreaHeight - 8;		self.viewBounds := RelBounds(0, theBottom-height, viewBounds.right, height);		end;	else if (viewBounds.top:=viewBounds.bottom - height) < 8 then begin		viewBounds.top:=8;		viewBounds.Bottom:=8+height;	endend
     ,
     widget: {},
     editWidget:
       func()begin	if Visible(self) then :Close();	if NOT visible(dragger) then dragger:open();	if NOT visible(stretcher) then stretcher:open();		self.widget := widgetArray[selectedWidget];	type := widget.type;	mode := 'new;	:Open();end
     ,
     viewQuitScript:
       func() begin	if debug then print("widgetSlip close");	widgetName:close(); // close this one first	if length(widget)=0 then arrayRemoveCount(widgetArray, selectedWidget, 1);	if Visible(actionSlipLink) then actionSlipLink:Close();	if visible(flags) then flags:close();	dragger:close();	stretcher:close();	inherited:?viewQuitScript();	end
       ,
     viewSetupChildrenScript:
       func()begin	if not HasSlot(widget, 'icon) then begin		IconPicker.viewFlags := BAnd(IconPicker.viewFlags, BNot(vVisible));		IconDisplay.viewFlags := BAnd(IconDisplay.viewFlags, BNot(vVisible));	end;	else begin		if HasSlot(IconPicker, 'viewFlags) then begin			RemoveSlot(IconPicker, 'viewFlags);			RemoveSlot(IconDisplay, 'viewFlags);		end;	end;end
     ,
     makeInt:
       func(text) begin	local x:=stringToNumber(text);	if NOT x then return 0					 else return floor(x);end
     ,
     showWidget:
       func() begin	if stopUpdates then return;	if debug then print("showWidget");			if selectedWidget<=length(widgetViews)-1 and widgetViews[selectedWidget] then begin		// widget already showing: just update it		if debug then print("Close widget " & selectedWidget);		if widgetViews[selectedWidget].viewCObject then widgetViews[selectedWidget]:close();				// transfer values to widgetView from widget		foreach slot,value in widget do			if classof(value)<>'codeblock and slot<>'_proto and slot<>'viewClass 			and classof(value)<>'_function then 				widgetViews[selectedWidget].(slot):=clone(value);				if debug then print("Open widget " & selectedWidget);		try widgetViews[selectedWidget]:open();		onexception |evt.ex| do nil;			end	else :showNewWidget(widget);	if length(widgetViews)>0 and widgetViews[selectedWidget].viewCObject 		then widgetViews[selectedWidget]:dirty();	baseView:dirty();	end		
       ,
     showWidgetProcrastinated:
       func(visualDesigner) begin	if debug then print("showWidgetProcrastinated requested");	local base:=visualDesigner;	local widgetSlip:=visualDesigner.widgetSlipLink;	if widgetSlip.property.lastaction='bounds		then widgetSlip.widgetProperties.bounds:getBounds();	widgetSlip:showWidget();	if  strEqual(widgetSlip.widget.widgetType, "labelInput") then	 				base.widgetViews[base.selectedWidget]:setLabelText(base.widgetViews[base.selectedWidget].label);	end;
     ,
     showWidgetProcrastinatedCancel:
       func() begin	if debug then print("showWidgetProcrastinatedCancel");	addProcrastinatedCall(kShellSymbol, func() nil, [], 0);	// cancel outstanding call	end
       ,
     Closeable:
       func() begin	if :FindNameConflict(widgetName.entryLine.text) then begin		local message:="Each widget must have a unique name.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));		nil;		end else true;end
     ,
     _proto: @179 /* protoFloater */
    };

Title :=
    {viewBounds: {left: 0, top: -8, right: 224, bottom: 8},
     viewSetupFormScript:
       func() begin	self.title := "Edit" && widgetLib.(intern(widget.widgetType)).item;	inherited:?viewSetupFormScript();		// this method is defined internallyend
       ,
     _proto: @229 /* protoTitle */
    };
AddStepForm(widgetSlipBase, Title);
StepDeclare(widgetSlipBase, Title, 'Title);



widgetAction :=
    {viewJustify: 8388774,
     deleteScript:
       func(target, targetView) begin	if selectedWidget=NIL then return;	if debug then print("Delete");	stretcher:close();	dragger:close();	widgetSlipLink:close();	:removeSelectedWidget();	end
     ,
     duplicateScript:
       func(target, targetView) begin	if not selectedWidget then return;	if debug then print("Duplicate");	stretcher:close();	dragger:close();	:duplicateWidget();/*	widget:=widgetArray[selectedWidget];	widgetTitle:close();	widgetTitle.title:=widgetArray[selectedWidget].widgetName;	widgetTitle:open();*/	:showNewWidget(widgetArray[selectedWidget]);	widgetSlipLink:EditWidget();end
     ,
     GetTargetInfo:
       func(targetType) begin	if debug then print("get Target Info");	{		target: {class: 'widget, data: selectedWidget,},		targetView: widgetSlipLink,	}end
     ,
     moveBackScript:
       func(target, targetView) begin	if NOT selectedWidget then return;	if selectedWidget=0 then return;	if debug then print("Move Back");	dragger:close();	stretcher:close();			local w:=widgetArray[selectedWidget];	w.order:=w.order-1;	widgetArray[selectedWidget-1].order:=widgetArray[selectedWidget-1].order+1;	removeSlot(widgetArray, selectedWidget);	arrayInsert(widgetArray, w, selectedWidget-1);	selectedWidget:=selectedWidget-1;		:showAllWidgets();	dragger:open();	stretcher:open();	end
     ,
     routeScripts:
       [// {title: "Move Backward", routeScript: 'moveBackScript, icon: kMoveBack}, {title: "Duplicate", routeScript: 'duplicateScript, icon: ROM_routeDuplicateIcon}, {title: "Delete", routeScript: 'deleteScript, icon: ROM_routeDeleteIcon},]
       ,
     viewBounds: {left: -42, top: -18, right: -25, bottom: -5},
     GetRouteScripts:
       func(info) begin	if debug then begin Print("WidgetSlip GetRouteScripts"); Print(info); end;	if ClassOf(info.target) = 'widget then routeScripts;	end
     ,
     _proto: @209 /* protoActionButton */
    };
AddStepForm(widgetSlipBase, widgetAction);



widgetSlipBase_v163_0 :=
    {
     buttonClickScript:
       func() begin	if :Closeable() 		then inherited:?buttonClickScript();		else :Hilite(nil);	end
     ,
     _proto: @163 /* protoLargeClosebox */
    };
AddStepForm(widgetSlipBase, widgetSlipBase_v163_0);



Actions :=
    {buttonClickScript: func()	:EditWidgetActions(selectedWidget),
     text: "Actions",
     viewBounds: {left: 5, top: -18, right: 49, bottom: -5},
     viewJustify: 8388742,
     viewSetupFormScript:
       // be sure to call inherited:?ViewSetupFormScript()func()begin	self._nextKeyView := baseView;	inherited:?ViewSetupFormScript();end
       ,
     _nextKeyView: nil,
     _proto: @226 /* protoTextButton */
    };
AddStepForm(widgetSlipBase, Actions);



Arrange :=
    {text: "Arrange",
     viewBounds: {left: 55, top: -18, right: 107, bottom: -5},
     viewJustify: 8388742,
     viewSetupFormScript:
       // be sure to call inherited:?ViewSetupFormScript()func()begin	self._nextKeyView := baseView;	inherited:?ViewSetupFormScript();end
       ,
     _nextKeyView: nil,
     popup:
       [	"Move Forward",	"Move to Front",	"Move Backward",	"Move to Back",]
     ,
     viewFlags: 515,
     pickActionScript:
       func(cmd)begin	inherited:?PickActionScript(cmd);	if cmd = 0 then widget.order:=Max(widget.order-1, 0) else	if cmd = 1 then widget.order:=0 else	if cmd = 2 then widget.order:=Min(widget.order+1, Length(widgetArray)-1) else	if cmd = 3 then widget.order:=Length(widgetArray)-1;	:showWidget();end
     ,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(widgetSlipBase, Arrange);
StepDeclare(widgetSlipBase, Arrange, 'Arrange);



WidgetName :=
    {viewBounds: {left: -8, top: 22, right: 224, bottom: 46},
     text: "",
     alwaysCallPickActionScript: nil,
     label: "Name",
     viewSetupFormScript:
       func() begin	self.text := widget.widgetName;	oldName:=clone(widget.widgetName);	inherited:?viewSetupFormScript();		// this method is defined internally	end
       ,
     viewSetupDoneScript:
       func() begin	AddDelayedSend(entryLine, 'SetHilite, [0, 9999, nil,], 0);	inherited:?viewSetupDoneScript();		// this method is defined internallyend
       ,
     oldName: nil,
     viewQuitScript:
       // must return the value of inherited:?ViewQuitScript()func() begin	if not strEqual(oldname, text) then		executor:renameASub(			executor:makeScriptName('widget, backgroundMode, oldName),			executor:makeScriptName('widget, backgroundMode, text));	inherited:?ViewQuitScript();end
       ,
     _proto: @189 /* protoLabelInputLine */
    };
AddStepForm(widgetSlipBase, WidgetName);
StepDeclare(widgetSlipBase, WidgetName, 'WidgetName);



IconPicker :=
    {
     labelCommands:
       [	{bits: iconPickerBitMap.bits,	bounds: iconPickerBitMap.bounds,	width: 6,	height: 16}]
     ,
     text: "Icon",
     viewBounds: {left: 0, top: 1, right: 0, bottom: 34},
     alwaysCallPickActionScript: true,
     viewJustify: 8396848,
     indent: 66,
     pickActionScript:
       func(tap)begin	local bitmap := MakeBitmap(32, 32, nil);	setvalue(IconDisplay, 'viewBounds, OffsetRect(iconPickerBitMap.bounds, indent, 0));	IconDisplay.icon:=iconPickerBitMap;	local left:=tap.x*33+1;	local top:=tap.y*33+1;	IconDisplay:viewIntoBitMap(RelBounds(left, top, 32, 32), nil, bitmap);	SetValue(IconDisplay, 'viewBounds, RelBounds(indent, 0, 32, 32));	SetValue(IconDisplay, 'icon, bitmap);	inherited:?pickActionScript(tap.index);end
     ,
     viewSetupFormScript:
       func()begin	self.indent := WidgetName.indent - 8;	inherited:?viewSetupFormScript();	IconDisplay.viewBounds := RelBounds(indent, 0, 32, 32);	if widget.icon then		IconDisplay.icon := widget.icon;end
     ,
     pickCancelledScript:
       func()begin	SetValue(IconDisplay, 'icon, nil);	inherited:?pickCancelledScript();end
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(widgetSlipBase, IconPicker);
StepDeclare(widgetSlipBase, IconPicker, 'IconPicker);



IconDisplay :=
    {icon: nil,
     viewFlags: 1,
     viewBounds: {left: 66, top: 0, right: 98, bottom: 32},
     viewJustify: 18432,
     viewChangedScript:
       func(slot, view)begin	if slot = 'icon then	begin		widget.icon := icon;		:ShowWidget();	end;	nil;end
     ,
     viewClass: 76 /* clPictureView */
    };
AddStepForm(widgetSlipBase, IconDisplay);
StepDeclare(widgetSlipBase, IconDisplay, 'IconDisplay);



Property :=
    {text: "Property",
     viewBounds: {left: 0, top: 1, right: 0, bottom: 15},
     alwaysCallPickActionScript: true,
     viewJustify: 8396848,
     labelCommands: ["Property"],
     textSetup:
       func() begin	if widget.widgetType=NIL then begin		name:=intern("widgetType");		return "widgetType";		end;	else return ""	end
     ,
     pickerSetup:
       func() begin	if debug then print("property.pickerSetup");	if lastAction then begin		:showWidget();		if lastAction='bounds then :showWidgetProcrastinatedCancel();		if lastAction<>'flags			then widgetProperties.(lastAction):close()			else flags:close();		lastAction:=nil;		SetValue(entryLine, 'text, :TextSetup());		end;	if NOT hasSlot(widget, 'widgetType)		then labelCommands:=["widgetType"];		else begin			local noMenu := ['_proto, 'viewClass, 'expert, 'type, 'icon, 'item, 'contents, ];			local noFuncs := ['codeBlock, '_function,];			local noWidgets := ['_proto, 'viewClass, 'widgetName, 'widgetType, 'order];			local a:=[];			local lib:=widgetLib.(intern(widget.widgetType));			foreach slot,value in lib do				if not LSearch(noMenu, slot, 0, '|=|, nil) and						not LSearch(noFuncs, classOf(value), 0, '|=|, nil)					then addArraySlot(a, sprintobject(slot));			foreach slot,value in widget do 				if not hasSlot(lib, slot) and 						not LSearch(noWidgets, slot, 0, '|=|, nil) and 						not LSearch(noFuncs, classOf(value), 0, '|=|, nil)					then addArraySlot(a, sprintobject(slot));			sort(a,'|str<|, nil);			labelCommands:=a;			if systemEntry.userLevel=kExpertExpert then begin				addArraySlot(labelCommands, 'pickSeparator);				addArraySlot(labelCommands, "add property");				if lastProperty and not strEqual(lastProperty, "add property") and not hasSlot(widgetLib, intern(lastProperty)) then					addArraySlot(labelCommands, "remove marked property");				end;			end;	true;end
     ,
     labelActionScript:
       func(i) begin	local format;			if strEqual(labelCommands[i],"add property") then begin		format:='string;		name:="add property";		end	else if strEqual(labelCommands[i],"remove marked property") then begin		removeSlot(widget, intern(lastProperty));		return		end	else begin		name:=intern(labelCommands[i]);		format:=kValues.(name).format;		end;			if debug then print("format:" & sprintobject(format) && name);	if (NOT format or NOT hasSlot(widgetProperties, format)) and format<>'flags then format:='eval;	lastAction:=format;	lastProperty:=labelCommands[i];	if format<>'flags		then widgetProperties.(format):open()		else flags:open();end
     ,
     name: nil,
     lastProperty: nil,
     lastAction: nil,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(widgetSlipBase, Property);
StepDeclare(widgetSlipBase, Property, 'Property);



widgetProperties :=
    {viewFlags: 1,
     viewBounds: {left: 0, top: 0, right: 0, bottom: 47},
     viewJustify: 8240,
     CurrentProperty: nil,
     viewChangedScript:
       func(slot, view)begin	if slot = 'CurrentProperty then	begin		if CloseProperty then			self.(CloseProperty):Close();		if CurrentProperty then			self.(CurrentProperty):Open();		CloseProperty := CurrentProperty;	end;	nil;end
     ,
     CloseProperty: nil,
     viewClass: 74 /* clView */
    };
AddStepForm(widgetSlipBase, widgetProperties);
StepDeclare(widgetSlipBase, widgetProperties, 'widgetProperties);

String :=
    {viewFlags: 33553920,
     viewFormat: 8273,
     viewBounds: {left: 8, top: 0, right: -8, bottom: 46},
     viewFont: editFont12,
     viewSetupDoneScript:
       func() begin	if classof(property.name)<>'string and widget.(property.name) // don't do if "add property"		then self.text:=sprintobject(widget.(property.name))		else self.text:="";		setKeyView(self, strLen(text));		end
       ,
     viewLineSpacing: 18,
     text: "",
     viewChangedScript:
       func(slot, view) begin	if debug then print("string.viewChangedScript:" & property.name);	if classOf(property.name)='string and strEqual(property.name, "add property")		then return		else begin			widget.(property.name):=text;			:delayedRefresh();						end;	if property.name='widgetName then begin		if debug then print("WidgetName changed");		widgetTitle:close();		widgetTitle.title:=text;		widgetTitle:open();		endend
     ,
     viewQuitScript:
       // must return the value of inherited:?viewQuitScript();func() begin	if debug then print("string.viewQuitScript");	if classOf(property.name)='string and 		 strEqual(property.name, "add property") and		 NOT strEqual(text, "") then begin				widget.(intern(text)):=widget.(intern(text));  // should do _proto inheritance				if debug then print(widget.(intern(text)));		    end;	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     viewJustify: 48,
     viewClass: 81 /* clParagraphView */
    };
AddStepForm(widgetProperties, String);
StepDeclare(widgetProperties, String, 'String);



Eval :=
    {viewFlags: 33553920,
     viewFormat: 8273,
     viewBounds: {left: 8, top: 0, right: -8, bottom: 46},
     viewFont: editFont10,
     viewSetupDoneScript:
       func() begin	if debug then print("Eval.viewSetupDoneScript");	line:="";	if widget.(property.name) then begin		:formatArbObj(widget.(property.name),0);		text:=line;		if debug then print(text);		end;	setKeyView(self, strLen(text));		end
     ,
     viewLineSpacing: 18,
     text: "",
     viewChangedScript:
       func(slot, view) begin	try local textValueFunc:=compile(text)		onException |evt.ex| do begin		return NIL;		end;		if debug then print(textValueFunc);	try local val:=call textValueFunc with ()		onException |evt.ex| do begin		return NIL;		end;	widget.(property.name):=val;	if debug then print(widget.(property.name));	:delayedRefresh();end
     ,
     viewJustify: 48,
     viewClass: 81 /* clParagraphView */
    };
AddStepForm(widgetProperties, Eval);
StepDeclare(widgetProperties, Eval, 'Eval);



Bounds :=
    {viewFlags: 4,
     viewFormat: 1,
     viewBounds: {left: 10, top: 0, right: 182, bottom: 46},
     viewChangedScript:
       func(slot, view) begin	if debug then print("bounds.viewChangedScript");	if ignoreChanges then return;	local x:={top:  :makeInt(top.text), bottom: :makeInt(bottom.text), 					 left: :makeInt(left.text), right:  :makeInt(right.text)};	if x.top>999 then x.top:=999;	if x.bottom>999 then x.bottom:=999;	if x.left>999 then x.left:=999;	if x.right>999 then x.right:=999;	widget.(property.name):=x;													 	:delayedRefresh();	nil;end
     ,
     viewSetupDoneScript:
       func() begin	:getBounds();	if newton21 then setKeyView(left, strLen(left.text));	end
     ,
     getBounds:
       func() begin	if debug then print("getBounds");	ignoreChanges:=true;	b:=widget.(property.name);	setValue(top, 'text, sPrintObject(b.top));	setValue(bottom, 'text, sPrintObject(b.bottom));	setValue(right, 'text, sPrintObject(b.right));	setValue(left, 'text, sPrintObject(b.left));	b:=widget.viewBounds;	setValue(dragger, 'viewBounds, b);	setValue(stretcher, 'viewBounds, {top:   b.bottom-9, left:    b.right-9,																		right: b.right-5,  bottom:  b.bottom-5});	ignoreChanges:=NIL;end
     ,
     ignoreChanges: nil,
     _tabChildren: ['Left, 'Right, 'Top, 'Bottom],
     _tabParent: TRUE,
     viewClass: 77 /* clEditView */
    };
AddStepForm(widgetProperties, Bounds);
StepDeclare(widgetProperties, Bounds, 'Bounds);

Bounds_v218_0 :=
    {text: "Top",
     viewBounds: {left: 25, top: 20, right: 60, bottom: 35},
     viewFont: ROM_fontSystem9,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(Bounds, Bounds_v218_0);



Top :=
    {viewBounds: {left: 55, top: 21, right: 90, bottom: 35},
     viewFont: editFont12,
     viewFormat: 12624,
     viewLineSpacing: 15,
     viewJustify: 8388612,
     viewFlags: 10753,
     text: "",
     ViewCaretActivateScript:
       func(activated) 	if activated and newton21 then setKeyView(self, strLen(text));
     ,
     _proto: @185 /* protoInputLine */
    };
AddStepForm(Bounds, Top);
StepDeclare(Bounds, Top, 'Top);



Bounds_v218_0 :=
    {text: "Left",
     viewBounds: {left: 25, top: 0, right: 50, bottom: 15},
     viewFont: ROM_fontSystem9,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(Bounds, Bounds_v218_0);



Left :=
    {viewBounds: {left: 55, top: 1, right: 90, bottom: 15},
     viewFont: editFont12,
     viewFormat: 12624,
     viewLineSpacing: 15,
     viewJustify: 8388612,
     viewFlags: 10753,
     text: "",
     ViewCaretActivateScript:
       func(activated) 	if activated and newton21 then setKeyView(self, strLen(text));
     ,
     _proto: @185 /* protoInputLine */
    };
AddStepForm(Bounds, Left);
StepDeclare(Bounds, Left, 'Left);



Bounds_v218_0 :=
    {text: "Right",
     viewBounds: {left: 98, top: 0, right: 135, bottom: 15},
     viewFont: ROM_fontSystem9,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(Bounds, Bounds_v218_0);



Right :=
    {viewBounds: {left: 135, top: 1, right: 170, bottom: 15},
     viewFont: editFont12,
     viewFormat: 12624,
     viewLineSpacing: 15,
     viewJustify: 8388612,
     viewFlags: 10753,
     text: "",
     ViewCaretActivateScript:
       func(activated) 	if activated and newton21 then setKeyView(self, strLen(text));
     ,
     _proto: @185 /* protoInputLine */
    };
AddStepForm(Bounds, Right);
StepDeclare(Bounds, Right, 'Right);



Bounds_v218_0 :=
    {text: "Bottom",
     viewBounds: {left: 98, top: 20, right: 135, bottom: 35},
     viewFont: ROM_fontSystem9,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(Bounds, Bounds_v218_0);



Bottom :=
    {viewBounds: {left: 135, top: 21, right: 170, bottom: 35},
     viewFont: editFont12,
     viewFormat: 12624,
     viewLineSpacing: 15,
     viewJustify: 8388612,
     viewFlags: 10753,
     text: "",
     ViewCaretActivateScript:
       func(activated) 	if activated and newton21 then setKeyView(self, strLen(text));
     ,
     _proto: @185 /* protoInputLine */
    };
AddStepForm(Bounds, Bottom);
StepDeclare(Bounds, Bottom, 'Bottom);





Format :=
    {viewFlags: 0,
     viewFormat: 1,
     viewBounds: {left: 0, top: 0, right: 190, bottom: 46},
     calcValue:
       func() begin	local PN:=property.name;	local v:=vfPen*pen.viewValue+vfRound*round.viewvalue+					 vfInset*inset.viewValue+vfShadow*shadow.viewValue+					 vConstants.(kValues.(PN).frameValues[frame.viewValue])+					 vConstants.(kValues.(PN).fillValues[fill.viewValue])+					 vConstants.(kValues.(PN).lineValues[lines.viewValue]);	widget.(PN):=v;	:showWidget();	end
     ,
     viewChangedScript: func(slot, view) 	:delayedRefresh();,
     viewSetupFormScript:
       func() begin	if widget.(property.name)=nil then widget.(property.name):=0;	end;
     ,
     viewJustify: 16,
     viewClass: 77 /* clEditView */
    };
AddStepForm(widgetProperties, Format);
StepDeclare(widgetProperties, Format, 'Format);

Shadow :=
    {labelCommands: ["0","1","2","3"],
     text: "Shadow",
     viewBounds: {left: 51, top: 17, right: 114, bottom: 31},
     viewFont: ROM_fontSystem9,
     textSetup:
       func() begin	local v:=widget.(property.name);	self.viewValue:=(v DIV vfShadow) MOD 4;	sprintobject(self.viewValue);	end;
     ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Format, Shadow);
StepDeclare(Format, Shadow, 'Shadow);



Round :=
    {
     labelCommands:
       ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"],
     text: "Round",
     viewBounds: {left: 51, top: 1, right: 114, bottom: 15},
     viewFont: ROM_fontSystem9,
     textSetup:
       func() begin	local v:=widget.(property.name);	self.viewValue:=(v DIV vfRound) MOD 16;	sprintobject(self.viewValue);	end;
     ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     viewSetupDoneScript:
       func()	setvalue(round.entryline.viewbounds, 'left, shadow.entryline.viewbounds.left)
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Format, Round);
StepDeclare(Format, Round, 'Round);



Inset :=
    {labelCommands: ["0","1","2","3"],
     text: "Inset",
     viewBounds: {left: 1, top: 17, right: 50, bottom: 31},
     viewFont: ROM_fontSystem9,
     textSetup:
       func() begin	local v:=widget.(property.name);	self.viewValue:=(v DIV vfInset) MOD 4;	sprintobject(self.viewValue);	end;
     ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Format, Inset);
StepDeclare(Format, Inset, 'Inset);



Pen :=
    {
     labelCommands:
       ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"],
     text: "Pen",
     viewBounds: {left: 1, top: 1, right: 50, bottom: 15},
     viewFont: ROM_fontSystem9,
     textSetup:
       func() begin	local v:=widget.(property.name);	self.viewValue:=(v DIV vfPen) MOD 16;	sprintobject(self.viewValue);	end;
     ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     viewSetupDoneScript:
       func()	setvalue(pen.entryline.viewbounds, 'left, inset.entryline.viewbounds.left)
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Format, Pen);
StepDeclare(Format, Pen, 'Pen);



Frame :=
    {labelCommands: [],
     text: "Frame",
     viewBounds: {left: 114, top: 1, right: 204, bottom: 15},
     viewFont: ROM_fontSystem9,
     pickerSetup:
       func() begin	if debug then print("call picker setup");	values:=kValues.(property.name).frameValues;	if debug then print(values);	labelCommands:=[];		if classOf(values)='array then		foreach v in values do begin			s:=substr(sPrintObject(v),2,nil);			if NOT strEqual(s,"None") then s:=substr(s,5,nil);			addArraySlot(labelCommands, s);			end;			true		// the popup should happenend
       ,
     textSetup:
       func() begin	if debug then print("frame.textSetup");	local v:=widget.(property.name);		self.viewValue:=(v DIV 16) MOD 16;	if viewValue=15 then viewValue:=6;		if viewValue=0		then return "None"		else return substr(sprintobject(kValues.(property.name).frameValues[viewValue]),7,nil);				end
     ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Format, Frame);
StepDeclare(Format, Frame, 'Frame);



Fill :=
    {labelCommands: [],
     text: "Fill",
     viewBounds: {left: 114, top: 17, right: 199, bottom: 31},
     viewFont: ROM_fontSystem9,
     pickerSetup:
       func() begin	values:=kValues.(property.name).fillValues;	if debug then print(values);	labelCommands:=[];		if classOf(values)='array then		foreach v in values do begin			s:=substr(sPrintObject(v),2,nil);			if NOT strEqual(s,"None") then s:=substr(s,4,nil);			addArraySlot(labelCommands, s);			end;			true		// the popup should happenend
       ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end
     ,
     textSetup:
       func() begin	if debug then print("line.textSetup");	local v:=widget.(property.name);		self.viewValue:=(v DIV 1) MOD 16;	if viewValue>5 then viewValue:=0;		if viewValue=0		then return "None"		else return substr(sprintobject(kValues.(property.name).fillValues[viewValue]),6,nil);				end
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Format, Fill);
StepDeclare(Format, Fill, 'Fill);



Lines :=
    {labelCommands: [],
     text: "Lines",
     viewBounds: {left: 51, top: 33, right: 140, bottom: 47},
     viewFont: ROM_fontSystem9,
     pickerSetup:
       func() begin	if debug then print("call picker setup");	local s;	values:=kValues.(property.name).lineValues;	if debug then print(values);	labelCommands:=[];		if classOf(values)='array then		foreach v in values do begin			s:=substr(sPrintObject(v),2,nil);			if NOT strEqual(s,"None") then s:=substr(s,5,nil);			addArraySlot(labelCommands, s);			end;			true		// the popup should happenend
       ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end
     ,
     textSetup:
       func() begin	if debug then print("frame.textSetup");	local v:=widget.(property.name);		self.viewValue:=(v DIV 4096) MOD 16;	if viewValue>5 then viewValue:=0;		if viewValue=0		then return "None"		else return substr(sprintobject(kValues.(property.name).frameValues[viewValue]),7,nil);				end
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Format, Lines);
StepDeclare(Format, Lines, 'Lines);





Justify :=
    {viewFlags: 0,
     viewFormat: 1,
     viewBounds: {left: 20, top: 0, right: 200, bottom: 46},
     calcValue:
       func() begin	local PN:=property.name;	local v:=vConstants.(kValues.(PN).horizontalValues[horizontal.viewValue])+					 vConstants.(kValues.(PN).verticalValues[vertical.viewValue])+					 vConstants.(kValues.(PN).textLimitValues[textLimits.viewValue]);	widget.(PN):=v;	:showWidget();	end
     ,
     viewChangedScript: func(slot, view)	:delayedRefresh();,
     viewClass: 77 /* clEditView */
    };
AddStepForm(widgetProperties, Justify);
StepDeclare(widgetProperties, Justify, 'Justify);

Horizontal :=
    {labelCommands: [],
     text: "Horizontal",
     viewBounds: {left: 1, top: 1, right: 140, bottom: 15},
     viewFont: ROM_fontSystem9,
     pickerSetup:
       func() begin	if debug then print("call picker setup");	values:=kValues.(property.name).horizontalValues;	if debug then print(values);	labelCommands:=[];		if classOf(values)='array then		foreach v in values do begin			s:=sPrintObject(v);			addArraySlot(labelCommands, substr(s,2,strLen(s)-3));			end;			true		// the popup should happenend
       ,
     textSetup:
       func() begin	if debug then print("horizontal.textSetup");	local v:=widget.(property.name);	if NOT v then widget.(property.name):=v:=0;	local values:=kValues.(property.name).horizontalValues;	self.viewValue:=0;	for  i:=0 to length(values)-1 do		if band(v,vConstants.(values[i]))=vConstants.(values[i]) and vConstants.(values[i])>0			then viewValue:=i;		local s:=sprintobject(values[viewValue]);			return substr(s,2,strLen(s)-3);		end		
     ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     viewSetupFormScript:
       func()begin	self.indent := 68;	inherited:?viewSetupFormScript();end,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Justify, Horizontal);
StepDeclare(Justify, Horizontal, 'Horizontal);



Vertical :=
    {labelCommands: [],
     text: "Vertical",
     viewBounds: {left: 1, top: 17, right: 140, bottom: 31},
     viewFont: ROM_fontSystem9,
     pickerSetup:
       func() begin	if debug then print("call picker setup");	values:=kValues.(property.name).verticalValues;	if debug then print(values);	labelCommands:=[];		if classOf(values)='array then		foreach v in values do begin			s:=sPrintObject(v);			addArraySlot(labelCommands, substr(s,2,strLen(s)-3));			end;			true		// the popup should happenend
       ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end
     ,
     textSetup:
       func() begin	if debug then print("horizontal.textSetup");	local v:=widget.(property.name);	local values:=kValues.(property.name).verticalValues;	self.viewValue:=0;	for  i:=0 to length(values)-1 do		if band(v,vConstants.(values[i]))=vConstants.(values[i]) and vConstants.(values[i])>0			then viewValue:=i;		local s:=sprintobject(values[viewValue]);			return substr(s,2,strLen(s)-3);		end
     ,
     viewSetupFormScript:
       func() begin	self.indent := Horizontal.indent;	inherited:?viewSetupFormScript();	end
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Justify, Vertical);
StepDeclare(Justify, Vertical, 'Vertical);



TextLimits :=
    {labelCommands: [],
     text: "Text Limits",
     viewBounds: {left: 1, top: 33, right: 190, bottom: 47}
     ,
     viewFont: ROM_fontSystem9,
     pickerSetup:
       func() begin	if debug then print("call picker setup");	values:=kValues.(property.name).textLimitValues;	if debug then print(values);	labelCommands:=[];		if classOf(values)='array then		foreach v in values do begin			s:=sPrintObject(v);			addArraySlot(labelCommands, s);			end;			true		// the popup should happenend
       ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end
     ,
     textSetup:
       func() begin	if debug then print("textLimits.textSetup");	local v:=widget.(property.name);	local values:=kValues.(property.name).textLimitValues;	self.viewValue:=0;	for  i:=0 to length(values)-1 do		if band(v,vConstants.(values[i]))>0 then viewValue:=i;		local s:=sprintobject(values[viewValue]);			return s;		end
     ,
     viewSetupFormScript:
       func() begin	self.indent := Horizontal.indent;	inherited:?viewSetupFormScript();	end
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Justify, TextLimits);
StepDeclare(Justify, TextLimits, 'TextLimits);





Font :=
    {viewFlags: 0,
     viewFormat: 1,
     viewBounds: {left: 20, top: 0, right: 150, bottom: 47},
     calcValue:
       func() begin	local PN:=property.name;	local v:=widget.(PN);	local parms:={family: intern(family.labelCommands[family.viewValue]),											face:   vConstants.(kfaceValues[face.viewValue]),											size:   :makeInt(size.labelCommands[size.viewValue])};	widget.(PN):=parms;	:showWidget();	end
     ,
     viewChangedScript: func(slot, view)	:delayedRefresh();,
     viewClass: 77 /* clEditView */
    };
AddStepForm(widgetProperties, Font);
StepDeclare(widgetProperties, Font, 'Font);

Family :=
    {labelCommands: [],
     text: "Family",
     viewBounds: {left: 1, top: 1, right: 140, bottom: 15},
     viewFont: ROM_fontSystem9,
     textSetup:
       func() begin	if debug then print("family.textSetup");	self.viewValue:=0;	local v:= sprintObject(getFontFamilySym(widget.(property.name)));	labelCommands:=[];	foreach slot, value in getglobals().fonts do		if slot<>'_proto then addArraySlot(labelCommands, getglobals().fonts.(slot).name);	foreach slot, value in getglobals().fonts._proto do		addArraySlot(labelCommands, getglobals().fonts._proto.(slot).name);	sort(labelCommands, '|str<|, nil);	for i:=0 to length(labelCommands)-1 do		if strEqual(v,labelCommands[i]) then self.viewValue:=i;	return labelCommands[viewValue];	end
     ,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Font, Family);
StepDeclare(Font, Family, 'Family);



Face :=
    {labelCommands: [],
     text: "Face",
     viewBounds: {left: 1, top: 17, right: 140, bottom: 31},
     viewFont: ROM_fontSystem9,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     textSetup:
       func() begin	if debug then print("face.textSetup");	self.viewValue:=0;	local v:=getFontFace(widget.(property.name));	local values:=kFaceValues;	labelCommands:=[];	for i:=0 to length(values)-1 do begin		if v=vConstants.(values[i]) then viewValue:=i;		addArraySlot(labelCommands,substr(sPrintObject(values[i]),5,nil))		end;		return labelCommands[viewValue]	end
     ,
     viewSetupFormScript:
       func() begin	self.indent := Family.indent;	inherited:?viewSetupFormScript();	end
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Font, Face);
StepDeclare(Font, Face, 'Face);



Size :=
    {labelCommands: [],
     text: "Size",
     viewBounds: {left: 1, top: 33, right: 190, bottom: 47},
     viewFont: ROM_fontSystem9,
     labelActionScript: func(i) begin	self.viewValue:=i;	:calcValue();end,
     textSetup:
       func() begin	if debug then print("size.textSetup");	self.viewValue:=0;	local v:=sPrintObject(getFontSize(widget.(property.name)));	labelCommands:=kSizeValues;	for i:=0 to length(labelCommands)-1 do		if strEqual(v,labelCommands[i]) then self.viewValue:=i;		return labelCommands[viewValue];	end
     ,
     viewSetupFormScript:
       func() begin	self.indent := Family.indent;	inherited:?viewSetupFormScript();	end
     ,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(Font, Size);
StepDeclare(Font, Size, 'Size);





Effect :=
    {labelCommands: [],
     text: "Effect",
     viewBounds: {left: 1, top: 0, right: 180, bottom: 15},
     viewFont: ROM_fontSystem9,
     textSetup:
       func() begin	if debug then print("effect.textSetup");	self.viewValue:=0;	local v:=getFontFace(widget.(property.name));	local values:=kValues.(property.name).Values;	labelCommands:=[];	for i:=0 to length(values)-1 do begin		if v=vConstants.(values[i]) then viewValue:=i;		addArraySlot(labelCommands,substr(sPrintObject(values[i]),2,nil))		end;		return labelCommands[viewValue]	end
     ,
     labelActionScript:
       func(i) begin	self.viewValue:=i;	widget.(property.name):=kValues.(property.name).values[i];	:showWidget();end
     ,
     viewFlags: 514,
     viewChangedScript: func(slot, view)	:delayedRefresh();,
     _proto: @190 /* protoLabelPicker */
    };
AddStepForm(widgetProperties, Effect);
StepDeclare(widgetProperties, Effect, 'Effect);



Boolean :=
    {viewBounds: {left: 0, top: 4, right: 14, bottom: 18},
     viewFormat: 0,
     viewLineSpacing: 15,
     text: "",
     viewValue: nil,
     viewSetupDoneScript:
       func() 	if widget.(property.name)<>viewValue then :toggleCheck();,
     viewFlags: 512,
     viewQuitScript:
       func() begin	widget.(property.name):=viewValue;	:showWidget();	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     viewChangedScript: func(slot, view)	:delayedRefresh();,
     viewJustify: 20,
     _proto: @164 /* protoCheckBox */
    };
AddStepForm(widgetProperties, Boolean);
StepDeclare(widgetProperties, Boolean, 'Boolean);



Int :=
    {viewBounds: {left: 0, top: 4, right: 80, bottom: 24},
     viewFont: editFont12,
     viewFormat: 12624,
     viewLineSpacing: 15,
     viewSetupDoneScript:
       func() begin	setValue(self, 'text, sprintobject(widget.(property.name)));	if newton21 then setKeyView(self, strLen(text));	end
     ,
     text: nil,
     viewFlags: 10752,
     viewJustify: 8388625,
     viewChangedScript:
       func(slot, view) begin	widget.(property.name):=:makeInt(text);	:delayedRefresh();	nil;end
     ,
     _proto: @185 /* protoInputLine */
    };
AddStepForm(widgetProperties, Int);
StepDeclare(widgetProperties, Int, 'Int);






constant |layout_widgetSlip| := widgetSlipBase;
// End of file widgetSlip
// Beginning of text file vRouting Data
constant vMyMainDataDefSym 	:= '|myDataDef:visualDesigner:NSB| ;constant vMyMainViewDefSym 	:= '|myViewDef:visualDesigner:NSB| ;constant vMyFrameViewDefSym := '|myFrameViewDef:visualDesigner:NSB| ;//OpenResFile(home & "resource.rsrc"); (HELP!)//DefConst('kMoveBack, GetPictAsBits("moveBack", nil));//DefConst('keditProperties, GetPictAsBits("editProperties", nil));constant kmoveback:=nil;constant kEditProperties:=nil;//CloseResFile();/* * This is a routing format which handles 'text and 'frame (des
£Gø£GÀpite the name, protoFrameFormat * handles both types. If you want to handle just 'frames, override the dataTypes slot with ['frame]. * * This will be registered in the application installScript with RegisterViewDef(...). * * Note that we won't necessarily be able to view the item in the iobox unless we write a  * NON-ROUTING viewDef for vMyMainDataDefSym so that it can be viewed in the iobox item viewer. */DefConst('vMyFrameRoutingFormat, {		_proto:		protoFrameFormat,	title:		"CustomRoute -
£Gø£GÀ picture choice", 	version:	1, 	symbol:		vMyFrameViewDefSym, 	SetupItem:	func(item, targetInfo) begin			inherited:?SetupItem(item, targetInfo);			/*If you have any "preprocessing" to do like set anything in the item or add			 * extra body slots like version slots, or extra data, you can do it here, but if you are			 * trying to actually prep visual shapes, do that in formatInitScript.					 * 			 * Note that by calling inherited, we get the equivalent of:			 *		item.body := targetInfo.target
£Gø£GÀ;			 * ...plus if the target is a soup entry alias, it resolves it...			 *			 * Only modify the item, not the target.			 */			// set the title; note that the string will be editable by the user...			item.title := "CustomRoute item: " & datentime(time());			if debug then print("setup Item" & item.title);			item;		end,	textScript: func(fields, target)		clone(target.data);	// our target.data should always be plain text});
ited, we get the equivalent of:			 *		item.body := targetInfo.target
// End of text file vRouting Data
// Beginning of file vPrintFormat
_v200_0 :=
    {
     printNextPageScript:
       func() begin   // print 1 pages worth of stuff	if myPageCounter < 1 then begin			// we check this in viewSetupFormScript to distinguish between			// Initialization and RedoChildren;			myPageCounter := myPageCounter + 1;			turningPages := true;				:RedoChildren();	// rebuild all our views in preparation for the next page			turningPages := nil;			true;		end;end
       ,
     symbol: vMyMainViewDefSym,
     viewSetupFormScript:
       func() begin	// we set this in printNextPageScript to distinguish between Initialization and RedoChildren();	if not turningPages then		myPageCounter := 1;					// don't rely on fields.pageNumber to track pages! We track it											// and increment it in printNextPageScript	inherited:?viewSetupFormScript();		// this method is defined internallyend
       ,
     formatInitScript:
       func(fields,theTarget)begin	/* If you need to do prep something which takes a long time, and you are 	 * worried about "timing out" a fax machine, do it here, not	 * in viewSetupFormScript!!!	 */end
     ,
     SetupItem:
       func(item, tInfo) begin	/* If you have any "preprocessing" to do like set anything in the item or add	 * extra slots like version slots, or extra data, you can do it here, but if you are	 * trying to actually prep the visual shapes, you should do that in formatInitScript.	 */	inherited:?SetupItem(item, tInfo);			// set the title; note that the string will be editable by the user...	item.title := "Visual Designer: " & datentime(time());		item;end
       ,
     title: "Visual Designer",
     myPageCounter: nil,
     turningPages:
       nil	// a flag to distinguish between initialization and RedoChildren in viewSetupFormScript
       ,
     _proto: @200 /* protoPrintFormat */
    };

widgets :=
    {viewBounds: {left: 5, top: 5, right: 5, bottom: -5},
     viewFlags: 1,
     viewFont: simpleFont18,
     viewFormat: 0,
     viewLineSpacing: 20,
     viewSetupFormScript:
       func() begin	self.viewBounds:=getAppParams().appAreaBounds;	foreach widget in getroot().(kAppSymbol).widgetViews do		addStepView(self, widget)	end
     ,
     viewJustify: 240,
     viewClass: 81 /* clParagraphView */
    };
AddStepForm(_v200_0, widgets);




constant |layout_vPrintFormat| := _v200_0;
// End of file vPrintFormat
// Beginning of file vButtons.t
Buttons :=
    {viewBounds: {left: 48, top: 24, right: 272, bottom: 256},
     viewFlags: 1,
     viewFormat: 0,
     DoneScript:
       func() begin	inherited:?viewSetupDoneScript();	NewtAppBase.(GetVariable(self, 'declareSelf)) := self;	end;
     ,
     QuitScript:
       func() begin	RemoveSlot(NewtAppBase, GetVariable(self, 'declareSelf));	inherited:?viewQuitScript();	end;
     ,
     viewClass: 74 /* clView */
    };

bNewButton :=
    {text: "  New Button",
     viewBounds: {left: 26, top: -16, right: 57, bottom: -3},
     popup: nil,
     buttonClickScript:
       func()begin	popup := visualDesigner:MakeTypeList('button);	inherited:?ButtonClickScript();end
     ,
     pickActionScript:
       func(cmd)begin	inherited:?PickActionScript(cmd);	visualDesigner:NewWidget(popup[cmd].item);end
     ,
     declareSelf: 'bNewButton,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bNewButton);



bNewField :=
    {text: "  New Field",
     viewBounds: {left: 63, top: -16, right: 94, bottom: -3},
     popup: nil,
     buttonClickScript:
       func()begin	popup := visualDesigner:MakeTypeList('field);	inherited:?ButtonClickScript();end
     ,
     pickActionScript:
       func(cmd)begin	inherited:?PickActionScript(cmd);	visualDesigner:NewWidget(popup[cmd].item);end
     ,
     declareSelf: 'bNewField,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(Buttons, bNewField);



// After Script for Buttons
thisView := Buttons;
foreach child in thisView.stepChildren dobegin	local sym;	RemoveSlot(child, 'viewBounds);	sym := GetSlot(child, 'declareSelf);	RemoveSlot(child, 'declareSelf);//		child.viewQuitScript := thisView.QuitScript;//		child.viewSetupDoneScript := thisView.DoneScript;	DefConst(sym, child);end		



constant |layout_vButtons.t| := Buttons;
// End of file vButtons.t
// Beginning of file VisualDesignerUnit
visualDesignerBase :=
    {
     pickTypePopup:
       func(type) begin	if strokeUnit then begin		local nb:=strokeUnit.bounds;		nb.left:=floor((nb.right-nb.left)/2)+nb.left;		end;	else nb:={left: 20, top: 20, bottom: 200, right: 200};	pickTypeList := :MakeTypeList(type);	doPopUp(pickTypeList,nb.left,nb.bottom,selector);end
     ,
     chainQuit:
       func() begin	local result,fullFrame;	line:="";	if getroot().|basic:NSB| and		getroot().|basic:NSB|.systemEntry and		hasSlot(getroot().|basic:NSB|.systemEntry, 'widgetDefType)		then chainMode:=getroot().|basic:NSB|.systemEntry.widgetDefType;	if chainMode='array then begin		foreach widget in widgetArray do widget:=:stripWidget(widget);		result:=:formatArbObj(widgetArray,0);		end;			else if chainMode='frame or chainMode:='frameIn then begin		fullFrame:={};		foreach widget in widgetArray do begin			widget:=:stripWidget(widget);			fullFrame.(intern(widget.widgetName)):=widget;			removeSlot(widget, 'widgetName);			end;		if chainMode='frame			then result:=:formatArbObj(fullFrame,0)			else result:=fullFrame;		end;					if debug then print("ChainQuit");	if chainCallBackFunc='newtCard		then addDeferredSend(funcs, 'visualDesignerReturn, [result])		else addDeferredCall(func() :chainCallBackFunc(result), nil);	chainMode:=nil;end
     ,
     Display:
       func(x, y, cbf)begin	:ShowToolLayer('widgets);	:NewWidget(if x = 'button then "textButton" else "text");end
     ,
     hideAllWidgets:
       func() begin	if debug then print("hideAllWidgets: " & length(baseView.stepchildren));	if NOT widgetViews then return;			foreach widget in widgetViews do removeStepView(baseView, widget);	baseView:dirty();	widgetViews:=[];end
     ,
     chainCallBackFunc:
       nil // reference passed from calling program
       ,
     widgetArray:
       [] // holds the full array of widget as passed in/returned
       ,
     MakeTypeList:
       func(type)begin	local theList := [];	foreach slot,value in widgetLib do		if (type='all or value.type=type)		   and value.type<>'ignore		   and (systemEntry.userLevel >= value.expert)		   	then addArraySlot(theList, {item: value.item, icon: widgetIcons.(slot),		   				indent: 30,});				sort(theList,'|str<|,'item);		theList;end
     ,
     viewSetupDoneScript: func() begin	stopUpdates:=nil;	Title:Close();end,
     viewFormat: 256,
     showAllWidgets:
       func() begin	:hideAllWidgets();	foreach widget in :getOrderedArray(widgetArray) do		:showNewWidget(widget);	baseView:dirty();	end
     ,
     viewQuitScript:
       // must return the value of inherited:?viewQuitScript();func() begin	if debug then print("visualDesigner.viewQuitScipt()");	if Visible(widgetSlipLink) then begin		local theName := widgetArray[selectedWidget].widgetName;		local originalName := Clone(theName);		while :FindNameConflict(theName) do begin			local modified:=true;			theName := theName & $*;			end;		if modified then begin			widgetArray[selectedWidget].widgetName := theName;			local message:="Widget Ò^0Ó renamed to Ò^1Ó because of a naming conflict.";			GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName),					EnsureInternal(ParamStr(message, [originalName, theName,])));			end;		end;	if length(widgetViews)>0 then :hideAllWidgets();	if debug then removeSlot(getGlobals(), 'w);	if chainMode then :chainQuit();	removeSlot(self, 'baseView);	removeSlot(self, 'titleSymbol);	removeSlot(self, 'stepChildren);	//if newton21 then :ClearKeyCommands();	line:=nil;	//chainCallBackFunc:=nil; // needs to be done by calling app	stopUpdates:=true;	widgetArray:=nil;	viewBounds:=nil;	if Visible(_oldKeyView) then		self._nextKeyView := _oldKeyView;	RemoveSlot(self, '_oldKeyView);	RemoveSlot(self, '_nextKeyView);	inherited:?viewQuitScript();		// this method is defined internally	end
       ,
     viewDrawScript: func() begin	:doDrawing('drawGrid, NIL);	end,
     delayedRefresh:
       func()	addProcrastinatedCall(kShellSymbol, 												showWidgetProcrastinated, 												[visualDesigner], 												kProcrastinate);
     ,
     viewFlags: 5,
     leftButtons: nil,
     ReorientToScreen: ROM_defRotateFunc,
     widgetViews:
       [] // a list of all open widgets as actually displayed. Codeblocks have been stripped.
       ,
     MyFormats:
       {	viewFormat:	GetLayout("vPrintFormat"),	myFrameFormat:  vMyFrameRoutingFormat,	// see Constants file	// put your other formats in this frame and then check out the code in	// the install/removescripts that uses it...};
       ,
     FindNameConflict:
       func(theName)begin	not theName or StrLen(theName)=0			or (foreach slot,w in widgetArray do					if slot<>selectedWidget and StrEqual(theName, w.widgetName) then						break true)end
     ,
     drawGrid:
       func() begin	:drawShape(gridArray, {penPattern: 3, transferMode:0});end
     ,
     viewBounds: {left: 0, top: 0, right: 232, bottom: 328},
     showNewWidget:
       func(w) begin	if NOT hasSlot(w, '_proto) and NOT hasSlot(w, 'viewClass) then return;	local numArgs, widgetClone;		// make a clone without active scripts	widgetClone:=clone(w);	if strEqual(widgetClone.widgetType, "scroller") then widgetClone._proto:=executor.scroller;	foreach slot,value in widgetClone do		if classof(value)='codeblock or classof(value)='_function then begin			numargs:=widgetClone.(slot).numargs;			if numargs=0 then widgetClone.(slot):=clone(funcWith0args)			else if numargs=1 then widgetClone.(slot):=clone(funcWith1arg)			else if numargs=2 then widgetClone.(slot):=clone(funcWith2args)			end;	w:=addStepView(baseView, widgetClone);	//if debug then print(w);	addArraySlot(widgetViews, w);	w:show();	end
       ,
     gridSize: 36,
     chain:
       func(work, callBackFunc) begin	// called from an external app	if debug then print("chain called");		chainCallBackFunc:=callBackFunc;	if not IsFrame(work) then begin // NewtCard passes it in as a frame		try local textValueFunc:=compile(work)			onException |evt.ex| do return;		try work:=call textValueFunc with ()			onException |evt.ex| do return;		chainMode:=classOf(work); // will either be frame or array		end	else chainMode:='frameIn;				//customize title and format array	if chainMode='array then begin		visualDesigner.titleSymbol:=work[0];		removeSlot(work,0);		foreach i, widget in work do begin			if NOT hasSlot(widget, 'order) then widget.order:=i;			if NOT hasSlot(widget, 'widgetName) then widget.widgetName:="widget_" & i;			end		end	else begin //'frame		visualDesigner.titleSymbol:=work.layoutName;		local workArray:=[];		foreach widgetName, widget in work do			if classOf(widget)='frame then begin				widget.widgetName:=sPrintObject(widgetName);				addArraySlot(workArray, widget);				end;		work:=workArray;		end;			foreach i,w in work do // go through list of widgets		if classOf(w)='frame and hasSlot(w,'widgetType) then begin			widgetSym:=intern(w.widgetType);			if not hasSlot(widgetLib, widgetSym)				then arrayRemoveCount(work, i, 1);			if hasSlot(widgetLib.(widgetSym), '_proto) 				then w._proto:=widgetLib.(widgetSym)._proto;			if hasSlot(widgetLib.(widgetSym), 'viewClass) 				then w.viewClass:=widgetLib.(widgetSym).viewClass;			foreach property, value in widgetLib.(widgetSym) do begin				if NOT hasSlot(w, property) then w.(property):=clone(value);				end;			end;	widgetArray:=work;		visualDesigner:open(); // open Visual Designer	:showAllWidgets();end
       ,
     funcWith0args: func() nil,
     gridArray: nil,
     formatArbObj:
       func (object,currDepth) begin  local whatPrimClass:=primClassOf(object);  local whatClass:=classOf(object);  local temp;  local i:=0;       if whatPrimClass='immediate or whatClass='symbol 		then line:=line & :formatArbObj1(object,currDepth);      	else if whatClass='string 		then line:=line & quote & object & quote;  	else if whatClass='array then begin		line:=line & "[";		foreach slotName,elementVal in object do begin			i:=i+1;			if i>1 then line:=line & ",";			:formatArbObj(elementVal,currDepth+1)			end;		line:=line & "]";		end;	      	else if whatClass='frame or whatPrimClass='Frame then begin		line:=line & "{";		foreach slotName,elementVal in object do begin			i:=i+1;			line:=line & (if i>1 then ",") & slotName & ":";			:formatArbObj(elementVal,currDepth+1);			end;		line:=line & "}";		end;	else begin		temp:=:formatArbObj1(object,currDepth);		if strEqual(temp,"") 			then line:=line & "<" & classof(object) & ">";			else line:=line & temp;		end;      end
     ,
     removeSelectedWidget:
       func() begin	if newtCard and backgroundMode='background then 		if not modalConfirm("Remove from all " & background.cardcount & 			" cards of this background?", 'okCancel) then return;	:smokeIt(widgetArray[selectedWidget].viewBounds);	:hideAllWidgets();	if newtCard then executor:deleteASub(executor:makeScriptName(		'widget, backgroundMode,widgetArray[selectedWidget].widgetName));	removeSlot(widgetArray,selectedWidget);	:showAllWidgets();	end
     ,
     rev: func() return kVersion;,
     strokeUnit: nil,
     chainMode:
       nil /* contains the type of data Widget Designer was chained to with, so the same kind can be returned. */
     ,
     stopUpdates: nil,
     viewOverviewScript:
       func() begin	if debug then print("overviews");	if visible(overView) 		then overview:close()		else overview:open();	end
     ,
     keyCommandArray:
       	[{char: $n, 	  modifiers:	kCommandModifier,		keyMessage:	'doNKeyCommand, 		name: "New",		category: "Editing"},	 {char:$r,	  modifiers:	kCommandModifier,	  keyMessage:	'DoBKeyCommand,	  name: "Router",	  category: "Editing"}]
     ,
     appSymbol: kAppSymbol,
     icon:
       MakePixFamily(
           GetResourceFromFile({filename:
                 "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                 resource: 136}),
           GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF", resource: 
                 }),
           [
            {rsrcSpec:
             GetResourceFromFile({filename:
                   "Macintosh HD:Files:NSB:4.00:NewtCard Shell:Resource.rsrc",
                   resource: 136}),bitDepth: 1},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 2},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 4},
            {rsrcSpec:
             GetResourceFromFile({filename: ":\u00FA000200A3\u9\u00BF",
                   resource: }),bitDepth: 8}]);,
     addWidget:
       func(type) begin	if visible(widgetSlipLink) then widgetSlipLink:close();	:pickTypePopup(type);	end
     ,
     duplicateWidget:
       func() begin	if debug then print("Duplicate" & selectedWidget);	local oldWidget := widgetArray[selectedWidget];	local newWidget:=totalClone(oldWidget);		addArraySlot(widgetArray, newWidget);	selectedWidget := Length(WidgetArray) - 1;	newWidget.viewBounds:=OffsetRect(oldWidget.viewBounds, 10, 10);	newWidget.widgetName:=oldWidget.widgetName & "_copy";	newWidget.order:=selectedWidget;end
     ,
     baseView: nil,
     pickTypeList: nil,
     pickCancelledScript:
       func()begin	strokeUnit := nil;	inherited:?pickCancelledScript();end,
     funcWith2args: func(x,y) NIL,
     getOrderedArray:
       func(frame) begin // This function takes a frame of frames and returns an array of those frames// sorted by the 'order slot in each frame, and resequences the order numbers// if an array is passed, it's just sorted	local result:=[];	if classOf(frame)='frame 		then foreach slot, value in frame do addArraySlot(result, value);		else result:=frame;			sort(result, '|<|, 'order);	for i:=0 to length(result)-1 do result[i].order:=i;	result;	end
       ,
     formatArbObj1:
       func (obj,currDepth) begin  if obj=NIL then return "NIL";  if obj=TRUE then return "TRUE";  if classOf(obj)='symbol  	then return "'" & sPrintObject(obj)  	else return sPrintObject(obj);	end
     ,
     declareSelf: 'base,
     funcWith1arg: func(x) nil,
     viewSetupFormScript:
       func() begin	if debug then getglobals().w:=visualDesigner;	if debug and functions.NSBEnableBreakPoints exists then NSBEnableBreakPoints(true);	if chainCallBackFunc:='newtCard then begin		:alignButtons({left: [bNewButton, bNewField,],});		Title:Close();		end;	baseView:=visualDesigner;	self.viewBounds := GetAppParams().AppAreaBounds;	if not hasSlot(self, 'stepChildren) then self.stepChildren:=clone(self.stepChildren);	newton21:=getglobals().functions.iscommandkeystroke;// test if running Newton 2.1		gridArray:=[];	local top:=0;	local bot:=20;	// The magic numbers 22 and 40 are the same as drawview.canvas	for i:=viewbounds.left+gridSize to viewbounds.right by gridSize		do addArraySlot(gridArray, makeLine(i,viewbounds.top+top,i,viewbounds.bottom-bot));	for i:=viewbounds.top+gridSize+top to viewbounds.bottom-bot by gridSize		do addArraySlot(gridArray, makeLine(viewbounds.left,i,viewbounds.right,i));	self._oldKeyView := GetKeyView();	SetKeyView(self, nil);	self._nextKeyView := GetRoot();end
       ,
     SmokeIt:
       /*   This function erases an area using a poof sound and dissipating   smoke and then forces that portion of the screen to be refreshed.   It takes one argument, a bounds frame in global coordinates. */func(smokeBounds)begin  local top  := smokeBounds.top;  local left := smokeBounds.left;  local bm1 := Clone(ROM_cloud1);  local bm2 := Clone(ROM_cloud2);  local bm3 := Clone(ROM_cloud3);    //CopyBits draw bitmaps scaled to their bounds  bm1.bounds := bm2.bounds := bm3.bounds := smokeBounds;   //explained below  local danQuayle := BuildContext({viewClass:clView,viewFlags:vFloating,viewBounds:smokeBounds,reorienttoscreen:func()nil});  PlaySound(ROM_poof);  GetRoot():CopyBits(bm1,left,top,modeMask);  Sleep(2);  GetRoot():CopyBits(bm1,left,top,modeBic);  GetRoot():CopyBits(bm2,left,top,modeMask);  Sleep(2);  GetRoot():CopyBits(bm2,left,top,modeBic);  GetRoot():CopyBits(bm3,left,top,modeMask);  Sleep(1);  GetRoot():CopyBits(bm3,left,top,modeBic);  //force an update (ala InvalRect in the Mac ToolBox)  danQuayle:Open();  danQuayle:Close();    //If you knew what view(s) to dirty you could just use :Dirty()  // to force the update. This code is general purpose, so it  // doesn't know (and GetRoot():Dirty is way slow)  // In the 2.0 OS only, you could use a better technique,  // simple call GetRoot():DirtyBox(<box>)end
       ,
     newton21: true,
     stripWidget:
       func(widget) begin	// strip all unneeded slots from widget	local removeList:=[];	foreach slot, value in widget do begin		if slot='_parent or slot='_proto or classOf(value)='codeBlock or classOf(value)='_function			then addArraySlot(removeList,slot);		if slot='GOTO and value=NIL then addArraySlot(removeList,slot);		if slot='GOSUB and value=NIL then addArraySlot(removeList,slot);		end;	foreach slot in removeList do removeSlot(widget, slot);	return widgetend
       ,
     pickActionScript:
       func(i) begin	:NewWidget(pickTypeList[i].item);	pickTypeList:=nil;end,
     viewClass: 74 /* clView */,
     doNKeyCommand: func(view) :addWidget('all);,
     selectedWidget: nil,
     line: nil,
     NewWidget:
       func(type)begin  // create a new widget	if StrEqual(type, "right checkbox") then type:="rCheckBox";	local widget:={widgetType: type,			widgetName: widgetLib.(intern(type)).type & "_" & length(widgetArray),			order: length(widgetArray)};				foreach slot,value in widgetLib.(intern(type)) do		widget.(slot):=value;			if strokeUnit then begin // from the caret, position the new widget		local nb:=strokeUnit.bounds;		nb.left:=floor((nb.right-nb.left)/2)+nb.left;		if not hasSlot(widget, 'viewBounds) and hasSlot(widget._proto, 'viewBounds)			then widget.viewbounds:=clone(widget._proto.viewBounds);		if hasSlot(widget, 'viewBounds) then begin			local vb:=widget.viewBounds;			widget.viewBounds:={top: nb.bottom, left: nb.left, 				 								bottom: nb.bottom+vb.bottom-vb.top,					 							right:  nb.left+vb.right-vb.left}		  end		else begin			local vb:=widget.Bounds;			widget.Bounds:={top: nb.bottom, left: nb.left, 				 								bottom: nb.bottom+vb.bottom-vb.top,					 							right:  nb.left+vb.right-vb.left}		  end;		strokeUnit:=NIL;		end;			addArraySlot(widgetArray,widget);	selectedWidget:=length(widgetArray)-1;	//inherit viewBounds so they can be modified	:showNewWidget(widget);	widgetViews[selectedWidget].viewBounds:=widgetViews[selectedWidget].viewBounds;	widgetSlipLink:EditWidget();end
       ,
     viewFillPattern: kFillPattern,
     EditWidgetActions:
       func(index)begin	selectedWidget := index;	if not Visible(widgetSlipLink) then widgetSlipLink:EditWidget();	actionSlipLink:Display(widgetSlipLink.widget, index);end
    };

NewButton :=
    {text: "  New Button",
     viewBounds: {left: 26, top: -16, right: 57, bottom: -3},
     viewJustify: 8388742,
     popup: [],
     viewFlags: 514,
     buttonClickScript:
       func()begin	popup := :MakeTypeList('button);	inherited:?ButtonClickScript();end
     ,
     pickActionScript:
       func(cmd)begin	inherited:?PickActionScript(cmd);	:NewWidget(popup[cmd].item);end
     ,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(visualDesignerBase, NewButton);
StepDeclare(visualDesignerBase, NewButton, 'NewButton);



newField :=
    {text: "  New Field",
     viewBounds: {left: 63, top: -16, right: 94, bottom: -3},
     viewJustify: 8388742,
     popup: [],
     viewFlags: 514,
     buttonClickScriptOLD:
       func() begin	:addWidget('field);	inherited:buttonClickScript();	end,
     buttonClickScript:
       func()begin	popup := :MakeTypeList('field);	inherited:?ButtonClickScript();end
     ,
     pickActionScript:
       func(cmd)begin	inherited:?PickActionScript(cmd);	:NewWidget(popup[cmd].item);end
     ,
     _proto: @386 /* protoPopupButton */
    };
AddStepForm(visualDesignerBase, newField);
StepDeclare(visualDesignerBase, newField, 'newField);



dragger :=
    {text: "",
     viewBounds: {left: 30, top: 33, right: 46, bottom: 41},
     viewFormat: 304,
     viewFlags: 1602,
     viewClickScript:
       func(unit) begin	if debug then print("dragger");	:drag(unit, nil);	setValue(widgetViews[selectedWidget], 'viewBounds, self.viewBounds);	widgetArray[selectedWidget].viewBounds:=widgetViews[selectedWidget].viewBounds;	local b:=widgetViews[selectedWidget].viewBounds;	setValue(stretcher, 'viewBounds, {top:   b.bottom-9, left:    b.right-9,																		right: b.right-3,  bottom:  b.bottom-3});	if visible(widgetSlipLink.widgetProperties.bounds) then widgetSlipLink.widgetProperties.bounds:getBounds();	baseView:dirty();	TRUEend
     ,
     viewSetupDoneScript:
       func() begin	if NOT selectedWidget then return;	if debug then print("dragger open");	setValue(self, 'viewBounds, widgetViews[selectedWidget].viewBounds);	end;
     ,
     viewQuitScript:
       // must return the value of inherited:?viewQuitScript();func()begin	if debug then print("dragger close");	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(visualDesignerBase, dragger);
StepDeclare(visualDesignerBase, dragger, 'dragger);



stretcher :=
    {text: "",
     viewBounds: {left: 30, top: 30, right: 36, bottom: 36},
     viewFormat: 517,
     viewFlags: 1602,
     viewClickScript:
       func(unit) begin	if debug then print("stretcher");	:drag(unit, nil);	widgetViews[selectedWidget].viewBounds.right:=self.viewbounds.right+5;	widgetViews[selectedWidget].viewBounds.bottom:=self.viewbounds.bottom+5;	widgetArray[selectedWidget].viewBounds:=widgetViews[selectedWidget].viewBounds;	setValue(widgetViews[selectedWidget], 'viewBounds, widgetViews[selectedWidget].viewBounds);		// This is needed for some apps, so it redraws its bounds properly.	if strEqual(widgetViews[selectedWidget].widgetType, "scroller") or	   strEqual(widgetViews[selectedWidget].widgetType, "app") then begin		widgetViews[selectedWidget]:close();		widgetViews[selectedWidget]:open();		end;			setValue(dragger, 'viewBounds, widgetViews[selectedWidget].viewBounds);	if visible(widgetSlipLink.widgetProperties.bounds) then widgetSlipLink.widgetProperties.bounds:getBounds();	baseView:dirty();	TRUEend
       ,
     viewSetupDoneScript:
       func() begin	if NOT selectedWidget then return;	if debug then print("stretcher open");	local b:=widgetViews[selectedWidget].viewBounds;	setValue(self, 'viewBounds, {top:   b.bottom-9, left:    b.right-9,																			right: b.right-3,  bottom:  b.bottom-3});	end
     ,
     viewQuitScript:
       // must return the value of inherited:?viewQuitScript();func()begin	if debug then print("stretcher close");	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     viewJustify: 8388608,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(visualDesignerBase, stretcher);
StepDeclare(visualDesignerBase, stretcher, 'stretcher);



selector :=
    {viewBounds: {left: 154, top: 26, right: 214, bottom: 54},
     viewFormat: 0,
     viewFlags: 3651,
     viewgesturescript:
       func(unit, gestureKind) begin	if debug then print("selector.viewGestureScript:" && gestureKind);	inkOff(unit);	if Visible(widgetSlipLink) and not widgetSlipLink:Closeable() then		return true;	x:=getPoint(firstx, unit);	y:=getpoint(firsty,unit);	local vb;	if selectedWidget then oldSelectedWidget:=selectedWidget;	local newSelectedWidget:=nil;	for i:=0 to length(widgetViews)-1 do // return highest view that contains it		if :isInView(widgetViews[i],x,y) then newSelectedWidget:=i;	if selectedWidget and newSelectedWidget<>oldSelectedWidget then begin // unlite		if oldSelectedWidget<=length(widgetViews)-1 then widgetViews[oldSelectedWidget]:hilite(nil);		if visible(widgetSlipLink) then widgetSlipLink:close();		dragger:close();		stretcher:close();		end;	selectedWidget:=newSelectedWidget;				if gestureKind=aeCaret then begin // caret means insert a new widget		if debug then print("Setting stroke Unit");		strokeUnit:=expandUnit(unit);		:addWidget('all);		return TRUE;		end;			if debug then begin print("found in widget:");print(newSelectedWidget);end;		if NOT newSelectedWidget then  // if it's not a user view, how about quit or new?		if :isInView(statusbar.close,x,y) then begin			if debug then print("click in quit");			addDeferredCall(func() statusbar.close:buttonClickScript(), '[]); 			return TRUE; 			end		else if :isInView(statusbar.info,x,y) then begin statusbar.info:viewClickScript(unit); return TRUE; end		else if :isInView(newbutton,x,y) then begin newbutton:viewClickScript(unit); return TRUE; end		else if :isInView(newField,x,y) then begin newField:viewClickScript(unit); return TRUE; end		else if :isInView(statusbar.tools,x,y) then begin statusbar.tools:viewClickScript(unit); return TRUE; end		else if :isInView(statusbar.action,x,y) then begin			statusbar.action:viewClickScript(unit); 			return TRUE; 			end		else return NIL;					if gestureKind=aeTap then // caret means edit this widget		widgetSlipLink:EditWidget();	else if gestureKind=aeHilite then begin // hilite this widget		widgetViews[selectedWidget]:hilite(true);		dragger:open();		stretcher:open();		end	else if gestureKind=aeScrub then :removeSelectedWidget();			true;end
       ,
     isInView:
       func(view,x,y) begin	// return true if x,y is in view.	if NOT view or NOT visible(view) then return NIL;	vb:=view:globalBox();	if debug then print("isInView:" && x && y);	if debug then print(vb);	return (x>=vb.left and x<=vb.right and y>=vb.top and y<=vb.bottom)end
       ,
     viewQuitScript:
       // must return the value of inherited:?viewQuitScript();func() begin	if debug then print("selector close");	strokeUnit:=NIL;	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     oldSelectedWidget: nil,
     viewSetupFormScript:
       func()begin	local lb := visualDesigner:LocalBox();	lb.bottom := lb.bottom - 18;	self.viewBounds := lb;end
     ,
     viewClass: 74 /* clView */
    };
AddStepForm(visualDesignerBase, selector);
StepDeclare(visualDesignerBase, selector, 'selector);


widgetSlipLink := LinkedSubview(widgetSlipBase,
    {viewBounds: {left: 147, top: 71, right: 225, bottom: 137}});
AddStepForm(visualDesignerBase, widgetSlipLink);
StepDeclare(visualDesignerBase, widgetSlipLink, 'widgetSlipLink);

flags :=
    {
     buttonClickScript:
       func(textIndex) begin	if debug then print("selected index " & textIndex);	if strEqual(listitems[textIndex],"NoFlags") then selectedItems:=[];	local v:=0;	foreach i in selectedItems do		v:=BOR(v,vConstants.(kvalues.(widgetSlipLink.property.name).values[i]));	widgetSlipLink.widget.(widgetSlipLink.property.name):=v;	if debug then print(selectedItems);	if debug then print(v);	:viewSetupFormScript();	:dirty();end
     ,
     viewBounds: {left: 20, top: 20, right: 140, bottom: 200},
     viewLines: 14,
     viewSetupFormScript:
       func() begin	if debug then print("flags.viewSetupFormScript");	local values:=kValues.(widgetSlipLink.property.name).values;	self.listItems:=array(length(values),"");	self.selectedItems:=[];	local v:=widgetSlipLink.widget.(widgetSlipLink.property.name);	for i:=0 to length(values)-1 do begin		if band(v,vConstants.(values[i]))=vConstants.(values[i]) and vConstants.(values[i])>0			then addArraySlot(selectedItems,i); 		listItems[i]:=substr(sprintobject(values[i]),1,nil);		end;	:SetupList();	if debug then print(selectedItems);	end
     ,
     useMultipleSelections: true,
     useScrollers: true,
     viewFlags: 608,
     scrollAmounts: [1,3,20],
     viewFormat: 337,
     viewQuitScript:
       func() begin	widgetSlipLink:showWidget();	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     _proto: @228 /* protoTextList */
    };
AddStepForm(visualDesignerBase, flags);
StepDeclare(visualDesignerBase, flags, 'flags);



title :=
    {title: "Visual Designer",
     viewSetupFormScript:
       func() begin	self.title:="Visual Designer:" && sPrintObject(titleSymbol);	inherited:?viewSetupFormScript();		// this method is defined internallyend
       ,
     _proto: @229 /* protoTitle */
    };
AddStepForm(visualDesignerBase, title);
StepDeclare(visualDesignerBase, title, 'title);



overView :=
    {viewBounds: {left: 154, top: 26, right: 214, bottom: 54},
     viewFormat: 1,
     viewFlags: 3650,
     viewSetupFormScript: func() 	viewBounds:=clone(baseView.viewBounds);,
     declareSelf: 'base,
     SelectItem:
       func() begin	if length(widgetOverview.selectedItems)<>1 then return;	local textIndex:=widgetOverview.selectedItems[0];	if debug then print("selected index " & textIndex);	if selectedWidget and textIndex<>selectedWidget then begin // unlite existing one		if selectedWidget<=length(widgetViews)-1 then widgetViews[selectedWidget]:hilite(nil);		if visible(widgetSlipLink) then widgetSlipLink:close();		dragger:close();		stretcher:close();		end;		selectedWidget:=textIndex;	widgetSlipLink:EditWidget();end
       ,
     viewQuitScript:
       // must return the value of inherited:?viewQuitScript();func() begin	:selectItem();	:showAllWidgets();	inherited:?viewQuitScript();		// this method is defined internallyend
       ,
     viewClass: 74 /* clView */
    };
AddStepForm(visualDesignerBase, overView);
StepDeclare(visualDesignerBase, overView, 'overView);

widgetOverview :=
    {viewBounds: {left: 20, top: 20, right: 140, bottom: 200},
     viewLines: 14,
     viewSetupFormScript:
       func() begin	if debug then print("overview.viewSetupFormScript");	viewLines:=length(widgetArray);	self.listItems:=array(length(widgetArray),"");	if selectedWidget then self.selectedItems:=[selectedWidget];	for i:=0 to length(widgetArray)-1 do 		listItems[i]:=widgetArray[i].widgetType & ":" && widgetArray[i].widgetName;			:SetupList();	if debug then print(selectedItems);	if viewLines=0 then overView:close();	viewBounds:=clone(overView.viewBounds);	viewBounds.bottom:=viewBounds.bottom-20;	viewBounds.top:=viewBounds.top+25;end
     ,
     scrollAmounts: [1,3,20],
     useMultipleSelections: true,
     useScrollers: true,
     viewFlags: 609,
     viewFormat: 1,
     viewFont: ROM_fontSystem10,
     selectedItems: nil,
     _proto: @228 /* protoTextList */
    };
AddStepForm(overView, widgetOverview);
StepDeclare(overView, widgetOverview, 'widgetOverview);



overView_v73_0 :=
    {
     viewFillPattern:
       {	class: 'ditherPattern,	pattern: SetClass(Clone("\uCC663399CC663399"), 'pattern),	foreground: kRGB_Gray5,	backGround: kRGB_White,}
     ,
     viewSetupFormScript:
       func()begin	self.viewFormat := statusBar.viewFormat;end,
     _proto: @73 /* newtStatusBarNoClose */
    };
AddStepForm(overView, overView_v73_0);

overView_v73_0_v478_0 :=
    {viewFlags: 514,
     viewJustify: 134,
     viewBounds: {left: 6, top: -16, right: 19, bottom: -3},
     DoInfoHelp:
       func() begin	PT_aboutVisualDesigner:close();	infoButtonLink:open();	infoButtonLink:showHelp();end
     ,
     DoInfoAbout: func() PT_aboutVisualDesigner:open();,
     DoInfoPrefs:
       func() begin//	PT_aboutVisualDesigner:close();//	infoButtonLink:open();//	infoButtonLink:showPrefs();end
       ,
     buttonClickScript: func() PT_aboutVisualDesigner:open();,
     viewFormat: 67109457,
     _proto: @478 /* protoInfoButton */
    };
AddStepForm(overView_v73_0, overView_v73_0_v478_0);



overView_v73_0_v209_0 :=
    {
     deleteScript:
       func(target, targetView) begin	local items := widgetOverview.selectedItems;	if not items or length(items) = 0 then begin		local message := "Nothing is selected.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));		return;	end;	sort(items, '|<|, nil);	for i:=length(items)-1 to 0 by -1 do begin		selectedWidget:=items[i];		if debug then print("Delete " & selectedWidget);		:removeSelectedWidget();		end;	selectedWidget:=NIL;	widgetOverview.selectedItems:=[];	widgetOverview:close();	widgetOverview:open();	end;
     ,
     duplicateScript:
       func(target, targetView) begin	local items := widgetOverview.selectedItems;	if not items or length(items) = 0 then begin		local message := "Nothing is selected.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));		return;	end;	foreach item in items do begin		selectedWidget:=item;		:duplicateWidget();	end;	selectedWidget:=NIL;	widgetOverview.selectedItems:=[];	widgetOverview:close();	widgetOverview:open();end
     ,
     GetTargetInfo:
       func(targetType) begin	if debug then print("get Target Info");	local targ := widgetOverview.selectedItems;	if debug then Print(targ);	if not targ or Length(targ) = 0 then targ:=nil;	{		target: if targ then {class: 'widget, data: widgetOverview.selectedItems,},		targetView: widgetOverview,	}end
     ,
     moveBackScript:
       func(target, targetView) begin	local items := widgetOverview.selectedItems;	if not items or length(items) = 0 then begin		local message := "Nothing is selected.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));		return;	end;	if length(items)>1 then begin		local message := "Only one item can be moved at a time.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));		return;	end;	selectedWidget:=widgetOverview.selectedItems[0];	if selectedWidget=0 then return;	if debug then print("Move Back " & selectedWidget);		local w:=widgetArray[selectedWidget];	w.order:=w.order-1;	widgetArray[selectedWidget-1].order:=widgetArray[selectedWidget-1].order+1;	removeSlot(widgetArray, selectedWidget);	arrayInsert(widgetArray, w, selectedWidget-1);	selectedWidget:=selectedWidget-1;		widgetOverview:close();	widgetOverview:open();	end
     ,
     routeScripts:
       [ {title: "Edit Properites", routeScript: 'editPropertiesScript, icon: kEditProperties}, {title: "Move Backward", routeScript: 'moveBackScript, icon: kMoveBack}, {title: "Duplicate", routeScript: 'duplicateScript, icon: ROM_routeDuplicateIcon}, {title: "Delete", routeScript: 'deleteScript, icon: ROM_routeDeleteIcon},]
     ,
     viewBounds: {left: -42, top: 2, right: -25, bottom: 15},
     editPropertiesScript:
       func(target, targetView) begin	local items := widgetOverview.selectedItems;	if not items or length(items) = 0 then begin		local message := "Nothing is selected.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));		return;	end;	if length(items)>1 then begin		local message := "Only one item can be edited at a time.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));		return;	end;	overView:close()	end
     ,
     GetRouteScripts: func(targetInfo)begin	routeScripts;end,
     _proto: @209 /* protoActionButton */
    };
AddStepForm(overView_v73_0, overView_v73_0_v209_0);



overView_v73_0_v163_0 :=
    {
     buttonClickScript:
       func() begin	if debug then print("quit called");	inherited:?buttonClickScript();		// this method is defined internallyend
       ,
     viewBounds: {left: -18, top: -16, right: -5, bottom: -3},
     _proto: @163 /* protoLargeClosebox */
    };
AddStepForm(overView_v73_0, overView_v73_0_v163_0);





title := {title: "Visual Designer: Overview", _proto: @229 /* protoTitle */};
AddStepForm(overView, title);
StepDeclare(overView, title, 'title);





// After Script for visualDesignerBase
thisView := visualDesignerBase;
SetPartFrameSlot('mainViewSlot, thisView);partData.mainView := thisView;


constant |layout_VisualDesignerUnit| := visualDesignerBase;
// End of file VisualDesignerUnit
// Beginning of text file visualDesignerUnit.f
definition := EnsureInternal(Clone(kVisualDesignerUnitFrame));definition.visualDesignerUnit := getlayout("visualDesignerUnit");DefineUnit(EnsureInternal('|visualDesignerUnit:NSB|), definition);InstallScript := func(partFrame, removeFrame) nil;RemoveScript := func(removeFrame) nil;
EP£Fð
// End of text file visualDesignerUnit.f
// Beginning of file MainView

// Before Script for NewtCardShell
print(kAppSymbol);if kAppSymbol='|newtCardShell:NSB|	then x := OpenResFileX(HOME & "Monaco.rsrc")	else x := OpenResFileX(HOME & "NewtCard Shell:Monaco.rsrc");DefConst('kFontName, GetNamedResource("ustr", "Font Name", 'string));DefConst('kFontPackage, GetNamedResource("pkg ", "Font Package", 'binary));DefConst('kFontSymbol, Intern(GetNamedResource("ustr", "Font Symbol", 'string)));CloseResFileX(x);

NewtCardShell :=
    {noQuitAllowed: nil,
     executor: nil,
     basicAlpha: nil,
     markedCards: nil,
     GetAppPreferences:
       func()begin	local prefs := GetAppPrefs( kAppSymbol, {drawPaper: {}} );		/* Override the defaults if you'd like	   	   However, if you call ShowGrid/ShowRuler/ShowToolBar, these prefs will	   get saved out to the real prefs so please be careful.  If you want to 	   call these functions, please save off a clone of 'prefs and restore it	   when you quit	  	if prefs.drawPaper then		begin			prefs.drawPaper.drawGrid := nil;			prefs.drawPaper.drawRuler := nil;			prefs.drawPaper.drawToolBar := nil;		end;	*/	prefs;end;
     ,
     killFrames: {},
     kSoupName: nil,
     enableBreak: nil,
     toggleBackgroundMode:
       func()begin	if backgroundMode='card then begin		SetValue(statusBar, 'viewFormat, vfFillCustom);		backgroundMode:='background;		_RF:hideCardViews();		end 	else begin		SetValue(statusBar, 'viewFormat, vfNone);		backgroundMode:='card;		_RF:displayLayer('card);					end;end
     ,
     viewSetupDoneScript:
       func() begin	if debug then print("Shell.ViewSetupDone");	if debug then getglobals().nc:=baseView;	getroot().extrasdrawer:?close();	if not hasSlot(base, 'stepChildren) then base.stepchildren:=clone(base.stepchildren);		getGlobals().(kU):=_RF;	_RF._parent:=executor;	_RF:initSymbolTable();	if not fonts.monaco exists then defStore:restorePackage(kFontPackage);	local runTime:=kRuntime;  if RunTime then begin		systemEntry.useScratch:=NIL;		systemEntry.enableBreak:=NIL;		if connect then connect:hide();		if useScratchBox then useScratchBox:hide();		if enableBreak then enableBreak:hide();		end  else systemEntry.useScratch:=TRUE;  	 	if IamFat then begin // running as a fat package 		interpreter.newStmt:=""; 		interpreter:doRun(); 		end; 		 	if kRuntime and NOT _mainRF._runState then _RF:exBye(NIL);  		if aboutView then :doAda(func() begin aboutView:close(); aboutView:=Nil end, '[], 0);		if GetRoot().|JTables:ENFOUR|.toU then begin		executor.kanjiPresent:=TRUE;		systemEntry.S0.inputForm:='raw		end;		if not strEqual(kTimeOut, "None") and time()>stringToDate(kTimeOut) then begin		:notify(kNotifyAlert,"NewtCard","This copy has timed out. Please contact NS BASIC Corporation at info@nsbasic.com for more information");		:doAda(func() self:close(), '[], 212);		return;		end;	if not interpreter:commsCheck() then serialNumberLink:open();	//Temporary code for initialization	_RF._widgets:={};	_RF._widgetList:=[];	currentTool:='none;end
       ,
     duplicateScript: func(arg1, arg2)	_RF:duplicateStack(nil, nil),
     keyCommands:
       [	{		char: 		$a,							modifiers:	kCommandModifier,				keymessage: '_SelectAll,		name:			"Select All",		category:	"Editing",	},	{		char: 		$d,							modifiers:	kCommandModifier,				keymessage: '_Duplicate,		name:			"Duplicate",		category:	"Editing",	},	{		char: 		$1,							modifiers:	kCommandModifier,				keymessage: '_openStack,		name:			"Open Stack",		category:	"Editing",	},]/********* Other keys that might be useful ***************	{	char: 		$g,						modifiers:	kCommandModifier,			keymessage: '_Group,	name:		"Group",	category:	 kKeyCategoryEditing,	},	{	char: 		$g,						modifiers:	kCommandModifier + kShiftModifier,			keymessage: '_UnGroup,	name:		 "Ungroup",	category:	 kKeyCategoryEditing,	},	{	char: $t,	modifiers: kCommandModifier,	keyMessage: '_SetPlainStyle,	name:"Plain Text",	category: kKeyCategoryEditing,	},	{	char: $b,	modifiers: kCommandModifier,	keyMessage: '_SetBoldStyle,	name:("Bold",	category: kKeyCategoryEditing,	},	{	char: $i,	modifiers: kCommandModifier,	keyMessage: '_SetItalicStyle,	name:"Italic",	category: kKeyCategoryEditing,	},	{	char: $u,	modifiers: kCommandModifier,	keyMessage: '_SetUnderlineStyle,	name:("Underline",	category: kKeyCategoryEditing,	}*/
     ,
     create_RF:
       func() begin	// This creates the runtime environment. All runtime functions run within the scope of this frame			_mainRF:=_RF:=deepclone(kEmptyRF);	killFrames:={U: _mainRF};end
       ,
     viewFormat: 0,
     _GoBack: func(kv)	funcs:Go('back),
     getBackupSoupNames:
       func() begin	local programs:=[];	local user:=getuserconfig('kCurrentUser);	if user 		then user:=getroot().homepage:genSoupName(kExt,user)		else user:=kExt;		foreach soup in getdefaultstore():getSoupNames() do 		if endswith(soup, user) then addArraySlot(programs, soup);	programs	end
     ,
     stack: nil,
     viewQuitScript:
       func() begin	if debug then print("shell.ViewQuitScript");	_mainRF._shuttingDown:=TRUE;	_rf:closeStack();	foreach frame in killFrames do begin		frame._hideUserViewsRunning:=TRUE; 		for i:=0 to length(frame._userViews)-1 do 			if frame._userViews[i].viewCObject then frame._userViews[i]:hide();					frame:=nil;		end;			unRegUserConfigChange(kAppSymbol);	local slotList:=[];	foreach slot, value in systemEntry do		if value=nil and 			NOT strEqual(sPrintObject(slot),"useScratch")  and			NOT strEqual(sPrintObject(slot),"serialNumber")			then addArraySlot(slotList, slot);	foreach slot in slotList do removeSlot(systemEntry, (slot));		if program		then entryUndoChanges(systemEntry) 		else entryFlushXmit(systemEntry,nil); 				 	if debug then removeSlot(getGlobals(), 'nc); 	if debug then removeSlot(getGlobals(), 'pf);	removeSlot(getGlobals(), 'U);				if debug then print("shell.viewQuitScript done");	'postQuit	end
     ,
     GetRouteScripts:
       func(targetInfo) begin	// merge our extraRouteScripts with the system ones	if debug then print("Getting extra route scripts");			local result := inherited:?GetRouteScripts(targetInfo);	// for future compatibility	if not result then result := routeScripts;	result := Clone(result); 	// get writeable copy	ArrayMunger(result, 0, 0, extraRouteScripts, 0, nil);	result;	end
       ,
     systemEntry: nil,
     widgetIcons: kWidgetIcons,
     editor: nil,
     target: nil,
     kShellSymbol: kkShellSymbol,
     setViewBounds:
       func() begin	// set size of base	local x:=getAppParams().appAreaBounds;	baseView.viewBounds:=x;	if program=NIL then begin	    // set size of infoButtonLink      if baseview then setvalue(baseView.infoButtonLink, 'viewBounds, {left: x.left, right: x.right-20,    			top: x.top+10, bottom: x.bottom-10});		end;	end
       ,
     SetStore:
       func() begin	defstore:=GetDefaultStore();	if classof(systemEntry.store)<>'int 		then systemEntry.store:=NIL		else if systemEntry.store>=length(getStores()) then systemEntry.store:=NIL;			if systemEntry.store=NIL then		if strEqual(defstore._proto.name,"Internal")			then systemEntry.store:=0			else systemEntry.store:=1;end
     ,
     doAda:
        func(function, parameters, delay) begin	if debug then print("doAda request" && delay);	addDelayedCall(func() apply(function, parameters), '[], delay);	end
     ,
     IamFat: nil,
     allKeyCommands:
       [	{		char: $n,		modifiers: kCommandModifier,		keyMessage: '_newKeyButtonPress,		name: "New",category: "NewtCard",	},	{		char: $,,modifiers: kCommandModifier,		keyMessage: '_GoBack,		name: "Back",category: "NewtCard",	},	{		char: $h,modifiers: kCommandModifier,		keyMessage: '_GoTitle,		name: "Title Card",category: "NewtCard",	},	{		char: $1,modifiers: kCommandModifier,		keyMessage: '_GoFirst,		name: "First Card",category: "NewtCard",	},	{		char: $2,modifiers: kCommandModifier,		keyMessage: '_GoPrev,		name: "Prev Card",category: "NewtCard",	},	{		char: $3,modifiers: kCommandModifier,		keyMessage: '_GoNext,		name: "Next Card",category: "NewtCard",	},	{		char: $4,modifiers: kCommandModifier,		keyMessage: '_GoLast,		name: "Last Card",category: "NewtCard",	},	{		char: $j,modifiers: kCommandModifier,		keyMessage: '_GoCard,		name: "Jump to Card",category: "NewtCard",	},	{		char: $k,modifiers: kCommandModifier,		keyMessage: '_GoStack,		name: "Jump to Stack",category: "NewtCard",	},	{		char: $m,modifiers: kCommandModifier,		keyMessage: '_GoMessage,		name: "Message",category: "NewtCard",	},	{		char: $g,modifiers: kCommandModifier,		keyMessage: '_Background,		name: "Background",category: "NewtCard",	},	{		char: $ ,modifiers: kCommandModifier,		keyMessage: '_toggleStatusBar,		name: "Status Bar",category: "NewtCard",	},]
     ,
     widgetLib: kWidgetLib,
     viewFlags: 5,
     packItScript:
       func(arg1, arg2) begin	if ModalConfirm("Are you sure you want to copy stack Ò" & stack.name & "Ó into a package?", 'cancelOKdefaultOK) then		_RF:packIt()	end
     ,
     program: nil,
     kVersion: kkVersion,
     card: nil,
     defStore: nil,
     kExt: nil,
     ReorientToScreen: ROM_defRotateFunc,
     MyFormats:
       {viewFormat:	GetLayout("PrintFormat"),	myFrameFormat:  kMyFrameRoutingFormat,	// see Constants file	// put your other formats in this frame and then check out the code in	// the install/removescripts that uses it...};
       ,
     _sub:
       'main  // the current sub
       ,
     _GoPrev: func(kv)	funcs:Go('prev),
     _work: nil,
     kSoupName1: nil,
     viewBounds: {left: -2, top: -1, right: 234, bottom: 312},
     appObject: ["Stack", "Stacks",],
     viewChangedScript:
       func(slot, view)begin	if slot = 'currentTool then		GetRoot():SysBeep();	nil;end
     ,
     _header: nil,
     ShowToolLayer:
       func(tool)begin	if tool = 'none then begin		if currentTool='Widgets then visualDesigner:close();		if currentTool='Drawing then drawlink:close();		:alignButtons({left: [bNew, bEdit, bGo, bFont,], right: [bAction,],});		end;	else if tool = 'drawing then begin		if currentTool='Widgets then begin			visualDesigner:close(); // give Visual Designer a chance to close			:doAda(func() funcs:drawCall(), '[], 23);			end;		else funcs:drawCall();		end;	else if tool = 'widgets then begin		if currentTool='Drawing then drawlink:close();		funcs:VisualDesignerCall();		end;	currentTool:=tool;end
       ,
     _workSoup: nil,
     progPickList: nil,
     chainParam: nil,
     rev: func() substr(kversion, 8, nil);,
     NewtAppBase: nil,
     error:
       func(err) begin	if debug then print("error:");	if debug then print(err);	local ecode:=clone(kError99);	if isFrame(err) then begin		if err.errorcode=nil then err.errorcode:=0;		if err.errorcode=-48404 then ecode:=clone(kError17);   	if err.errorcode=-48019 then ecode:=clone(kErrorM4);   	if err.errorcode=-48210 then ecode:=clone(kError1);   	if err.errorcode=-48214 then ecode:=clone(kError30);		if err.errorcode=-48200 or err.errorcode=-48205 then ecode:=clone(kError31);   	if err.errorcode=-48803 then ecode:=clone(kError63);   	if err.errorcode=-48807 then ecode:=clone(kError18);   	if err.errorcode=-48809 then ecode:=clone(kError20);   	if endsWith(sPrintObject(currentException().name), "div0") then ecode:=clone(kError16);   	if endsWith(sPrintObject(currentException().name),"type.ref.frame")   		and NOT ecode then ecode:=clone(kError29);   	if endsWith(sPrintObject(currentException().name),"outofmem") then begin   		ecode:=clone(kError14);   		executor:initSymbolTable()   		end;		end	else ecode:=err;	// on error trap	if _RF._errorCounter<>0 and _RF._runflag then begin		_RF._runFlag:=_RF._errorCounter;		interpreter.newStmt:=_RF._errorCounter;		_RF._errorCounter:=0;		if interpreter.stmtFrame then interpreter.stmtFrame.err:=nil;		_RF._inputFlag:=nil;		return NIL		end;		//Normal error execution	if interpreter.stmtFrame 		then interpreter.stmtFrame.err:=true		else interpreter.stmtFrame:={err: true, lineNo: _RF._lastLineNo};	if _mainRF._runState then 		if _RF._codePos>=0			then ecode:=[ (_RF:formatLineNo(_RF:getStmtNo(_RF._codePos)) & " :" & ecode[0]) ]			else ecode:=[ (_RF:formatLineNo(_RF._lastLineNo) & " :" & ecode[0]) ];	if editor 		then editor:addlines(ecode)		else getroot():notify(kNotifyAlert, ensureInternal(kShellSymbol && _sub), ensureInternal(ecode[0]));	_RF:setRunStateOff();	executor.enterInProgress:=nil;	playsound(rom_plinkbeep);	return NIL;		end
       ,
     ShowFoundItem: func(entry, finder)	executor:showFoundItem(entry, finder),
     viewOverviewScript:
       func() begin	if debug then print("viewOverviewScript");	if executor._runState then return;	if currentTool<>'none then return;	progPickList:=interpreter:getDirList('popUpStack);	doPopUp(clone(progPickList),0,0,baseView);	end
     ,
     viewJustify: 0,
     extraRouteScripts:
       [ {title: "Duplicate", routeScript: 'duplicateScript, icon: ROM_routeDuplicateIcon}, {title: "Delete", routeScript: 'deleteScript, icon: ROM_routeDeleteIcon}, {title: "PackIt", routeScript: 'packItScript, icon: packItIcon},]
     ,
     screenView: nil,
     _GoStack:
       func(kv)	inputOneLineLink:display("Jump to Stack", "Stack Name", stack.name, 'openStack);
     ,
     interpreter: nil,
     _GoNext: func(kv)	funcs:Go('next),
     baseView: nil,
     _background: func(kv)	:toggleBackgroundMode(),
     _toggleStatusBar: func(kv) statusBar:toggle(),
     currentTool: nil,
     Find:
       func(what, results, scope, statusForm)	executor:find(what, results, scope, statusForm)
     ,
     UpdateAllScrollers:
       func(a, b, c, d, e)	begin	nil;  // do nothing	end;
       ,
     _subs:
       {} // List of subs and IDs of header records in current program. // From gotoKey(kMainsub).subs
       ,
     makeProgramName:
       func(programName) begin	local user:=getUserConfig('kCurrentUser);	local userName:=sPrintObject(user);	local maxLen:=19-(5+strlen(userName));	local p, shortName;		if (p:=strPos(programName, kExt,0))		then shortName:=substr(programName,0, p)		else shortName:=programName;			if user then begin // if in classroom mode		if not endsWith(shortName, getroot().homepage:genSoupName("",userName)) then begin			if strLen(shortName)>maxLen then shortName:=substr(shortName,0,maxLen);			programName:=getroot().homepage:genSoupName(shortname & kExt, user);			end		end	else 		if not strPos(programName,":",0) then programName:=shortName & kExt;		if debug then print(programName);	programName		End
       ,
     ViewPostQuitScript:
       func() begin	if debug then print("shell.viewPostCloseScript");	local app:=getroot().(kAppSymbol);	foreach slot, value in app do		if not '{_proto:{}, _Parent:{}, viewCObject:true}.(slot) then			RemoveSlot(app, slot);	inherited:?viewPostQuitScript()end
     ,
     _RF: {},
     getNonUnionSoup:
       func(soupName) begin	// searches all stores for soup. returns NIL if not found.	local soup:=nil;	foreach store in getstores() do		if not soup then soup:=store:getSoup(soupName);	soup	end
       ,
     appName: "NewtCard",
     _GoFirst: func(kv)	funcs:Go('first),
     deleteScript: func(arg1, arg2)	_RF:deleteStack(),
     _GoCard:
       func(kv)	inputOneLineLink:display("Jump to Card","Card Name","",'go);,
     declareSelf: 'base,
     viewSetupFormScript:
       func() begin	SetKeyView(self, nil);	self:AddKeyCommands(allKeyCommands);	self.newtCard := (kShellSymbol='|newtCard:NSB|);  // TRUE or NIL	local systemSoupTag;	if systemEntry then return;	if debug then print("shell.viewSetupFormScript");	if debug and functions.NSDEnableBreakpoints exists then NSDEnableBreakPoints(true);	if not kRuntime then		if getroot().(kUpdater) exists then getroot().(kUpdater):open();	:create_RF();		baseView:=self;	target := { saveData: {shapes: [], styles: nil, selection: []} };	targetView := self;	newtAppBase := self;	if NOT kRunTIme then begin 		aboutView:=buildContext({_proto: PT_aboutNC}); 		aboutView.kVersion:=kVersion;		aboutView:open();		refreshviews();		end;	:setViewBounds();	if newtCard then begin		systemSoupTag:="NEWTCARD:NSB";		kExt:=":stk";		kSoupName:="SCRATCH" & kExt;		kSoupName1:="SCRATCH1" & kExt;		end	else begin		systemSoupTag:="BASIC:NSB";		kExt:=":bas";		kSoupName:="SCRATCH" & kExt;		kSoupName1:="SCRATCH1" & kExt;		end;		regUserConfigChange(kAppSymbol, func(changeSym) getroot().(kAppSymbol):userChanged(changeSym));	local systemSoup:=getStores()[0]:getSoup(ROM_SystemSoupName);	local systemQuery:=query(systemSoup, {type: 'index, indexPath: 'tag,    								 startKey: systemSoupTag,    								 endTest: func(e) NOT strEqual(e.tag, SystemSoupTag)});	systemEntry:=systemQuery:entry();		// create system soup entry if it doesn't exist already		if NOT systemEntry then begin			systemEntry:=deepclone(kSysEntry);			systemEntry.tag:=systemSoupTag;			systemEntry:=systemSoup:add(systemEntry);			end;   // make sure none of the required slots are NIL	:setStore();	local SE:=systemEntry;	   	foreach slotname,value in kSysEntry do		if NOT hasSlot(SE, slotname) 			then SE.(slotname):=deepClone(value)   		else if SE.(slotname)=nil then SE.(slotname):=deepclone(value);	SE.extr:=deepclone(kSysEntry.extr);	SE.io:="scre";	basicAlphaInUse:=SE.showKeyboard;	noQuitAllowed:=NIL;	screenView:=buildContext(UR('|editorUnit:NSB|, 'editorUnit));	screenView._parent:=self;	// don't open this one until it's needed	interpreter:=buildContext(UR('|interpreterUnit:NSB|, 'interpreterUnit));	interpreter._parent:=self;	interpreter:open();	executor:=buildContext(UR('|executorUnit:NSB|, 'executorUnit));	executor._parent:=self;	executor:open();	visualDesigner:=buildContext(UR('|visualDesignerUnit:NSB|, 'visualDesignerUnit));	visualDesigner._parent:=self;	// don't open this one until it's needed	io:=buildContext(UR('|commsUnit:NSB|, 'commsUnit));	io._parent:=self;	BIT:=buildContext(UR('|commsUnit:NSB|, 'BITUnit));	BIT._parent:=self;	io.connectedTo:=SE.io;	end;
       ,
     visualDesigner: nil,
     _mainRF: nil,
     _GoLast: func(kv)	funcs:Go('last),
     kSignature: kkSignature,
     CopyrightWarning:
       "Use of this product is subject to theterms of the Licence Agreement in the NewtCard Handbook.Copyright 1995-97 © NS BASIC Corporation.If you're reading this, you are pastthe line!"
     ,
     newtcard: nil,
     pickActionScript:
       func(i) begin	if i>0 then begin		local name := progPickList[i];		name := StrMunger(name, StrLen(name)-1, nil, nil, 0, nil);		if debug then Print(name);		_RF:openStack(name);	end;	progPickList:=nil;	end
     ,
     BIT: nil,
     viewClass: 74 /* clView */,
     alignButtons:
       func(buttonList) begin	// this function arrnges the right and left positions of a list of buttons//	local left:=19;//	foreach button in buttonList do begin//		if not hasSlot(button, 'viewbounds) then button.viewbounds:=clone(button.viewbounds);//		setvalue(button, 'viewbounds, RelBounds(left+6, -16, StdButtonWidth(button.text), 13));//		{top: -16, bottom: -3, left: left+6,//			right: left+6+stdbuttonwidth(button.text)});//		left:=left+stdbuttonwidth(button.text)+6;//		end;//	refreshviews();	if length(buttonList.left)>0 then AddArraySlot(buttonList.left, bShow);	arrayInsert(buttonList.left, bInfo, 0);	statusBar.menuLeftButtons := buttonList.left;	local right := [bClose,];	if buttonList.right then		ArrayMunger(right, 1, nil, buttonList.right, 0, nil);	statusBar.menuRightButtons := right;	statusBar:RedoChildren();end
       ,
     makePackage: nil,
     basicAlphaInUse: true,
     setStatusText: func(statusText)	SetValue(StackName, 'text, statusText),
     kClassroomAware: true,
     useScratchBox: nil,
     background: nil,
     _newKeyButtonPress: func(kv)	PressButton(_newKeyButton),
     targetView: nil,
     code: nil,
     kScreenSize: nil,
     aboutView: nil,
     programHeader: nil,
     io: nil,
     _GoMessage: func(kv)	inputOneLineLink:display("Message","","",'message);,
     backgroundMode: 'card,
     _GoTitle: func(kv)	funcs:Go('title),
     UserChanged:
       func(changeSym)	if changeSym='kCurrentUser then		getroot().homepage:multiUserSwitch(kAppSymbol)
    };

StackName :=
    {buttonClickScript: func()beginend,
     text: nil,
     viewBounds: {left: -130, top: 4, right: 0, bottom: 40},
     viewJustify: 33,
     viewFormat: 0,
     viewFont: ROM_fontSystem9Bold,
     viewFlags: 3
     ,
     _proto: @226 /* protoTextButton */
    };
AddStepForm(NewtCardShell, StackName);
StepDeclare(NewtCardShell, StackName, 'StackName);



funcs :=
    {viewFormat: 0,
     editorCallInfo: nil,
     drawCall:
       func() begin	if debug then print('drawCall);	local layer;	_rf:saveWidgetValues('card);	_rf:saveWidgetValues('background);		drawLink:open();	if backgroundMode='background		then layer:=backgroundLayer		else layer:=cardLayer;	drawLink.drawview.canvas.allshapes:=deepclone(layer.shapeArray);	drawLink.drawview.canvas.allstyles:=deepclone(layer.styleFrame);		drawLink.callBackFunc:='drawReturn;		end
     ,
     openApp:
       func(appName)begin	if GetRoot().(Intern(appName)) then		GetRoot().(Intern(appName)):Open();	else begin		local message:="That application is not installed.";		GetRoot():Notify(kNotifyAlert, EnsureInternal(kAppName), EnsureInternal(message));	end;end
     ,
     VisualDesignerCall:
       func() begin	if backgroundMode='background		then begin			_rf:saveWidgetValues('card);			_rf:saveWidgetValues('background);			_rf:hideUserViews();			_rf:displayLayer('backgroundDrawingsOnly)			end		else begin			_rf:saveWidgetValues('card);			_rf:hideCardViews();			_rf:displayLayer('CardDrawingsOnly)			end;			local targ:=baseView.(backgroundMode);	visualDesigner:chain(if not targ.widgets then {} else targ.widgets,'newtCard);	end
     ,
     openStack: func(name)	_RF:openStack(name),
     viewFlags: 0,
     drawReturn:
       func(drawings) begin	if debug then begin		print("drawreturn");		print(drawings.shapes);		print(drawings.styles);		end;	baseView.(backgroundMode).drawings:=drawings;	EntryFlushXmit(baseView.(backgroundMode), nil);	_RF:displayLayer(backgroundMode);end
     ,
     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     visualDesignerReturn:
       func(w) begin	if debug then begin Print("VisualDesignerReturn");Print(w); end;	local targ:=baseView.(backgroundMode);	targ.widgets := DeepClone(w);	EntryFlushXmit(targ, nil);	_RF:displayLayer('background);	if backgroundMode='card then		_RF:displayLayer('card);			_rf:loadSubs(backgroundMode);	end
     ,
     openCard:
       func(name) begin	local ID := StringToNumber(name);	if ID then ID := Floor(ID) else ID := name;	_RF:openCard(ID);end
     ,
     saveStack: func()beginend,
     appToGo: func(appName)	actionSlipLink.target.placesToGo.var := appName,
     message:
       func(text) begin	// send message to NS BASIC	if debug then print("message: " && text);	local result:=_rf:doImmediate(text);		// message may have shut down executor!	if not executor then return nil;		local x:=executor:printFrame({x: result})[0];	x:=substr(x,2,strLen(x)-3);	if debug then print(x);	:doAda(func() inputOneLineLink:display("Message","",x,'message), '[], 5);	end
       ,
     stackToGo:
       func(stackName)	actionSlipLink.target.placesToGo.var := stackName,
     Find: func(text) beginend,
     go:
       func(where) begin	local num;	if not where then return;	if IsSymbol(where) then _RF:exGo({action: where,})	else if BeginsWith(where, "'") then _RF:exGo({action:Intern(SubStr(where,1,nil)),})	else if (num:=StringToNumber(where)) then _RF:exGo({action:'card,var:Floor(num),})	else _RF:exGo({action:'card,var:where,})end
     ,
     editorCall:
       func(module, callback) begin	// (HELP!) Need to save environment so it can be reopened on editorReturn	// save into editorCallInfo		if visible(infoSlipLink) then begin		editorCallInfo:=['info, infoSlipLink.type, module,];		infoSlipLink:close();		end;	if visible(actionSlipLink) then begin		editorCallInfo:=['action, actionSlipLink.widgetIndex, module,];		actionSlipLink:close();		visualDesigner:close();		end;	screenview:script(module, callback);	end
       ,
     cardToGo: func(cardName)	actionSlipLink.target.placesToGo.var := cardName,
     newStack:
       func(name) begin	_RF:newStack({name: name,});	infoSlipLink:Display('stack);	end
     ,
     viewClass: 77 /* clEditView */,
     editorReturn:
       func() begin	_rf:closeRF();		local context, scriptName;	scriptName:=sprintobject(editorCallInfo[2]);	if beginsWith(scriptName, "STACK") then context:='stack else	if beginsWith(scriptName, "BG") then context:='background else	if beginsWith(scriptName, "CD") then context:='card;		if editorCallInfo[0]='action then begin		:showToolLayer('widgets);		visualDesigner:EditWidgetActions(editorCallInfo[1])		end	else begin		:showToolLayer('none);		infoSlipLink:Display(editorCallInfo[1]);		_rf:loadSubs(context);			end;	editorCallInfo:=NIL;	end
     ,
     NewItem:
       func(type, specFrame) begin	if type='background then		_RF:newBackground(specFrame);	else		_RF:newCard(specFrame);end
     ,
     editItem:
       func(item) begin			// stack name changed?	if not strEqual(:makeProgramName(stack.name), systemEntry.programName) then begin		// name was changed		if executor:renameStack(systemEntry.programName, stack.name) // was it successful?			then systemEntry.programName:=:makeProgramName(stack.name)			else stack.name:=				substr(systemEntry.programname, 0, strPos(systemEntry.programName, kExt,0));		end;	if debug then begin		setValue(stackName, 'text,			stack.Name & CR &			background.ID && background.sub && background.name & CR &			card.ID && card.Name);		refreshviews();		end;			EntryFlushXmit(item, nil);	end
       ,
     showStatusButtons:
       func() begin	statusBar.new:show();	statusBar.edit:show();	statusBar.go:show();	//statusBar.tools:show();	statusBar.font:show();	statusBar.action:show();	:alignButtons([statusbar.new, statusbar.edit, statusbar.go, statusbar.font, statusbar.tools,]);	end
       
    };
AddStepForm(NewtCardShell, funcs);
StepDeclare(NewtCardShell, funcs, 'funcs);


infoSlipLink := LinkedSubview(infoBase,
    {viewBounds: {left: 37, top: 281, right: 46, bottom: 287}});
AddStepForm(NewtCardShell, infoSlipLink);
StepDeclare(NewtCardShell, infoSlipLink, 'infoSlipLink);
inputOneLineLink := LinkedSubview(getOneLineBase,
    {viewBounds: {left: 53, top: 281, right: 62, bottom: 287}});
AddStepForm(NewtCardShell, inputOneLineLink);
StepDeclare(NewtCardShell, inputOneLineLink, 'inputOneLineLink);
drawLink := LinkedSubview(drawBase,
    {viewBounds: {left: 23, top: 280, right: 31, bottom: 287}});
AddStepForm(NewtCardShell, drawLink);
StepDeclare(NewtCardShell, drawLink, 'drawLink);
infoButtonLink := LinkedSubview(helpInfoBase,
    {viewBounds: {left: 18, top: 305, right: 23, bottom: 310}});
AddStepForm(NewtCardShell, infoButtonLink);
StepDeclare(NewtCardShell, infoButtonLink, 'infoButtonLink);

PT_aboutNC := {_proto: aboutNewtCard};
AddStepForm(NewtCardShell, PT_aboutNC);
StepDeclare(NewtCardShell, PT_aboutNC, 'PT_aboutNC);



statusBar :=
    {
     GetTargetInfo:
       func(targetType) begin	if debug then print("get Target Info");	local theFrame := {		target: {class: kMyMainDataDefSym,  // set unique class (and register viewDefs on this symbol!)						 data: ""},		targetView: _RF._parent,		appSymbol: kAppSymbol,	};	theFrame;end
       ,
     routeScripts: [],
     viewSetupDoneScript:
       func() begin//	:alignButtons([new, edit,go, font, tools,]);//	:alignButtons([bInfo, bNew, bEdit, bGo, bFont, bShow,]);end
       ,
     menuLeftButtons: [bInfo, bNew, bEdit, bGo, bFont, bShow,],
     menuRightButtons: [bClose, bAction,],
     viewFillPattern:
       {	class: 'ditherPattern,	pattern: SetClass(Clone("\uCC663399CC663399"), 'pattern),	foreground: kRGB_Gray10,	backGround: kRGB_White,}
     ,
     _proto: @73 /* newtStatusBarNoClose */
    };
AddStepForm(NewtCardShell, statusBar);
StepDeclare(NewtCardShell, statusBar, 'statusBar);


actionSlipLink := LinkedSubview(actionSlipBase,
    {viewBounds: {left: 88, top: 283, right: 97, bottom: 290}});
AddStepForm(NewtCardShell, actionSlipLink);
StepDeclare(NewtCardShell, actionSlipLink, 'actionSlipLink);
serialNumberLink := LinkedSubview(SerialNumber,
    {viewBounds: {left: 119, top: 275, right: 130, bottom: 284}});
AddStepForm(NewtCardShell, serialNumberLink);
StepDeclare(NewtCardShell, serialNumberLink, 'serialNumberLink);

Wrapper :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewFlags: 1,
     viewFormat: 0,
     viewJustify: 240,
     viewSetupFormScript:
       func() begin	if debug then print("wrapper opening");	local a := GetAppParams();	self.viewBounds := RelBounds(a.appAreaLeft, a.appAreaTop, a.appAreaWidth, a.appAreaHeight);	end
     ,
     viewClass: 74 /* clView */
    };
AddStepForm(NewtCardShell, Wrapper);
StepDeclare(NewtCardShell, Wrapper, 'Wrapper);

backgroundLayer :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewFlags: 1,
     viewFormat: 0,
     viewJustify: 240,
     viewSetupFormScript:
       func() begin	if debug then print("backgroundLayer opening");	self.stepChildren:=[];	end
     ,
     drawShapes: func() begin	:drawShape(shapeArray, nil);end,
     shapeArray: [],
     styleFrame: nil,
     viewDrawScript:
       func() if CurrentTool <> 'drawing then :doDrawing('drawShapes, NIL);,
     viewClass: 74 /* clView */
    };
AddStepForm(Wrapper, backgroundLayer);
StepDeclare(NewtCardShell, backgroundLayer, 'backgroundLayer);



CardLayer :=
    {viewBounds: {left: 0, top: 0, right: 0, bottom: 0},
     viewFlags: 1,
     viewFormat: 0,
     viewJustify: 240,
     viewSetupFormScript:
       func() begin	if debug then print("cardLayer opening");	self.stepChildren:=[];	end
     ,
     drawShapes: func() begin	:drawShape(shapeArray, nil);end,
     shapeArray: [],
     styleFrame: nil,
     viewDrawScript:
       func() if CurrentTool <> 'drawing then :doDrawing('drawShapes, NIL);,
     viewClass: 74 /* clView */
    };
AddStepForm(Wrapper, CardLayer);
StepDeclare(NewtCardShell, CardLayer, 'CardLayer);





// After Script for NewtCardShell
thisView := NewtCardShell;
if kRunTime then begin // remove all views which have a notRunTime slot	for i:=length(thisView.StepChildren)-1 to 0 by -1 do		if hasSlot(thisView.StepChildren[i],'notRunTime) then begin			print("Stripping SC:" & thisView.StepChildren[i].notRunTime);			arrayRemoveCount(thisView.stepChildren,i,1);			end;	partData.mainView:=thisView; // so it can be an autpartend;thisView.kMaxStepChildren:=length(thisView.StepChildren);



constant |layout_MainView| := NewtCardShell;
// End of file MainView
// Beginning of text file installScripts
if kDebugOn then SetPartFrameSlot('labels, '_buttonbar);if kRunTime and not kFat thenInstallScript:=func(partFrame, removeFrame) begin		if debug then print("Creating Symbol"  && kAppSymbol);		local myApp := partFrame.theForm;		RegisterViewDef(GetLayout("MainView").MyFormats.viewFormat, ensureInternal(kMyMainDataDefSym));		RegisterViewDef(GetLayout("MainView").MyFormats.myFrameFormat, ensureInternal(kMyMainDataDefSym));		getRoot().(ensureInternal(kAppSymbol)):=buildContext(partframe.partData.mainView
£Gø£GÀ);		if hasSlot(getRoot(), kToolsSymbol)			then begin				if not setContains(getRoot().(kToolsSymbol), kAppSymbol)					then addArraySlot(getroot().(kToolsSymbol), ensureInternal(kAppSymbol))				end			else begin				getroot().(ensureInternal(kToolsSymbol)):=ensureInternal([kAppSymbol]);				end;		end;elseInstallScript:=func(partframe) begin		if debug then print("Creating Symbol"  && kAppSymbol);		local myApp := partFrame.theForm;		RegisterViewDef(myApp.MyFormats.viewFormat, kMyMainDataDefSym
£Gø£GÀ);		RegisterViewDef(myApp.MyFormats.myFrameFormat, kMyMainDataDefSym);	end;					RemoveScript :=	func(removeFrame) begin	if debug then print("Removing Symbol"  && kAppSymbol);	UnregisterViewDef(kMyMainViewDefSym, kMyMainDataDefSym);	UnregisterViewDef(kMyFrameViewDefSym, kMyMainDataDefSym);	if kRunTime then begin		if debug then print("removing runtime stuff");		if hasSlot(getRoot(),kAppSymbol) then removeSlot(getRoot(),kAppSymbol);		if hasSlot(getRoot(),kToolsSymbol) 			then setRemove(getR
£Gø£GÀoot().(kToolsSymbol), kappSymbol);		if length(getRoot().(kToolsSymbol))=0 then removeSlot(getroot(), kToolsSymbol);		end;	end;	if kRunTime thenSetPartFrameSlot(	'DeletionScript,					func()					begin						if debug then print("Executing DeletionScript." && kAppSymbol);					end	);
efSym);	if kRunTime then begin		if debug then print("removing runtime stuff");		if hasSlot(getRoot(),kAppSymbol) then removeSlot(getRoot(),kAppSymbol);		if hasSlot(getRoot(),kToolsSymbol) 			then setRemove(getR
// End of text file installScripts



